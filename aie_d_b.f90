!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.9 (r5096) - 24 Feb 2014 16:53
!
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.9 (r5096) - 24 Feb 2014 16:53
!
MODULE AIE_D_B
  IMPLICIT NONE
!=======================================================================
!subroutine nucleati(t, q, relhum, ql, pmid, zm, w, nuci, pcols, pver, sumr, bcmr, &
!                    cld, char, so4_num, soot_num, ndep, rhcrit, lev, tregm, nuhm)
!
!!---------------------------------------------------------------
!! Purpose:
!!  The parameterization of ice nucleation.
!!
!! Method: The current method is based on Liu & Penner (Meteorol. Zeitschrift,2005)
!!  It related the ice crystal number with aerosol number, temperature and the
!!  updraft velocity. It includes homogeneous freezing of sulfate, immersion
!!  freezing on soot, and Meyers et al. (1992) deposition/condensation nucleation
!!
!! PS: ice number calculated is for in-cloud values. For grid average, cloud fraction
!!     needs to be multiplied
!!
!! Authors: Xiaohong Liu, 02/2006
!!          (Xiaohong.Liu@pnl.gov)
!!----------------------------------------------------------------
!
!! use prescribed_aerosols, only: get_aerosol, naer_all, aerosol_diagnostics, &
!!     aerosol_indirect, get_rf_scales, get_int_scales, radforce, idxSUL, idxBG, &
!!     idxSSLT, idxCARBONfirst, numCARBON, idxDUSTfirst, numDUST, idxVOLC
!! use wv_saturation,       only: aqsat
!
!!-----------------------------------------------------
!! Input Arguments
!!
!  integer, intent(in) :: pcols, pver                     ! grid points & vertical layers
!  integer, intent(in) :: lev                             ! layer (if calling single point)
!
!  real, intent(in) :: t(pcols, pver)                 ! temperature (K)
!  real, intent(in) :: q(pcols, pver)                 ! specific humidity (kg/kg)
!  real, intent(inout) :: relhum(pcols, pver)            ! relative humidity (%) wrt water
!  real, intent(in) :: ql(pcols, pver)                ! liquid water mixing ratio (kg/kg)
!  real, intent(in) :: pmid(pcols, pver)              ! model midpoint pressure (hPa)
!  real, intent(in) :: zm(pcols, pver)                ! height abv sfc at midpoints(m)
!  real, intent(in) :: w(pcols, pver)                 ! cloudscale upward vertical velocity (m/s)
!  real, intent(in) :: sumr(pcols, pver)              ! sulfate aerosol mass mixing ratio (kg/kg)
!  real, intent(in) :: bcmr(pcols, pver)              ! black carbon aerosol mass mixing ratio (kg/kg)
!  real, intent(in) :: cld(pcols, pver)               ! newly formed cloud fraction
!  character, intent(in) :: char*1                    ! c or g (for print)
!  real, intent(inout) :: rhcrit(pcols, pver)           ! RHw diagnostic
!  real, intent(inout) ::  tregm(pcols, pver)           ! REGM diagnostic
!
!!
!! Output Arguments
!!
!  real, intent(out) :: nuci(pcols,pver)              ! ice number nucleated in clouds (#/cm^3)
!  real, intent(out) :: ndep(pcols,pver)              ! ice number nucleated in clouds (#/cm^3)
!  real, intent(out) :: nuhm(pcols,pver)              ! ice number nucleated in clouds (#/cm^3)
!  real, intent(out) ::  so4_num(pcols, pver)         ! so4 aerosol number (#/cm^3)
!  real, intent(out) :: soot_num(pcols, pver)         ! soot (hydrophilic) aerosol number (#/cm^3)
!
!!
!! Local workspace
!!
!  integer i, k, lx, kk
!
!! real  scales(naer_all)                             ! scaling factors for aerosol
!  real  rhoair(pcols, pver)                          ! air density (kg/m3)
!  real  re_so4                                       ! volume mean radius for so4 aerosol(m)
!  real  re_soot                                      ! volume mean radius for soot aerosol(m)
!  real  rhosul                                       ! density of sulfate aerosol (kg/m^3)
!  real  rhoboc                                       ! density of bc and oc       (kg/m^3)
!  real  pi,gravit
!  real  sigma                                        ! standard deviation for updraft velocity (cm)
!  real  wn, dw, ww                                   ! work variable
!  real  n1,n1h,niso4,nisoot,nidep,ni,nih             ! nucleated number
!  real  tc,A,B,C,regm,RHw                            ! work variable
!  real  es(pcols, pver)                              ! Saturation vapor pressure (Pa)
!  real  qs(pcols, pver)                              ! Saturation specific humidity (kg/kg)
!  real  tk,esn,ein,deles                             ! work variable
!
!  
!  pi=3.1415927
!  gravit=9.810616
!
!! volume mean radius for so4 and soot aerosols, calculated from assumed size distributions typical
!! of the upper troposphere: SO4 from Jensen et al., 1994; Soot from Pueschel et al., 1992.
!  re_so4=0.0566*1.0e-6   ! Jensen et al., 1994: rg=0.02um, sig=2.3
!  re_soot=0.0896*1.0e-6  ! Pueschel et al., 1992: rg=0.07um, sig=1.5
!
!! sulfate and bc density (kg/m3)
!  rhosul =1.841*1.0e3    ! H2SO4
!  rhoboc =1.000*1.0e3    ! BC
!
!! standard deviation of updraft velocity (cm), measured in INCA campaign of cirrus (Karcher & Strom, 2003)
!  sigma=25.              ! Karcher and Strom, ACP, 2003
!
!! calculate water vapor saturation specific humidity, qs (kg/kg)
!! call aqsat (t, pmid, es, qs, pcols, pcols, pver  ,1       ,pver    )  
!
!  do i=1, pcols
!   do k=1, pver
!
!    rhoair(i,k)=100.*pmid(i,k)/(287*t(i,k))         ! air density (kg/m3)
!
!! calculate so4 and soot number (#/cm^3) from aerosol mixing ratio (kg/kg)
!    so4_num(i,k)=rhoair(i,k)*(sumr(i,k)/rhosul)/(4*pi*re_so4**3/3.0)*1.0e-6
!    soot_num(i,k)=rhoair(i,k)*(bcmr(i,k)/rhoboc)/(4*pi*re_soot**3/3.0)*1.0e-6
!
!! calculate relative humidity (%) with respective to water, used for ice nucleation threshold
!!!! relhum(i,k)=q(i,k) * (pmid(i,k)-0.378*svpl(t(i,k))) / (0.622*svpl(t(i,k))) * 100.   ! use my RHw
!
!!
!! integrate ice nucleated number over the w space (assume normal distribution for w, with
!! mean w(i,k), and standard deviation sigma=25 cm/s).
!! PS: you may want to use your own method of calculating in-cloud updraft velocity
!!
!    ni=0
!    nih=0.   		! RMB to keep track of heterogeneous nucleation
!    tc=t(i,k)-273.15
!
!    tregm = -999.
!
!! calculate ice nucleation only when there are aerosols (aerosol number > 1.e-10)
!    if(so4_num(i,k).ge.1.0e-10 .and. soot_num(i,k).ge.1.0e-10) then
!
!!-----------------------------
!! RHw threshold parameterization (%) for heterogeneous soot nucleation
!    A = 0.0073
!    B = 1.477
!    C = 131.74
!    RHw=A*tc*tc+B*tc+C
!    rhcrit(i,k) = RHw
!
!! ice nucleation takes place only when T<0 C & RH>RHw
!    if(tc.le.0. .and. relhum(i,k).ge.RHw) then 
!
!    do lx=1, 100      ! integrate over the w spectrum divided into 100 bins
!     dw=6*sigma/100
!     wn=w(i,k)*100.0-3*sigma+0.5*dw
!     wn=wn+(lx-1)*dw
!     ww=wn/100.             ! m/s
!
!! calculate ice number nucleated only when w>0, otherwise ice number nucleated = 0
!     if(ww.gt.0.0) then
!
!       A = -1.4938 * log(soot_num(i,k)) + 12.884
!       B = -10.41  * log(soot_num(i,k)) - 67.69
!       regm = A * log(ww) + B
!
!       tregm(i,k) = max(tregm(i,k),regm)
!
!!      if(char.eq.'g' .and. cld(i,k).gt.0.) print *, k,lx,ww,w(i,k),regm,tc
!
!       if(tc.gt.regm) then         ! heterogeneous nucleation-only regime
!         if(tc.lt.-40. .and. ww.gt.1.) then ! exclude T<-40 & W>1m/s from hetero. nucleation
!           call hf(tc,ww,relhum(i,k),so4_num(i,k),niso4)
!           nisoot=0.               ! ice from soot
!           nidep=0.                ! ice from deposition nucleation
!           n1=niso4                ! ice from so4 homogeneosu nucleation
!	   n1h=nisoot		   ! RMB - het nucleation	
!         else
!           call hetero(tc,ww,soot_num(i,k),nisoot,nidep)
!           niso4=0.
!           n1=nisoot+nidep
!	   n1h=n1		   ! RMB - het nucleation
!         endif
!       elseif (tc.lt.regm-5.) then ! homogeneous nucleation-dominated regime
!!        print *, 'tc < (regm-5): ',tc,regm
!         call hf(tc,ww,relhum(i,k),so4_num(i,k),niso4)
!         nisoot=0.
!         nidep=0.
!         n1=niso4
!	 n1h=nisoot		   ! RMB - het nucleation
!       else                        ! interpolate in-between the two regimes
!!        print *, 'tc < regm: ',tc,regm,ww
!         if(tc.lt.-40. .and. ww.gt.1.) then ! exclude T<-40 & W>1m/s from hetero. nucleation
!           call hf(tc,ww,relhum(i,k),so4_num(i,k),niso4)
!           nisoot=0.
!           nidep=0.
!           n1=niso4
!	   n1h=nisoot
!         else
!           call hf(regm-5.,ww,relhum(i,k),so4_num(i,k),niso4)
!           call hetero(regm,ww,soot_num(i,k),nisoot,nidep)
!
!           if(niso4.le.(nisoot+nidep)) then
!             n1=niso4
!	     n1h=0.
!           else
!	     n1=(nisoot+nidep)*((nisoot+nidep)/niso4)**((tc-regm)/5.)
!	     n1h=n1*(niso4-n1)/(niso4-(nisoot+nidep))	! RMB - keeping track of heterogeneous
!           endif
!         endif
!       endif
!
!     else   ! w<0
!       n1=0
!       n1h=0.
!     endif
!
!! integrate ice number over w spectrum (normal distribution)
!     ni=ni+exp(-1.*(wn-w(i,k)*100.0)**2/(2*sigma**2))/(sigma*sqrt(2*pi))*n1*dw
!     nih=nih+exp(-1.*(wn-w(i,k)*100.0)**2/(2*sigma**2))/(sigma*sqrt(2*pi))*n1h*dw	
!    enddo     !end lx
!
!    endif
!    endif
!
!! deposition/condensation nucleation in mixed clouds (-37<T<0C) (Meyers etal., 1992)
!
!    if(tc.lt.0. .and. tc.gt.-37. .and. ql(i,k).gt.0.) then
!      tk=t(i,k)
!      esn = svpl(tk)*100.    ! Pa, vapor pressure over water
!      ein = svpi(tk)*100.    ! Pa, vapor pressure over ice
!      deles = esn - ein
!
!! include height correction for Meyers' formulation, based on INCA campaign (Minikin et al, 2003)
!      if(zm(i,k) .le. 1000.) then
!        nidep=1.e-3*exp(12.96*deles/ein - 0.639)  ! cm^-3, assuming water saturation in-cloud
!      else if(zm(i,k) .le. 7000.) then
!        nidep=1.e-3*exp(12.96*deles/ein - 0.639) * 10**(-(zm(i,k)-1000.)/6700.)
!      else
!        nidep=1.e-3*exp(12.96*deles/ein - 0.639) * 10**(-6000./6700.)
!      endif
!    else
!      nidep=0.
!    endif  
!
!    nuci(i,k)=ni+nidep		! Total number of nucleated ice crystals
!    ndep(i,k)=   nidep		! Number due only to deposition (Only active in mixed phase)
!    nuhm(i,K)=nih+nidep         ! RMB - (inmersion + deposition) i.e. the heterogeneous part of the nucleation
!    if(nuci(i,k).gt.9999.or.nuci(i,k).lt.0) then
!     write(6, *) 'incorrect nucleation parameterization'
!     write(6, *) i,k,nuci(i,k),ni,nidep
!    endif
!
!    if(lev .eq. 0) then
!      kk = k
!     else
!      kk = lev
!    endif
!
!    if(tc .le. 0. .and. char.eq.'x') then
!    write(6,800) char,kk,tc,w(i,k),cld(i,k),ql(i,k),relhum(i,k),RHw, &
!                 ni*1.e6,nidep*1.e6,nuci(i,k)*1.e6,                          &
!                 100.*nuci(i,k)/(so4_num(i,k)+soot_num(i,k)),pmid(i,k)
!    endif
!800 format(a1,'ice:',i3,f7.2,f7.3,f7.4,e11.4,2f7.2,3e11.4,2f7.2)
!
!   enddo  ! k
!  enddo   ! i
!
!  return
!  end subroutine nucleati
!
!
!! real function svpl(tk)
!
!! tk is the absolute temperature
!! Goff-Gratch formula for saturation vapor pressure over
!! a plane surface of pure liquid water, in mbar as
!! function of tk, valid for tc=-100 ?? to 100 degree C
!! (List: Smithsonian Tables)
!!     real tk,y,esat
!
!!     y=373.16/tk
!
!!     esat=10.0**(-7.90298   *(y-1.0)                               &
!!                +5.02808   *ALOG10(y)                              &
!!                -1.3816E-07*((10.0**(11.344*(1.0-(1.0/y))))-1.0)   &
!!                +8.1328E-03*((10.0**(-3.49149*(y-1.0)))-1.0)       &
!!                +ALOG10(1013.246))
!
!!     svpl = esat
!
!  REAL function svpl(t)
!
!! using the formular from CAM 
!! t is the absolute temperature
!!
!! Water
!!
!      real t, ts, ps, es
!      real e1, e2, f1, f2, f3, f4, f5, f
!
!      ps = 1013.246
!      ts = 373.16
!      e1 = 11.344*(1.0 - t/ts)
!      e2 = -3.49149*(ts/t - 1.0)
!      f1 = -7.90298*(ts/t - 1.0)
!      f2 = 5.02808*log10(ts/t)
!      f3 = -1.3816*(10.0**e1 - 1.0)/10000000.0
!      f4 = 8.1328*(10.0**e2 - 1.0)/1000.0
!      f5 = log10(ps)
!      f  = f1 + f2 + f3 + f4 + f5
!      es = (10.0**f)*100.0
!
!      svpl = es/100.   ! mbar
!
!    return
!  end function svpl
!
!! real function svpi(tk)
!
!! tk is the absolute temperature
!! Goff-Gratch formula for saturation vapor pressure over
!! a plane surface of pure water ice, in mbar as
!! function of tk, valid for tc=-100 to 0 degree C
!! (List: Smithsonian Tables)
!!     real tk,y,esat
!
!!     y=273.16/tk
!
!!     esat=10.**(-9.09718 *(y-1.)                       &
!!                -3.56654 *ALOG10(y)                    &
!!                +0.876793*(1.-(1./y))                  &
!!                +ALOG10(6.1071))
!
!!     svpi = esat
!
!  REAL function svpi(t)
!
!!
!! using the formular from CAM
!! t is the absolute temperature
!!
!! Ice
!!
!      real t, t0, term1, term2, term3, es
!
!      t0    = 273.15
!      term1 = 2.01889049/(t0/t)
!      term2 = 3.56654*log(t0/t)
!      term3 = 20.947031*(t0/t)
!      es    = 575.185606e10*exp(-(term1 + term2 + term3))
!
!      svpi = es/100.   ! mbar
!
!    return
!  end function svpi
!
!
!  subroutine hetero(T,ww,Ns,Nis,Nid)
!
!! heterogeneous ice nucleation on soot
!
!      real, intent(in)  :: T, ww, Ns
!      real, intent(out) :: Nis, Nid
!
!      real A11,A12,A21,A22,B11,B12,B21,B22
!      real A1,A2,A3,B1,B2,B3,C1,C2,C3
!      real A,B,C
!      real si_max
!
!!---------------------------------------------------------------------
!! parameters
!
!      A11 = 0.0263
!      A12 = -0.0185
!      A21 = 2.758
!      A22 = 1.3221
!      B11 = -0.008
!      B12 = -0.0468
!      B21 = -0.2667
!      B22 = -1.4588
!
!!     ice number from soot nucleation (cm^-3)
!
!      B = (A11+B11*log(Ns)) * log(ww) + (A12+B12*log(Ns))
!      C =  A21+B21*log(Ns)
!
!      Nis = exp(A22) * Ns**B22 * exp(B*T) * ww**C
!      Nis = min(Nis,Ns)
!
!!     ice from deposition nucleation (cm^-3)
!
!      A1 = -0.2035*Ns**(-0.8854)
!      A2 =  0.2725*Ns**(-0.415)
!      A3 = -0.0069
!
!      B1 = -24.759*Ns**(-0.8831)
!      B2 =  29.893*Ns**(-0.4067)
!      B3 = -0.672
!
!      C1 = -732.36*Ns**(-0.8712)
!      C2 =  822.49*Ns**(-0.3951)
!      C3 =  6.702
!
!      A = A1*ww**2. + A2*ww + A3
!      B = B1*ww**2. + B2*ww + B3
!      C = C1*ww**2. + C2*ww + C3
!
!      si_max = A * T**2. + B * T + C   ! max supersaturation (%)
!      si_max = min(max(si_max,10.),100.)
!
!!  calculate ice number from deposition nucleation based on Meyers et al. (1992)
!!     Nid = 1.e-3 * exp(-0.639 + 0.1296*si_max)
!      Nid = 0.0         ! don't include deposition nucleation here
!
!      return
!  end subroutine hetero
!
!
!  subroutine hf(T,ww,RH,Na,Ni)
!
!! homogeneous ice nucleation of so4
!
!      real, intent(in)  :: T, ww, RH, Na
!      real, intent(out) :: Ni
!
!      real    A1_fast,A21_fast,A22_fast,B1_fast,B21_fast,B22_fast
!      real    A2_fast,B2_fast
!      real    C1_fast,C2_fast,k1_fast,k2_fast
!      real    A1_slow,A2_slow,B1_slow,B2_slow,B3_slow
!      real    C1_slow,C2_slow,k1_slow,k2_slow
!      real    regm
!      real    A,B,C
!      real    RHw
!
!!---------------------------------------------------------------------
!! parameters
!
!      A1_fast  =0.0231
!      A21_fast =-1.6387  !(T>-64 deg)
!      A22_fast =-6.045   !(T<=-64 deg)
!      B1_fast  =-0.008
!      B21_fast =-0.042   !(T>-64 deg)
!      B22_fast =-0.112   !(T<=-64 deg)
!      C1_fast  =0.0739
!      C2_fast  =1.2372
!
!      A1_slow  =-0.3949
!      A2_slow  =1.282
!      B1_slow  =-0.0156
!      B2_slow  =0.0111
!      B3_slow  =0.0217
!      C1_slow  =0.120
!      C2_slow  =2.312
!
!      Ni = 0.0
!
!!----------------------------
!! threshold RHw (%) for homogeneous nucleation
!      A = 6.0e-4*log(ww)+6.6e-3
!      B = 6.0e-2*log(ww)+1.052
!      C = 1.68  *log(ww)+129.35
!      RHw=A*T*T+B*T+C
!
!! homogeneous nucleation takes place only when T<-37C & RH>RHw
!      if(T.le.-37.0.and.RH.ge.RHw) then
!
!        regm = 6.07*log(ww)-55.0
!
!        if(T.ge.regm) then    ! fast-growth regime
!
!          if(T.gt.-64.0) then
!            A2_fast=A21_fast
!            B2_fast=B21_fast
!          else
!            A2_fast=A22_fast
!            B2_fast=B22_fast
!          endif
!
!          k1_fast = exp(A2_fast + B2_fast*T + C2_fast*log(ww))
!          k2_fast = A1_fast+B1_fast*T+C1_fast*log(ww)
!
!          Ni = k1_fast*Na**(k2_fast)
!          Ni = min(Ni,Na)
!
!        else       ! slow-growth regime
!
!          k1_slow = exp(A2_slow + (B2_slow+B3_slow*log(ww))*T + C2_slow*log(ww))
!          k2_slow = A1_slow+B1_slow*T+C1_slow*log(ww)
!
!          Ni = k1_slow*Na**(k2_slow)
!          Ni = min(Ni,Na)
!
!        endif
!
!      end if
!
!      return
!  end subroutine hf
!!**********************************************************************************
!subroutine nucleaticon(t, q, relhum, ql, pmid, zm, w, nuci, pcols,  &
!                    pver,sumr,bcmr,cld, char, so4_num, soot_num,  &
!!                   ndep,rhcrit,lev,tregm,aso4)  ! dm need aso4
!                    ndep,rhcrit,lev,tregm)
!!---------------------------------------------------------------
!! Purpose:
!!  The parameterization of ice nucleation.
!!
!! Method: The current method is based on Liu & Penner (Meteorol. Zeitschrift,2005)
!!  It related the ice crystal number with aerosol number, temperature and the
!!  updraft velocity. It includes homogeneous freezing of sulfate, immersion
!!  freezing on soot, and Meyers et al. (1992) deposition/condensation nucleation
!!
!! PS: ice number calculated is for in-cloud values. For grid average, cloud fraction
!!     needs to be multiplied
!!
!! Authors: Xiaohong Liu, 02/2006
!!          (Xiaohong.Liu@pnl.gov)
!!----------------------------------------------------------------
!
!! use prescribed_aerosols, only: get_aerosol, naer_all, aerosol_diagnostics, &
!!     aerosol_indirect, get_rf_scales, get_int_scales, radforce, idxSUL, idxBG, &
!!     idxSSLT, idxCARBONfirst, numCARBON, idxDUSTfirst, numDUST, idxVOLC
!! use wv_saturation,       only: aqsat
!
!!-----------------------------------------------------
!! Input Arguments
!!
!  integer, intent(in) :: pcols, pver                     ! grid points & vertical layers
!  integer, intent(in) :: lev                             ! layer (if calling single point)
!
!  real, intent(in) :: t(pcols, pver)                 ! temperature (K)
!  real, intent(in) :: q(pcols, pver)                 ! specific humidity (kg/kg)
!  real, intent(inout) :: relhum(pcols, pver)            ! relative humidity (%) wrt water
!  real, intent(in) :: ql(pcols, pver)                ! liquid water mixing ratio (kg/kg)
!  real, intent(in) :: pmid(pcols, pver)              ! model midpoint pressure (hPa)
!  real, intent(in) :: zm(pcols, pver)                ! height abv sfc at midpoints(m)
!  real, intent(in) :: w(pcols, pver)                 ! cloudscale upward vertical velocity (m/s)
!  real, intent(in) :: sumr(pcols, pver)              ! sulfate aerosol mass mixing ratio (kg/kg)
!  real, intent(in) :: bcmr(pcols, pver)              ! black carbon aerosol mass mixing ratio (kg/kg)
!! real, intent(in) :: aso4(pcols,pver)              ! ammonium sulfate (cm^3)
!  real, intent(in) :: cld(pcols, pver)               ! newly formed cloud fraction
!  character, intent(in) :: char*1                    ! c or g (for print)
!  real, intent(inout) :: rhcrit(pcols, pver)           ! RHw diagnostic
!  real, intent(inout) ::  tregm(pcols, pver)           ! REGM diagnostic
!!!  real, intent(in) :: nl(pver)                        ! Liquid concentration
!
!!
!! Output Arguments
!!
!  real, intent(out) :: nuci(pcols,pver)              ! ice number nucleated in clouds (#/cm^3)
!  real, intent(out) :: ndep(pcols,pver)              ! ice number nucleated in clouds (#/cm^3)
!  real, intent(out) ::  so4_num(pcols, pver)         ! so4 aerosol number (#/cm^3)
!  real, intent(out) :: soot_num(pcols, pver)         ! soot (hydrophilic) aerosol number (#/cm^3)
!
!!
!! Local workspace
!!
!  integer i, k, lx, kk
!
!! real  scales(naer_all)                             ! scaling factors for aerosol
!  real  rhoair(pcols, pver)                          ! air density (kg/m3)
!  real  re_so4                                       ! volume mean radius for so4 aerosol(m)
!  real  re_soot                                      ! volume mean radius for soot aerosol(m)
!  real  rhosul                                       ! density of sulfate aerosol (kg/m^3)
!  real  rhoboc                                       ! density of bc and oc       (kg/m^3)
!  real  pi,gravit
!  real  sigma                                        ! standard deviation for updraft velocity (cm)
!  real  wn, dw, ww                                   ! work variable
!  real  n1,niso4,nisoot,nidep,ni                     ! nucleated number
!  real  tc,A,B,C,regm,RHw                            ! work variable
!  real  es(pcols, pver)                              ! Saturation vapor pressure (Pa)
!  real  qs(pcols, pver)                              ! Saturation specific humidity (kg/kg)
!  real  tk,esn,ein,deles 
!
!
!  pi=3.1415927
!  gravit=9.810616
!
!! volume mean radius for so4 and soot aerosols, calculated from assumed size distributions typical
!! of the upper troposphere: SO4 from Jensen et al., 1994; Soot from Pueschel et al., 1992.
!  re_so4=0.0566*1.0e-6   ! Jensen et al., 1994: rg=0.02um, sig=2.3
!  re_soot=0.0896*1.0e-6  ! Pueschel et al., 1992: rg=0.07um, sig=1.5
!
!! sulfate and bc density (kg/m3)
!  rhosul =1.841*1.0e3    ! H2SO4
!  rhoboc =1.000*1.0e3    ! BC
!
!! standard deviation of updraft velocity (cm), measured in INCA campaign of cirrus (Karcher & Strom, 2003)
!  sigma=25.              ! Karcher and Strom, ACP, 2003
!
!! calculate water vapor saturation specific humidity, qs (kg/kg)
!! call aqsat (t, pmid, es, qs, pcols, pcols, pver  ,1       ,pver    )
!
!  do i=1, pcols
!   do k=1, pver
!    rhoair(i,k)=100.*pmid(i,k)/(287*t(i,k))         ! air density (kg/m3)
!  
!! calculate so4 and soot number (#/cm^3) from aerosol mixing ratio (kg/kg)
!     
!     so4_num(i,k)=rhoair(i,k)*(sumr(i,k)/rhosul)/(4*pi*re_so4**3/3.0)*1.0e-6
!     soot_num(i,k)=rhoair(i,k)*(bcmr(i,k)/rhoboc)/(4*pi*re_soot**3/3.0)*1.0e-6
!  
!! calculate relative humidity (%) with respective to water, used for ice nucleation threshold
!!!! relhum(i,k)=q(i,k) * (pmid(i,k)-0.378*svpl(t(i,k))) / (0.622*svpl(t(i,k))) * 100.   ! use my RHw
!
!! integrate ice nucleated number over the w space (assume normal distribution for w, with
!! mean w(i,k), and standard deviation sigma=25 cm/s).
!! PS: you may want to use your own method of calculating in-cloud updraft velocity
!! 
!    ni=0
!    tc=t(i,k)-273.15                                 
!  
!    tregm = -999.                                    
!  
!! calculate ice nucleation only when there are aerosols (aerosol number > 1.e-10)
!    if(so4_num(i,k).ge.1.0e-10 .and. soot_num(i,k).ge.1.0e-10) then
!  
!!-----------------------------                       
!! RHw threshold parameterization (%) for heterogeneous soot nucleation
!! Both immersion and depostion nucleation by soot
!    A = 0.0073
!    B = 1.477
!    C = 131.74
!    RHw=A*tc*tc+B*tc+C
!    rhcrit(i,k) = RHw
!
!! ice nucleation takes place only when T<0 C & RH>RHw
!    if(tc.le.0. .and. relhum(i,k).ge.RHw) then 
!
!    do lx=1, 100      ! integrate over the w spectrum divided into 100 bins
!     dw=6*sigma/100
!     wn=w(i,k)*100.0-3*sigma+0.5*dw
!     wn=wn+(lx-1)*dw
!     ww=wn/100.             ! m/s
!  
!! calculate ice number nucleated only when w>0, otherwise ice number nucleated = 0
!     if(ww.gt.0.0) then 
!
!       A = -1.4938 * log(soot_num(i,k)) + 12.884
!       B = -10.41  * log(soot_num(i,k)) - 67.69
!       regm = A * log(ww) + B
!       tregm(i,k) = max(tregm(i,k),regm)
!
!!      if(char.eq.'g' .and. cld(i,k).gt.0.) print *, k,lx,ww,w(i,k),regm,tc
!
!       if(tc.gt.regm) then         ! heterogeneous nucleation-only regime
!         if(tc.lt.-40. .and. ww.gt.1.) then ! exclude T<-40 & W>1m/s from hetero. nucleation
!           call hfc(tc,ww,relhum(i,k),so4_num(i,k),niso4)
!           nisoot=0.               ! ice from soot
!           nidep=0.                ! ice from deposition nucleation
!           n1=niso4                ! ice from so4 homogeneosu nucleation
!         else
!           call heteroc(tc,ww,soot_num(i,k),nisoot,nidep)
!           niso4=0.
!           n1=nisoot+nidep
!         endif
!       elseif (tc.lt.regm-5.) then ! homogeneous nucleation-dominated regime
!
!         call hfc(tc,ww,relhum(i,k),so4_num(i,k),niso4)
!         nisoot=0.
!         nidep=0.
!         n1=niso4
!       else                        ! interpolate in-between the two regimes
!
!         if(tc.lt.-40. .and. ww.gt.1.) then ! exclude T<-40 & W>1m/s from hetero. nucleation
!           call hfc(tc,ww,relhum(i,k),so4_num(i,k),niso4)
!           nisoot=0.
!           nidep=0.
!           n1=niso4
!         else
!           call hfc(regm-5.,ww,relhum(i,k),so4_num(i,k),niso4)
!           call heteroc(regm,ww,soot_num(i,k),nisoot,nidep)
!
!           if(niso4.le.(nisoot+nidep)) then
!             n1=niso4
!           else
!             n1=(nisoot+nidep)*((nisoot+nidep)/niso4)**((tc-regm)/5.)
!           endif
!         endif
!       endif
!
!     else   ! w<0
!       n1=0
!     endif
!
!! integrate ice number over w spectrum (normal distribution)
!     ni=ni+exp(-1.*(wn-w(i,k)*100.0)**2/(2*sigma**2))/(sigma*sqrt(2*pi))*n1*dw
!    enddo     !end lx
!
!    endif
!    endif
!       
!! deposition/condensation nucleation in mixed clouds (-37<T<0C) (Meyers etal., 1992)
!           
!    if(tc.lt.0. .and. tc.gt.-37. .and. ql(i,k).gt.0.) then
!      tk=t(i,k)
!      esn = svplc(tk)*100.    ! Pa, vapor pressure over water 
!      ein = svpic(tk)*100.    ! Pa, vapor pressure over ice
!      deles = esn - ein
!           
!! include height correction for Meyers' formulation, based on INCA campaign (Minikin et al, 2003)
!      if(zm(i,k) .le. 1000.) then
!        nidep=1.e-3*exp(12.96*deles/ein - 0.639)  ! cm^-3, assuming water saturation in-cloud
!      else if(zm(i,k) .le. 7000.) then
!        nidep=1.e-3*exp(12.96*deles/ein - 0.639) * 10**(-(zm(i,k)-1000.)/6700.)
!      else
!        nidep=1.e-3*exp(12.96*deles/ein - 0.639) * 10**(-6000./6700.)
!      endif
!    else
!      nidep=0.
!    endif  
!           
!    nuci(i,k)=ni+nidep
!    ndep(i,k)=   nidep
!           
!         
!    if(nuci(i,k).gt.9999.or.nuci(i,k).lt.0) then
!     write(6, *) 'incorrest nucleation parameterization'
!     write(6, *) i,k,nuci(i,k),ni,nidep
!    endif    
!             
!    if(lev .eq. 0) then
!      kk = k 
!     else  
!      kk = lev
!    endif
!
!   enddo  ! k
!  enddo   ! i
!
!  return
!  end subroutine nucleaticon
!
!
!! real function svpl(tk)
!
!! tk is the absolute temperature
!! Goff-Gratch formula for saturation vapor pressure over
!! a plane surface of pure liquid water, in mbar as
!! function of tk, valid for tc=-100 ?? to 100 degree C
!! (List: Smithsonian Tables)
!!     real tk,y,esat
!
!!     y=373.16/tk
!
!!     esat=10.0**(-7.90298   *(y-1.0)                               &
!!                +5.02808   *ALOG10(y)                              &
!!                -1.3816E-07*((10.0**(11.344*(1.0-(1.0/y))))-1.0)   &
!!                +8.1328E-03*((10.0**(-3.49149*(y-1.0)))-1.0)       &
!!                +ALOG10(1013.246))
!
!!     svpl = esat
!
!  real function svplc(t)
!
!! using the formular from CAM
!! t is the absolute temperature
!!
!! Water
!!
!      real t, ts, ps, es
!      real e1, e2, f1, f2, f3, f4, f5, f
!
!      ps = 1013.246
!      ts = 373.16
!      e1 = 11.344*(1.0 - t/ts)
!      e2 = -3.49149*(ts/t - 1.0)
!      f1 = -7.90298*(ts/t - 1.0)
!      f2 = 5.02808*log10(ts/t)
!      f3 = -1.3816*(10.0**e1 - 1.0)/10000000.0
!      f4 = 8.1328*(10.0**e2 - 1.0)/1000.0
!      f5 = log10(ps)
!      f  = f1 + f2 + f3 + f4 + f5
!      es = (10.0**f)*100.0
!   
!      svplc = es/100.   ! mbar
!
!    return
!  end function svplc
!  real function svpic(t)
!
!!
!! using the formular from CAM
!! t is the absolute temperature
!!
!! Ice
!!
!      real t, t0, term1, term2, term3, es
!
!      t0    = 273.15
!      term1 = 2.01889049/(t0/t)
!      term2 = 3.56654*log(t0/t)
!      term3 = 20.947031*(t0/t)
!      es    = 575.185606e10*exp(-(term1 + term2 + term3))
!
!      svpic = es/100.   ! mbar
!
!    return
!  end function svpic
!  subroutine heteroc(T,ww,Ns,Nis,Nid)
!
!! heterogeneous ice nucleation on soot
!
!      real, intent(in)  :: T, ww, Ns
!      real, intent(out) :: Nis, Nid
!
!      real A11,A12,A21,A22,B11,B12,B21,B22
!      real A1,A2,A3,B1,B2,B3,C1,C2,C3
!      real A,B,C
!      real si_max
!
!!---------------------------------------------------------------------
!! parameters
!
!      A11 = 0.0263
!      A12 = -0.0185
!      A21 = 2.758
!      A22 = 1.3221
!      B11 = -0.008
!      B12 = -0.0468
!      B21 = -0.2667
!      B22 = -1.4588
!
!!     ice number from soot nucleation (cm^-3)
!
!      B = (A11+B11*log(Ns)) * log(ww) + (A12+B12*log(Ns))
!      C =  A21+B21*log(Ns)
!
!      Nis = exp(A22) * Ns**B22 * exp(B*T) * ww**C
!
!
!      Nis = min(Nis,Ns)
!
!!     ice from deposition nucleation (cm^-3)
!
!      A1 = -0.2035*Ns**(-0.8854)
!      A2 =  0.2725*Ns**(-0.415)
!      A3 = -0.0069
!
!      B1 = -24.759*Ns**(-0.8831)
!      B2 =  29.893*Ns**(-0.4067)
!      B3 = -0.672
!
!      C1 = -732.36*Ns**(-0.8712)
!      C2 =  822.49*Ns**(-0.3951)
!      C3 =  6.702
!      A = A1*ww**2. + A2*ww + A3
!      B = B1*ww**2. + B2*ww + B3
!      C = C1*ww**2. + C2*ww + C3
!      
!      si_max = A * T**2. + B * T + C   ! max supersaturation (%)
!      si_max = min(max(si_max,10.),100.)
!      
!!  calculate ice number from deposition nucleation based on Meyers et al. (1992)
!!     Nid = 1.e-3 * exp(-0.639 + 0.1296*si_max)
!      Nid = 0.0         ! don't include deposition nucleation here
!
!
!      return
!  end subroutine heteroc
!      
!      
!  subroutine hfc(T,ww,RH,Na,Ni)
!      
!! homogeneous ice nucleation of so4
!      
!      real, intent(in)  :: T, ww, RH, Na
!      real, intent(out) :: Ni
!
!      real    A1_fast,A21_fast,A22_fast,B1_fast,B21_fast,B22_fast
!      real    A2_fast,B2_fast
!      real    C1_fast,C2_fast,k1_fast,k2_fast
!      real    A1_slow,A2_slow,B1_slow,B2_slow,B3_slow
!      real    C1_slow,C2_slow,k1_slow,k2_slow
!      real    regm
!      real    A,B,C
!      real    RHw
!      
!!---------------------------------------------------------------------
!! parameters
!
!      A1_fast  =0.0231
!      A21_fast =-1.6387  !(T>-64 deg)
!      A22_fast =-6.045   !(T<=-64 deg)
!      B1_fast  =-0.008
!      B21_fast =-0.042   !(T>-64 deg)
!      B22_fast =-0.112   !(T<=-64 deg)
!      C1_fast  =0.0739
!      C2_fast  =1.2372
!      
!      A1_slow  =-0.3949
!      A2_slow  =1.282
!      B1_slow  =-0.0156
!      B2_slow  =0.0111
!      B3_slow  =0.0217
!      C1_slow  =0.120
!      C2_slow  =2.312
!
!      Ni = 0.0
!
!!----------------------------
!! threshold RHw (%) for homogeneous nucleation
!      A = 6.0e-4*log(ww)+6.6e-3
!      B = 6.0e-2*log(ww)+1.052
!      C = 1.68  *log(ww)+129.35
!      RHw=A*T*T+B*T+C
!
!! homogeneous nucleation takes place only when T<-37C & RH>RHw
!      if(T.le.-37.0.and.RH.ge.RHw) then
!
!        regm = 6.07*log(ww)-55.0
!
!        if(T.ge.regm) then    ! fast-growth regime
!
!          if(T.gt.-64.0) then
!            A2_fast=A21_fast
!            B2_fast=B21_fast
!          else
!            A2_fast=A22_fast
!            B2_fast=B22_fast
!          endif
!
!          k1_fast = exp(A2_fast + B2_fast*T + C2_fast*log(ww))
!          k2_fast = A1_fast+B1_fast*T+C1_fast*log(ww)
!
!          Ni = k1_fast*Na**(k2_fast)
!          Ni = min(Ni,Na)
!
!        else       ! slow-growth regime
!
!          k1_slow = exp(A2_slow + (B2_slow+B3_slow*log(ww))*T + C2_slow*log(ww))
!          k2_slow = A1_slow+B1_slow*T+C1_slow*log(ww)
!
!          Ni = k1_slow*Na**(k2_slow)
!
!          Ni = min(Ni,Na)
!
!        endif
!      end if
!      
!      return
!  end subroutine hfc
!!**********************************************************************************
!  subroutine contact_freezing(nliq,nice,cldwat,t,pmid,dust,dt,ni_frzc)
!
!    real ni_frzc, na0, nacon, mfp
!
!    real nliq          ! in-cloud activated liquid aerosol droplets (#/m3)
!    real nice          ! in-cloud activated frozen aerosol droplets (#/m3)
!
!    real cldwat        ! in-cloud water mixing ratio
!    real t             ! layer temperature (K)
!    real pmid          ! layer pressure (hPa)    
!
!    real dt            ! physics timestep (seconds)
!    real rhowater,rhodst,dfaer,rlv,viscosity,tfac,slip
!    
!    integer nd, n1, n
!    parameter ( nd = 1 , n1 = 4 ) ! 5 dust bins; 4 sub-bins in first bin
!
!    real dust(nd)      ! dust mass concentration (ug/m3) (multiply by 1e9 for kg/m3)
!
!    real rn_dst(n1)    ! dust number mean radius (m)
!    data rn_dst /0.12e-6,0.21e-6,0.39e-6,0.71e-6/
!    
!    real rv_dst(n1)    ! dust volume mean radius (m)
!    data rv_dst /0.14e-6,0.24e-6,0.45e-6,0.80e-6/
!
!    real frac(n1)    ! dust mass fraction
!    data frac  /0.01053,0.08421,0.25263,0.65263/
!
!    logical default    ! use the default values from the original code
!    data    default /.false./
!
!
!    pi=3.1415927
!    rhowater=1.0e3     ! density of water (kg/m3)
!    rhodst=2.500*1.0e3 ! density of dust  (kg/m3)
!
!! contact freezing (-40<T<-3 C) (Young, 1974)
!          if(t.lt.270.16 .and. t.gt.233.15) then
!
!          if(default) then
!            dfaer=1.0e-10     ! or 1.4e-8 m2/s,    aerosol diffusivity -- size dependent
!            na0=2.0e5         ! constant with height
!            nacon=na0*(270.16-t)**1.3   ! contact IN number density (m^-3)
!
!            rlv=(3.*cldwat/(4.*pi*rhowater*nliq))**(1./3.)   ! cloud droplet size (m)
!               
!            ni_frzc = dfaer*4.*pi*rlv*nacon*nliq*dt          ! ice number change in dt
!
!           else
!
!! based on dust bins 1-5 (0.1-1.0, 1-1.8, 1.8-3, 3-6, 6-10 um radius)
!!
!            viscosity=1.8e-5*(t/298.0)**0.85                                 ! Viscosity (kg/m/s)
!            mfp=2.0*viscosity/(100.*pmid*sqrt(8.0*28.96e-3/(pi*8.314409*t))) ! Mean free path (m)
!              
!            tfac = (270.16-t)**1.3
!
!            rlv=(3.*cldwat/(4.*pi*rhowater*nliq))**(1./3.)
!
!            ni_frzc = 0.
!
!            do n = 1,n1
! 	      slip=1.0 + (mfp/rn_dst(n))*(1.257 +(0.4*exp(-(1.1*rn_dst(n)/mfp)))) ! Slip correction factor
!
!              dfaer=1.381e-23*t*slip/(6.*pi*viscosity*rn_dst(n))    ! aerosol diffusivity (m2/s)
!
!              na0=(1.e-9*frac(n)*dust(1)/rhodst)/(4.*pi*rv_dst(n)**3/3.0)   ! m^-3
!
!              nacon=na0*tfac
!!!!           print *, n,na0,dfaer,slip,mfp,viscosity,rn_dst(n)
!
!              ni_frzc=ni_frzc + dfaer*nacon*4.*pi*rlv*nliq*dt    ! contact freezing; sum over bins
!            end do
!
!          endif
!
!           else
!            ni_frzc = 0.
!          endif
!    return
!  end subroutine contact_freezing
!!**********************************************************************************
!    subroutine contact_frz_con(nliq,nice,cldwat,t,pmid,dust,dt,ni_frzc)
!
!    real ni_frzc, na0, nacon, mfp
!
!    real nliq          ! in-cloud activated liquid aerosol droplets (#/m3)
!    real nice          ! in-cloud activated frozen aerosol droplets (#/m3)
!
!    real cldwat        ! in-cloud water mixing ratio
!    real t             ! layer temperature (K)
!    real pmid          ! layer pressure (hPa)
!
!    real dt            ! physics timestep (seconds)
!
!    integer nd,n1,n
!    parameter ( nd = 1 , n1 = 4 ) ! 5 dust bins; 4 sub-bins in first bin
!
!    real dust(nd)      ! dust mass concentration (ug/m3) (multiply by 1e9 for kg/m3)
!
!    real rn_dst(n1)    ! dust number mean radius (m)
!    data rn_dst /0.12e-6,0.21e-6,0.39e-6,0.71e-6/
!
!    real rv_dst(n1)    ! dust volume mean radius (m)
!    data rv_dst /0.14e-6,0.24e-6,0.45e-6,0.80e-6/
!
!    real frac(n1)    ! dust mass fraction
!    data frac  /0.01053,0.08421,0.25263,0.65263/
!    
!    !Sylvia
!    real rhowater,rhodst,dfaer,rlv,viscosity,tfac,slip
!    
!    logical default    ! use the default values from the original code
!    data    default /.false./
!
!
!    pi=3.1415927
!    rhowater=1.0e3     ! density of water (kg/m3)
!    rhodst=2.500*1.0e3 ! density of dust  (kg/m3)
!
!! contact freezing (-40<T<-3 C) (Young, 1974)
!
!          if(t.lt.270.16 .and. t.gt.233.15) then
!
!
!          if(default) then
!            dfaer=1.0e-10     ! or 1.4e-8 m2/s,    aerosol diffusivity -- size dependent
!            na0=2.0e5         ! constant with height
!            nacon=na0*(270.16-t)**1.3   ! contact IN number density (m^-3)
!
!            rlv=(3.*cldwat/(4.*pi*rhowater*nliq))**(1./3.)   ! cloud droplet size (m)
!
!            ni_frzc = dfaer*4.*pi*rlv*nacon*nliq*dt          ! ice number change in dt
!           else
!
!! based on dust bins 1-5 (0.1-1.0, 1-1.8, 1.8-3, 3-6, 6-10 um radius)
!!
!            viscosity=1.8e-5*(t/298.0)**0.85                                 ! Viscosity (kg/m/s)
!            if ( pmid .lt. 1. ) print*,"Ooops",pmid,t
!            mfp=2.0*viscosity/(100.*pmid*sqrt(8.0*28.96e-3/(pi*8.314409*t))) ! Mean free path (m)
!
!            tfac = (270.16-t)**1.3
!
!            rlv=(3.*cldwat/(4.*pi*rhowater*nliq))**(1./3.)
!
!            ni_frzc = 0.
!
!            do n = 1,n1
!              slip=1.0 + (mfp/rn_dst(n))*(1.257 +(0.4*exp(-(1.1*rn_dst(n)/mfp)))) ! Slip correction factor
!
!              dfaer=1.381e-23*t*slip/(6.*pi*viscosity*rn_dst(n))    ! aerosol diffusivity (m2/s)
!
!              na0=(1.e-9*frac(n)*dust(1)/rhodst)/(4.*pi*rv_dst(n)**3/3.0)   ! m^-3
!
!
!              nacon=na0*tfac
!
!
!              ni_frzc=ni_frzc + dfaer*nacon*4.*pi*rlv*nliq*dt    ! contact freezing; sum over bins
!
!
!            end do
!
!          endif
!
!
!           else
!            ni_frzc = 0.
!          endif
!    return
!    end subroutine contact_frz_con
!!**********************************************************************************
!  subroutine ice_deposition(tn,relhum,qn,qs,cldm,qsp,ni,qi,ql,p, &
!                            deltat,vap2ice,vpdpheat,liq2ice,lqfzheat,nl)
!
!      implicit none
!
!      real tn, relhum, qn, qs, qsp, cldm, ni, qi, ql, p, deltat, nl
!      real vap2ice, vpdpheat, liq2ice, lqfzheat
!
!      real rKa, Dva, mincld, tmelt, rh2o, hlatf, hlatv, cp, cwat, fice
!      real tliq, Tk, esn, ein, deles, Aprpr, Bprpr, rho
!      real cm0, fd, alf, rhoic, qidep
!      REAL Cice, qi0, Crate, qidep8
!
!! INPUT:
!! tn: temperaure (K)
!! relhum: RH over water (0-1)
!! qn: specific humidity of water vapor (kg/kg)
!! qs: saturation specific humidity (kg/kg)
!! qsp: saturation specific humidity (kg/kg) at wet bulb temp
!! cldm: mean cloud fraction over the time step
!! ni: in-cloud ice number concentration (#/m3)
!! nl: in-cloud liquid number concentration (#/m3)
!! qi: ice mixing ratio (kg/kg)
!! ql: latent mixing ratio (kg/kg)
!! p: pressure (hPa)
!! deltat: timestep (sec)
!
!! OUTPUT:
!! vap2ice: water vapor deposition onto ice [qn -> qi] (kg/kg/sec)
!! vpdpheat: latent heat for water vapor converted to ice (K/sec)
!! liq2ice: cloud water deposition onto ice [ql -> qi] (kg/kg/sec)
!! lqfzheat: latent heat for cloud water converted to ice (K/sec)
!
!      rKa=2.4e-2   !Thermal conductivity of air (0 deg)
!      Dva=2.21     !Diffusivity of qv in air (0 deg. and 1 Pa)
!      mincld=1.e-3 ! a small cloud fraction to avoid / zero
!
!      tmelt = 273.16
!      tmelt = 263.16  ! T melt modified
!      tmelt = 268.16  ! T melt modified
!      rh2o =  461.5   ! water vapor gas const (J/kg/K) gkw: is this correct?
!
!      hlatf = 0.346e6 ! Latent heat of fusion (J/kg)
!      hlatv = 2.499e6 ! Latent heat of vaporization (J/kg)
!
!      cp = 1004.      ! dry air heat capacity (J/kg/K)
!
!
!      cwat = qi + ql  ! total water (kg/kg)
!
!!  ice fraction in total water (0-1)
!      if(cwat .gt. 0.) then
!        fice = max(qi,0.)/cwat
!       else
!        fice = 0.
!      endif
!
!! liquid deposition calculation in mixed-phase clouds (Bergeron process)
!        tliq = tn - hlatv/cp*cwat - hlatf/cp*qi
!
!        if(cldm > mincld) then
!          Tk = tliq + hlatv/cp*cwat/cldm !T in liq cloud
!! Revised by Yogesh, 6/10/2011
!          Tk = tn - hlatf/cp*qi/cldm     !T in liq cloud
!! Limit 0.1% ice particle
!!         if(Tk.lt.tmelt.and.ql.gt.1.0e-12) then
!          if(Tk.lt.tmelt.and.ql.gt.1.0e-12.and.ni.gt.0.001*nl) then
!            esn = svpl(Tk)*100.       ! Pa
!            ein = svpi(Tk)*100.       ! Pa
!            deles = (esn - ein) * (1.-fice)   ! es(T) is weighted value of the liquid and ice values
!            deles = max(deles,0.)
!
!            Aprpr = hlatv/(rKa*Tk)*(hlatf/(rh2o*Tk)-1.)
!            Bprpr = rh2o*Tk/((Dva/(100.*p))*ein)
!            rho = 100.*p/(287.0*Tk)
!            Cice = ni                 ! in-cld ice number, m^-3
!
!            cm0=1.e-12  !Initial crystal mass
!            qi0=cm0*Cice/rho  !Initial mixing ratio
!
!! Next 2 lines are for assumption of fully mixed ql and qi
!            qi0=max(qi0, qi/cldm)
!            fd=1.
!
!! assume spheres for ice (and spread over grid box)
!            alf=1./3.
!            rhoic=1000.    ! 700.
!
!!           print *, tk,ql,fice,cldm,esn,ein,deles,rho,rhoic,Aprpr,Bprpr,qi0
!
!            Crate=7.8*((Cice/rho)**2/rhoic)**(1./3.)*deles/((Aprpr+Bprpr)*ein)
!            qidep=fd*cldm*sqrt(((2./3.)*Crate*deltat+qi0**(2./3.))**3)
!
!            qidep=qidep-qi
!            qidep=min(qidep,ql)
!
!            liq2ice=qidep/deltat
!
!! bounds
!            liq2ice = max(min(liq2ice,(cwat*(1.-fice))/deltat),0.)
!
!! Account for the latent heat of fusion for liquid drops converted to ice
!            lqfzheat = hlatf * liq2ice / cp
!
!! Ni/Nl ramp
!            if ( ni .le. 0.010*nl ) then
!               liq2ice  = liq2ice  * ni / nl * 100.
!               lqfzheat = lqfzheat * ni / nl * 100.
!            endif
!
!          else
!            liq2ice = 0.0
!            lqfzheat = 0.0
!          endif
!
!        else
!          liq2ice = 0.0
!          lqfzheat = 0.0
!        endif
!
!! vapor deposition calculation in whole grid box (Rotstayn et al., 2000)
!!       if(qi > 0.) then
!        if(qi > 0. .and. ql < 1.e-12) then
!          Tk = tn
!          if(Tk.lt.tmelt) then
!            esn = svpl(Tk)*100.       ! over water, Pa
!            ein = svpi(Tk)*100.       ! over ice, Pa
!
!            if ((relhum*esn/ein) > 1.) then
!
!            Aprpr = hlatv/(rKa*Tk)*(hlatf/(rh2o*Tk)-1.)
!            Bprpr = rh2o*Tk/((Dva/(100.*p))*ein)
!            rho = 100.*p/(287.0*Tk)
!            Cice = ni*cldm            ! grid-averaged ice number, m^-3
!
!            cm0=1.e-12  !Initial crystal mass
!            qi0=cm0*Cice/rho  !Initial mixing ratio
!
!! Next 2 lines are for assumption of fully mixed ql and qi
!!           qi0=max(qi0, qi)                    ! grid-averaged ice mixing ratio
!            qi0=qi
!            fd=1.
!
!! assume spheres for ice
!            alf=1./3.
!            rhoic=1000.    ! ice density, 700. kg/m3
!            Crate=7.8*((Cice/rho)**2/rhoic)**(1./3.)*(relhum*esn/ein-1.)                 &
!                  /(Aprpr+Bprpr)
!            qidep8=fd*sqrt(((2./3.)*Crate*deltat+qi0**(2./3.))**3)
!
!            qidep=min(qidep8-qi,qn-1.0e-12)
!
!! if deposition, it should not reduce grid mean rhi below 1.0
!            if(qidep > 0.0 .and. (relhum*esn/ein) > 1. ) &
!               qidep=min(qidep, (qn-qs*ein/esn))
!
!! if net evaporation, it should not exceed available ice
!            else if(cwat*fice > 0.0) then
!              qidep = - min(max(0.0,qsp-qn),cwat*fice)
!            else
!              qidep = 0.0
!            endif
!
!! when qi>0 and tem >= tmelt, evaporate the ice
!          else
!            qidep = - min(max(0.0,qsp-qn),cwat*fice)
!          endif
!
!          vap2ice=qidep/deltat
!
!! Account for the latent heat for water vapor converted to ice
!          vpdpheat = (hlatv+hlatf) * vap2ice / cp
!
!        else
!          vap2ice = 0.0
!          vpdpheat = 0.0
!        endif
!
!      return
!  end subroutine ice_deposition
!!***************************************************************************
!      subroutine ice_dep_con(tn,cldm,ni,qi,ql,p, &
!                             deltat,nl,liq2ice)
!
!      implicit none
!
!      real tn,relhum, qn, qs, qsp, cldm, ni, qi,ql,p, deltat,nl
!      real vap2ice, vpdpheat, liq2ice, lqfzheat
!
!      real rKa, Dva, mincld, tmelt, rh2o, hlatf, hlatv, cp, cwat, fice
!!     real tliq, Tk, esn,svpl, ein,svpi,deles,Aprpr,Bprpr,rho,Cice
!      real tliq, Tk, esn, ein,deles,Aprpr,Bprpr,rho,Cice
!      real cm0, qi0,fd, alf, rhoic, Crate, qidep,qidep1,qidep2
!!     real tc,tk,qi0,qtotal,xfac,VPmult,contrm,qif
!      real tc,qtotal,xfac,VPmult,contrm,qif
!      real cc,fliqn,ficen,factor,ffi,qic,nlc,nic,qii,nli,qli,qlc,qtc
!
!! INPUT:
!! tn: temperaure (K)
!! cldm: mean cloud fraction over the time step
!! ni: in-cloud ice number concentration (#/m3)
!! nl: in-cloud liquid number concentration (#/m3)
!! qi: ice mixing ratio (kg/kg)
!! ql: liquid mixing ratio (kg/kg)
!! p: pressure (hPa)
!! deltat: timestep (sec)
!
!! OUTPUT:
!! liq2ice: cloud water deposition onto ice [ql -> qi] (kg/kg/sec)
!
!      rKa=2.4e-2   !Thermal conductivity of air (0 deg)
!      Dva=2.21     !Diffusivity of qv in air (0 deg. and 1 Pa)
!      mincld=1.e-4 ! a small cloud fraction to avoid / zero
!
!      tmelt = 268.16
!      rh2o =  461.5   ! water vapor gas const (J/kg/K)
!
!      hlatf = 0.346e6 ! Latent heat of fusion (J/kg)
!      hlatv = 2.499e6 ! Latent heat of vaporization (J/kg)
!
!      cp = 1004.      ! dry air heat capacity (J/kg/K)
!      ffi = 3.0
!
!      qtotal = ql + qi
!
!! liquid deposition calculation in mixed-phase clouds (Bergeron process)
!
!
!      Tk = tn - hlatf/cp*qi   ! Liquid Cloud Temperature, 6/10/2011
!
!! Limit 0.1% ice particle
!!     if(Tk .lt. tmelt .and. nl*ql*ql .gt. 0. .and. ni .gt. 0.001*nl ) then
!      if(Tk .lt. tmelt .and. nl*ql*ql .gt. 0.  ) then
!         esn = svpl(Tk)*100.       ! Pa
!         ein = svpi(Tk)*100.       ! Pa
!
!         Aprpr = hlatv/(rKa*Tk)*(hlatf/(rh2o*Tk)-1.)
!         Bprpr = rh2o*Tk/((Dva/(100.*p))*ein)
!         rho = 100.*p/(287.0*Tk)
!
!         qlc = ql/cldm
!         qic = qi/cldm
!         nlc = nl/cldm
!         nic = ni/cldm
!         qtc = qlc+qic
!
!! Next 2 lines are for assumption of fully mixed ql and qi
!         deles = (esn - ein)/ein
!
!         VPmult = 1.0/(1.0+ffi*((nic*qic*qic)/(nlc*qlc*qlc))**0.333)
!
!! assume spheres for ice (and spread over grid box)
!
!         rhoic=1000.    ! 700., using 1000
!
!         Crate=7.8*((nic/rho)**2/rhoic)**(1./3.)*deles/((Aprpr+Bprpr))
!
!         qif=qic*((1.0+(2./3.)*Crate*VPmult*deltat/qic**(2./3.))**1.5)
!         qif=min(qif,qtc*0.99)
!!! First iteration
!         qii = 0.5*(qic + qif)
!         nli = nlc-nlc*(qii-qic)/qlc
!         qli = qtotal-qii
!
!         VPmult =1.0/(1.0+ffi*((nic*qii*qii)/(nli*qli*qli))**0.333)
!
!         qif=qic*((1.0+(2./3.)*Crate*VPmult*deltat/qic**(2./3.))**1.5)
!         qif=min(qif,qtc*0.99)
!
!!! Second iteration
!
!         qii = 0.5*(qic + qif)
!         nli = nlc-nlc*(qii-qic)/qlc
!         qli = qtotal-qii
!            
!         VPmult =1.0/(1.0+ffi*((nic*qii*qii)/(nli*qli*qli))**0.333)
!            
!         qif=qic*((1.0+(2./3.)*Crate*VPmult*deltat/qic**(2./3.))**1.5)
!         qif=min(qif,qtc*0.99)
!            
!!! Third iteration
!              
!         qii = 0.5*(qic + qif)
!         nli = nlc-nlc*(qii-qic)/qlc
!         qli = qtotal-qii
!              
!         VPmult =1.0/(1.0+ffi*((nic*qii*qii)/(nli*qli*qli))**0.333)
!              
!         qif=qic*((1.0+(2./3.)*Crate*VPmult*deltat/qic**(2./3.))**1.5)
!         qif=min(qif,qtc*0.99)
!
!         qidep=max(qif,qic)
!         qidep=(qidep-qic)*cldm   
!         qidep=min(qidep,ql)
!
!         liq2ice=qidep
!
!! Account for the latent heat of fusion for liquid drops converted to ice
!
!      else 
!         liq2ice = 0.0
!        
!      endif
!
!      return
!      end subroutine ice_dep_con
!
!!***************************************************************************
!      subroutine ice_dep_con2(tn,cldm,ni,qi,ql,p, &
!                             deltat,nl,liq2ice)
!
!      implicit none
!
!      real tn,relhum, qn, qs, qsp, cldm, ni, qi,ql,p, deltat,nl
!      real vap2ice, vpdpheat, liq2ice, lqfzheat
!
!      real rKa, Dva, mincld, tmelt, rh2o, hlatf, hlatv, cp, cwat, fice
!!     real tliq, Tk, esn,svpl, ein,svpi,deles,Aprpr,Bprpr,rho,Cice
!      real tliq, Tk, esn, ein,deles,Aprpr,Bprpr,rho,Cice
!      real cm0, qi0,fd, alf, rhoic, Crate, qidep,qidep1,qidep2
!!     real tc,tk,qi0,qtotal,xfac,VPmult,contrm,qif
!      real tc,qtotal,xfac,VPmult,contrm,qif
!      real cc,fliqn,ficen,factor,ffi,qic,nlc,nic,qii,nli,qli,qlc,qtc
!
!! INPUT:
!! tn: temperaure (K)
!! cldm: mean cloud fraction over the time step
!! ni: in-cloud ice number concentration (#/m3)
!! nl: in-cloud liquid number concentration (#/m3)
!! qi: ice mixing ratio (kg/kg)
!! ql: liquid mixing ratio (kg/kg)
!! p: pressure (hPa)
!! deltat: timestep (sec)
!
!! OUTPUT:
!! liq2ice: cloud water deposition onto ice [ql -> qi] (kg/kg/sec)
!
!      rKa=2.4e-2   !Thermal conductivity of air (0 deg)
!      Dva=2.21     !Diffusivity of qv in air (0 deg. and 1 Pa)
!      mincld=1.e-4 ! a small cloud fraction to avoid / zero
!
!      tmelt = 273.16
!      tmelt = 263.16  ! T melt modified
!      tmelt = 265.16  ! T melt modified
!      rh2o =  461.5   ! water vapor gas const (J/kg/K)
!
!      hlatf = 0.346e6 ! Latent heat of fusion (J/kg)
!      hlatv = 2.499e6 ! Latent heat of vaporization (J/kg)
!
!      cp = 1004.      ! dry air heat capacity (J/kg/K)
!      ffi = 3.0
!
!      qtotal = ql + qi
!
!! liquid deposition calculation in mixed-phase clouds (Bergeron process)
!
!
!!     Tk = tn - hlatf/cp*qi   ! Liquid Cloud Temperature, 6/10/2011
!      Tk = tn                 ! Yogesh, 07-18-2011
!
!! Limit 0.1% Nice to Nliquid
!      if(Tk .lt. tmelt .and. ql .gt. 1.e-12 .and. nl .gt. 1.e-3 .and. &
!         qi .gt. 1.e-20 .and. ni .gt. 0.005*nl ) then
!         esn = svpl(Tk)*100.       ! Pa
!         ein = svpi(Tk)*100.       ! Pa
!
!         Aprpr = hlatv/(rKa*Tk)*(hlatf/(rh2o*Tk)-1.)
!         Bprpr = rh2o*Tk/((Dva/(100.*p))*ein)
!         rho = 100.*p/(287.0*Tk)
!
!         qlc = ql
!         qic = qi
!         nlc = nl
!         nic = ni
!         qtc = qlc+qic
!
!! Next 2 lines are for assumption of fully mixed ql and qi
!         deles = (esn - ein)/ein
!
!         if (qic/qlc .lt. 1.e-20 ) then
!            VPmult = 1.
!         elseif ( qic/qlc .gt. 1.e20 ) then 
!            VPmult = 0.
!         else
!            VPmult = 1.0/(1.0+ffi*(nic/nlc)**.333*(qic/qlc)**.333*(qic/qlc)**.333)
!         endif
!
!! assume spheres for ice (and spread over grid box)
!
!         rhoic=1000.    ! 700., using 1000
!
!         Crate=7.8*((nic/rho)**2/rhoic)**(1./3.)*deles/((Aprpr+Bprpr))
!
!         qif=qic*((1.0+(2./3.)*Crate*VPmult*deltat/qic**(2./3.))**1.5)
!         qif=min(qif,qtc*0.9999)
!!! First iteration
!         qii = 0.5*(qic + qif)
!         nli = nlc-nlc*(qii-qic)/qlc
!         qli = qtotal-qii
!
!         qif=qic*((1.0+(2./3.)*Crate*VPmult*deltat/qic**(2./3.))**1.5)
!         qif=min(qif,qtc*0.9999)
!
!!! Second iteration
!
!         qii = 0.5*(qii + qif)
!         nli = nlc-nlc*(qii-qic)/qlc
!         qli = qtotal-qii
!            
!         qif=qic*((1.0+(2./3.)*Crate*VPmult*deltat/qic**(2./3.))**1.5)
!         qif=min(qif,qtc*0.9999)
!            
!!! Third iteration
!              
!         qii = 0.5*(qii + qif)
!         nli = nlc-nlc*(qii-qic)/qlc
!         qli = qtotal-qii
!              
!         qif=qic*((1.0+(2./3.)*Crate*VPmult*deltat/qic**(2./3.))**1.5)
!         qif=min(qif,qtc*0.9999)
!
!!! Fourth iteration
!
!         qii = 0.5*(qii + qif)
!         nli = nlc-nlc*(qii-qic)/qlc
!         qli = qtotal-qii
!
!         qif=qic*((1.0+(2./3.)*Crate*VPmult*deltat/qic**(2./3.))**1.5)
!         qif=min(qif,qtc*0.9999)
!
!!! Fifth iteration
!
!         qii = 0.5*(qii + qif)
!         nli = nlc-nlc*(qii-qic)/qlc
!         qli = qtotal-qii
!         
!         if ( (nic*qic)/(nlc*qlc) .gt. 1.e-7 ) then
!            VPmult = 1.0/(1.0+ffi*((nic*qic*qic)/(nlc*qlc*qlc))**0.333)
!         else
!            VPmult = 1.0
!         endif
!
!         qif=qic*((1.0+(2./3.)*Crate*VPmult*deltat/qic**(2./3.))**1.5)
!         qif=min(qif,qtc*0.9999)
!
!         qidep=max(qif,qic)
!         qidep=(qidep-qic)*cldm   
!         qidep=min(qidep,ql)
!
!         liq2ice=qidep
!! Ni/Nl ramp
!         if ( ni .le. 0.010*nl ) then
!            liq2ice = liq2ice * ni / nl * 100.
!         endif
!
!! Account for the latent heat of fusion for liquid drops converted to ice
!
!      else 
!         liq2ice = 0.0
!        
!      endif
!
!      return
!      end subroutine ice_dep_con2
!
!!=======================================================================
!
!Subroutine BN_ice_nucleati(t, ql, pmid, zm, w, nuci, pcols, pver, sumr, bcmr, &
!                    so4_num, soot_num, nhet, IN_spectrum, SigmaW, dumr, dust_num )
!
!!-----------------------------------------------------------------------
!! Purpose:
!!  Parameterization of ice nucleation.
!!
!! Method: Uses the Ice nucleation parameterization of D. Barahona and A. Nenes,
!!  described in Barahona and Nenes 2008, 2009 and 2011. It relates the ice crystal 
!!  number with aerosol number, temperature and the
!!  updraft velocity. It includes homogeneous freezing of sulfate, and heterogeneous 
!!  freezing on other insoluble aerosol.
!!
!!  The code of the parameterization can be found in the Module BLABLABLA
!!
!!  The parameterization has an option (IN_spectrum) to choose the IN spectrum to be used for
!!  heterogenous ice nucleation:
!! 
!       !-1 - Monodisperse
!       ! 1-  Meyers, 1992
!       ! 2-  BKG, Phillips 2007 
!       ! 3-  Barahona  and Nenes (2009) formulation based on modified CNT.
!       ! 4-  PDA08, using fixed size distributions.
!       
!!  If the standard deviation of the cloud-scale updraft velocity (sigwparc) is set 
!!  greater than 0.02 m/s the code automatically performs an integration over the positive
!!  part of a gaussian PDF with mean w (= miuv) and standar deviation (= sigmawparc).
!!        
!!  For sigwparc < 0.02 m/s, the code assumes a single updraft equal to w
!!
!!  PS: ice number calculated is for in-cloud values. For grid average, cloud fraction
!!     needs to be multiplied.
!!
!!  Authors: Donifan Barahona
!!
!!----------------------------------------------------------------
!!----------------------------------------------------------------
!! Input Arguments
!!
!  Implicit none
!  
!  integer, intent(in) :: pcols, pver                     ! grid points & vertical layers
!  integer, intent(in) :: IN_spectrum		         ! tye of IN spectrum to be used
!
!  real, intent(in) :: t(pcols, pver)                 ! temperature (K)
!  real, intent(in) :: ql(pcols, pver)                ! liquid water mixing ratio (kg/kg)
!  real, intent(in) :: pmid(pcols, pver)              ! model midpoint pressure (hPa)
!  real, intent(in) :: zm(pcols, pver)                ! height abv sfc at midpoints(m)
!  real, intent(in) :: w(pcols, pver)                 ! cloudscale upward vertical velocity (m/s)
!  real, intent(in) :: sumr(pcols, pver)              ! sulfate aerosol mass mixing ratio (kg/kg)
!  real, intent(in) :: bcmr(pcols, pver)              ! black carbon aerosol mass mixing ratio (kg/kg)
!  real, intent(in) :: dumr(pcols, pver,5)            ! dust aerosol mass mixing ratio (kg/kg)
!  real, intent(in) :: SigmaW			     ! STDV of updraft velocity distribution (m/s)
!  
!!
!! Output Arguments
!!
!  real, intent(out) :: nuci(pcols,pver)              ! ice number nucleated in clouds (#/cm^3)
!  real, intent(out) :: nhet(pcols,pver)              ! ice crystal number by heterogeneous nucleation (#/cm^3)
!  real, intent(out) :: so4_num(pcols, pver)          ! so4 aerosol number (#/cm^3)
!  real, intent(out) :: soot_num(pcols, pver)         ! soot (hydrophilic) aerosol number (#/cm^3)
!  real, intent(out) :: dust_num(pcols, pver,5)       ! dust aerosol number (#/cm^3)
!
!!
!! Local workspace 
!!
!  integer i, k, id
!
!  real  rhoa                                         ! air density (kg/m3)
!  real  re_so4                                       ! volume mean radius for so4 aerosol(m)
!  real  re_soot                                      ! volume mean radius for soot aerosol(m)
!  real, dimension(5) :: re_dust                        ! volume mean radius for dust aerosol(m)
!  real  rhosul                                       ! density of sulfate aerosol (kg/m^3)
!  real  rhoboc                                       ! density of bc and oc       (kg/m^3)
!  real  rhodus                                       ! density of dust            (kg/m^3)
!  real  pi
!  real  hfactor			   		     ! Height attenuation factor
!  
!!-------------------------------------------------------------------------
!
!  real*8, dimension(5)  :: ndust, ddust              ! bins for dust
!  real*8                :: nhet2, nice, smaxice, nlim, &
!                     frac, norg, nbc, nhom, dorg, dbc, tparc, & 
!      		     pparc, sigwparc, fact, miuv
!
!  logical  :: Mixed_Phase                            ! true = mixed phase cloud
!
!  pi = 3.1415927
!
!!------------------------------------------------------------------------
!! 
!! volume mean radius for so4 and soot aerosols, calculated from assumed size distributions typical
!! of the upper troposphere: SO4 from Jensen et al., 1994; Soot from Pueschel et al., 1992
!!
!  re_so4  = 0.0566*1.0e-6    	! Jensen et al., 1994: rg=0.02um, sig=2.3
!  re_soot = 0.0896*1.0e-6	! Pueschel et al., 1992: rg=0.07um, sig=1.5
!  re_dust(1) = 0.73*1.0e-6	! GOCART 1st bin
!  re_dust(2) = 1.40*1.0e-6	! GOCART 2st bin
!  re_dust(3) = 2.40*1.0e-6	! GOCART 3st bin
!  re_dust(4) = 4.50*1.0e-6	! GOCART 4st bin
!  re_dust(5) = 8.00*1.0e-6	! GOCART 5st bin
!  rhosul = 1.841*1.0e3    	! Density of H2SO4 (kg/m3)
!  rhoboc = 1.000*1.0e3    	! Density of BC (kg/m3)
!  rhodus = 2.500*1.0e3    	! Density of Dust (kg/m3)
!
!  Do i=1, pcols
!   Do k=1, pver
!
!! calculate so4 and soot number (#/cm^3) from aerosol mixing ratio (kg/kg)
!
!    rhoa          = 100.*pmid(i,k)/(287*t(i,k))         ! air density (kg/m3)
!    so4_num(i,k)  = rhoa*(sumr(i,k)/rhosul)/(4*pi*re_so4**3/3.0)*1.0e-6
!    soot_num(i,k) = rhoa*(bcmr(i,k)/rhoboc)/(4*pi*re_soot**3/3.0)*1.0e-6
!    do id = 1, 5
!       dust_num(i,k,id) = rhoa*(dumr(i,k,id)/rhodus)/(4*pi*re_dust(id)**3/3.0)*1.0e-6
!    enddo
!
!    tparc    =  t(i,k)
!    pparc    =  100.*pmid(i,k)		! to Pa
!    miuv     =  w(i,k)
!    sigwparc =  SigmaW                  ! when sigma < 0.02 ---> No PDF integration
!    
!! Aerosol size characteristics. This is only used for the IN_spec = 4 
!! for heterogenous freezing of insoluble species: BC, insoluble organics, and dust.
!
!    ddust(:) =  2.0*re_dust(:)
!!   dbc      =  0.5e-6                  ! default value used by Donifan
!    dbc      =  2.0*re_soot
!    dorg     =  1e-6
!    norg     =  0.0
!    
!! initialize output
!
!      smaxice=0d0
!      nhet2=0d0
!      nice=0d0
!      nlim=0d0
!
!! calculate ice nucleation only when there are aerosols (aerosol number > 1.e-4 cm-3)
!
!    if(so4_num(i,k).ge.1.0e-10 .or. soot_num(i,k).ge.1.0e-10 &
!        .or. dust_num(i,k,1).ge.1.0e-10 ) then
!    
!      nhom    =  max(so4_num(i,k)*1.0e6,1.e-4)	! to (#/m3) since IceParam requires SI units
!      nbc     =  max(soot_num(i,k)*1.0e6,1.e-4)	! to (#/m3)
!      ndust(:)=  max(dust_num(i,k,:)*1.0e6,1.e-4)    ! to (#/m3)
!       
!! -------------------------------------------------------
!
!      if (tparc .lt. 273.0) then 	! only if ice is present
!       
!        if (tparc .gt. 236.0) then 	! only het freezing         
!          
!	  if (ql(i,k).le. 1.e-8) then  	! no liquid, therefore no mixed phase
!	  
!	     Mixed_Phase = .FALSE.
!	     sigwparc = max(0.01, sigwparc) 
!	     sigwparc = min(1.0, sigwparc)
!	     
!	     if (miuv .gt. 0.) then
!             CALL IceParam (sigwparc, miuv, tparc, pparc,  &
!                   nhom, ndust, ddust, nbc, dbc, norg, dorg,  &
!                   nhet2, nice, smaxice, nlim, IN_spectrum, Mixed_Phase)
!	     endif
!            
!	  else 				! It is a mixed phase cloud
!       
!             Mixed_Phase = .TRUE.
!	     CALL IceParam (sigwparc, miuv, tparc, pparc,  &
!                   nhom, ndust, ddust, nbc, dbc, norg, dorg,  &
!                   nhet2, nice, smaxice, nlim, IN_spectrum, Mixed_Phase)
!		   
!! Altitude correction for IN concentration from Meyers (=1.0 at present)
!
!             if(zm(i,k) .le. 1000.) then
!               hfactor = 1.00        
!             else if(zm(i,k) .le. 7000.) then
!               hfactor = 10.**(-(zm(i,k)-1000.)/6700.)
!             else
!               hfactor = 10.**(-6000./6700.)
!             endif
!             hfactor = 1.0
!	     nhet2 = hfactor*nhet2 	   
!	  	  	   	   	   
!          end if 
!	   	   	   
!        else                            ! homog. and hetero. freezing in cirrus regime
!	   
!          Mixed_Phase = .FALSE.
!	  sigwparc = max(0.01, sigwparc) 
!          sigwparc = min(1.0, sigwparc) 
!     
!          if (miuv .gt. 0.) then
!	  CALL IceParam (sigwparc, miuv, tparc, pparc,  &
!                nhom, ndust, ddust, nbc, dbc, norg, dorg,  &
!                nhet2, nice, smaxice, nlim, IN_spectrum, Mixed_Phase)
!	  endif	
!	 
!        end if		  		  		      
!	 
!      end if
!      
!    endif    
!
!    nuci(i,k) = nice*1.0e-6		! convert back to (#/cm3)
!    nhet(i,k) = nhet2*1.0e-6		! convert back to (#/cm3) 
!    
!    if(nuci(i,k).gt.9999.or.nuci(i,k).lt.0) then
!     write(6, *) 'incorrect nucleation parameterization'
!     write(6, *) i,k,nuci(i,k)
!    endif
!
!
!   enddo  ! k
!  enddo   ! i
!
!  return
!  end Subroutine BN_ice_nucleati
!Sylvia
!Sylvia
  PRIVATE 
! liquid phase aerosol activation
  PUBLIC activate_nenes
!  PUBLIC nucleati         ! ice phase aerosol activation  (Liu & Penner)
!  PUBLIC BN_ice_nucleati  ! ice phase aerosol acitivation (Barahona &  Nenes)
!  PUBLIC nucleaticon      ! ice phase aerosol activation
!  PUBLIC ice_deposition   ! mixed-phase physics
!  PUBLIC ice_dep_con      ! mixed-phase physics
!  PUBLIC ice_dep_con2     ! mixed-phase physics
!  PUBLIC contact_freezing ! mixed-phase physics
!  PUBLIC contact_frz_con  ! mixed-phase physics
!Sylvia: adding variables to common block
! number of modes
  INTEGER :: nm_drop
  REAL :: ama, grav, rgas, dw, amw, denw, dhv, cpair, d11, d12, d13
  REAL :: d14, d15, d21, d22, d23, d24, d25, d31, d32, d33, d34, d35
  REAL :: d41, d42, d43, d44, d45, eps, akoh_drop
  REAL :: aka, psat, dair, surt, pres_drop, temp_drop
  REAL :: pi, zero, great, sq2pi
  LOGICAL :: ccnspst
  INTEGER :: maxit
  DATA ccnspst /.false./
  DATA sq2pi /2.5066282746/
  DATA great /1e30/
  DATA zero /0e0/
!
! Some constants
  DATA pi /3.1415927/
! Convergence criterion
  DATA eps /1e-6/
!
! Max iterations for solution
  DATA maxit /100/
  DATA d45 /-0.2799/
  DATA d44 /2.3514/
  DATA d43 /-6.8527/
  DATA d42 /8.8725/
! for C4
  DATA d41 /-5.1774/
  DATA d35 /0.4647/
  DATA d34 /-3.9115/
  DATA d33 /11.4552/
  DATA d32 /-14.9297/
! for C3
  DATA d31 /8.4825/
  DATA d25 /-0.2131/
  DATA d24 /1.8025/
  DATA d23 /-5.3436/
  DATA d22 /7.0906/
! for C2
  DATA d21 /-3.9310/
  DATA d15 /0.0711/
  DATA d14 /-0.5644/
  DATA d13 /1.4963/
  DATA d12 /-1.6929/
  DATA d11 /-0.1907/
! Air Cp
  DATA cpair /1.0061e3/
! Water enthalpy of vaporization
  DATA dhv /2.25e6/
! Water density
  DATA denw /1e3/
! Water molecular weight
  DATA amw /18e-3/
! Water Molecule Diameter
  DATA dw /2.75e-10/
! Universal gas constant
  DATA rgas /8.31e0/
! g constant
  DATA grav /9.81e0/
! Air molecular weight
  DATA ama /29e-3/

CONTAINS
! *** PROGRAM PARAMExample
! *** THIS SUBROUTINE PROVIDES AN EXAMPLE FOR USING THE PARAMETERIZATION
!
!     The calling sequence is as follows:
!     1. CALL GAULEG   (once, only if integration over a PDF of updrafts)
!     2. CALL CCNSPEC  (to convert aerosol/chemistry info to CCN)
!     3. CALL PDFACTIV (to calculate Ndroplet and Smax for known W)
!
!     Notes:
!     GAULEG calculates the GAUSS integration points and weighting factors
!     This routine needs to be called only if PDF up updraft velocity is
!     employed; if so, GAULEG needs to be called only once, in the INIT
!     routine of the GCM, as the XGS, WGS values are saved in the COMMON
!     block in 'parametr.inc'. Npgauss is a PARAMETER defined in the
!     INCLUDE file 'parametr.inc' and is the # of integration points used
!     to integrate over the PDF of updrafts. When used, the PDF is assumed
!     to be Gaussian.
!
!  Developed by
!  Athanasios Nenes
!  School of Earth and Atmospheric Sciences
!  School of Chemical and Biomolecular Engineering
!  Georgia Institute of Technology
!  Atlanta, Georgia, 30332-0340
!  e-mail: thanos.nenes@che.gatech.edu
!  URL: http:\\nenes.eas.gatech.edu
!
!
!=======================================================================
!
  SUBROUTINE ACTIVATE_NENES(tparc, pparc, wparc, ityp, smax, aact, atot&
&   , sulfi, indx, snns, nmodes)
    IMPLICIT NONE
    INTEGER :: nmdm, npgauss, nmodes, nmd, n, ityp
    PARAMETER (npgauss=10)
    PARAMETER (nmdm=10)
! Max # of lognormal modes
    REAL :: tpi(nmdm), dpgi(nmdm), sigi(nmdm), vhfi(nmdm), amsi(nmdm), &
&   densi(nmdm), denii(nmdm), amfsi(nmdm), tpart, npt, nacti, sg(nmdm)
    REAL :: nact, accom
    INTEGER :: modei(nmdm)
    REAL :: sulfi(nmodes), snns(4*nmodes), akk(nmdm)
    REAL :: a_drop, b_drop
    REAL :: xgs(npgauss), wgs(npgauss)
    SAVE xgs, wgs
    LOGICAL :: first
! dmlee
    REAL :: rh
    REAL :: aact, atot
!Sylvia
    REAL :: dbig, dlow, coef, temp, sigw, pres
    REAL, INTENT(IN) :: tparc, pparc, wparc
    REAL, INTENT(OUT) :: smax
    INTEGER :: indx
    INTRINSIC LOG
    INTRINSIC SNGL
    REAL :: pwr1
    REAL :: arg1
    DATA first /.true./
    IF (nmodes .GT. nmdm) THEN
      STOP
    ELSE
!!!   print*,"NENES",tparc,pparc,wparc,indx
!
! ** INITIALIZE: CALCULATE GAUSS QUADRATURE POINTS *******************
!
      IF (first) THEN
        CALL GAULEG(xgs, wgs, npgauss)
        first = .false.
      END IF
!Sylvia: give some variables to the common block
      nm_drop = nmodes
      pres_drop = pparc
      temp_drop = tparc
!
! ** SPECIFY INPUT FOR CALCULATING CCN SPECTRUM **********************
!
!     TPARC  = 298.0   ! Temperature (K)
!     PPARC  = 9.E4    ! Pressure (Pa)
!     WPARC  = 0.05    ! Updraft velocity (m s-1)
! Accommodation coefficient (common for all CCN)
      accom = 0.042
!
!     ITYP   = 1       ! 1=Marine (NA), 2=Continental, 3=Remote Marine
!     SULFI  =-1       ! <0, take default conc's; >0, use as scaling factor
!
      CALL AERTYP(tpi, dpgi, sigi, vhfi, amsi, densi, denii, amfsi, &
&           nmodes, nmd, sulfi, ityp, indx, snns, modei)
! Get aerosol
!Sylvia: coefficients in Kumar's FHH parameterization
      a_drop = 2.25
      b_drop = 1.20
      CALL CCNSPEC(tpi, dpgi, amfsi, vhfi, amsi, densi, denii, nmodes, &
&            sg, akk, modei, a_drop, b_drop)
! Calculate CCN data
!                                                      
! 0=calculate for single updraft (no PDF)
      sigw = 0.0
      CALL PDFACTIV(wparc, sigw, nact, smax, sigi, tpi, dpgi, xgs, wgs, &
&             npgauss, sg, nmodes, akk, modei, accom, a_drop, b_drop)
! Calculate Ndrop
      aact = nact
      atot = 0.
      PRINT*, 'nact', nact
      DO n=1,nmodes
        atot = atot + tpi(n)
      END DO
      RETURN
    END IF
!     WRITE (*,100) 2,WPARC,100*SMAX,NACT*1e-6, &
!                   100.0*NACT/(TPI(1)+TPI(2)+TPI(3))
!
 100 FORMAT(1x, 'Example #',i2 / 1x, 'Updraft (m/s) =',f8.4 / 1x, &
&          'Smax (%) = ',f8.4 / 1x, 'Ndrop (# cm-3) = ', f8.3 / 1x, &
&          'Activation fraction (%) = ', f7.3/)
  END SUBROUTINE ACTIVATE_NENES
!=======================================================================
!
! *** SUBROUTINE CCNSPEC
! *** THIS SUBROUTINE CALCULATES THE CCN SPECTRUM OF THE AEROSOL USING
!     THE APPROPRIATE FORM OF KOHLER THEORY     
!
!  Developed by
!  Athanasios Nenes
!  School of Earth and Atmospheric Sciences
!  School of Chemical and Biomolecular Engineering
!  Georgia Institute of Technology
!  Atlanta, Georgia, 30332-0340
!  e-mail: thanos.nenes@che.gatech.edu
!  URL: http://nenes.eas.gatech.edu
!
!=======================================================================
!
  SUBROUTINE CCNSPEC(tp, dpg, amfs, vhf, ams, dens, deni, nmodes, sg, &
&   akk, modes, a_drop, b_drop)
    IMPLICIT NONE
    INTEGER :: k, nmodes, modes(nmodes)
!Sylvia: add hygroscopitiy (AKK) to outputs
!
    REAL, INTENT(IN) :: dpg(nmodes), vhf(nmodes), ams(nmodes), dens(&
&   nmodes), amfs(nmodes), deni(nmodes), tp(nmodes), a_drop, b_drop
    REAL :: amfi, denp, vlfs, akk(nmodes), sg(nmodes)
!Sylvia
    REAL :: par1, par2
    REAL :: dpcm
    INTRINSIC MAX
    INTRINSIC SQRT
    INTRINSIC EXP
    REAL :: arg1
    REAL :: pwx1
    REAL :: pwy1
    REAL :: pwr1
! Surface Tension for water (J m-2)
    surt = SFT(temp_drop)
! *** Calculate critical properties
! Curvature param
    akoh_drop = 4.*amw*surt/rgas/temp_drop/denw
    DO k=1,nmodes
      IF (modes(k) .EQ. 1) THEN
        IF (1.0 - amfs(k) .LT. 0.0) THEN
          amfi = 0.0
        ELSE
          amfi = 1.0 - amfs(k)
        END IF
! Particle Density
        denp = amfs(k)*dens(k) + amfi*deni(k)
! Vol.Fr.Salt
        vlfs = amfs(k)/dens(k)/(amfs(k)/dens(k)+amfi/deni(k))
        akk(k) = vhf(k)*deni(k)*vlfs*amw/(denw*ams(k))
        par1 = 4./27./akk(k)/dpg(k)**3
!Sylvia: hygroscopicity calculation, VLFS adjusts for salt vol. frac.
        arg1 = par1*akoh_drop**3
        par2 = SQRT(arg1)
! Sc of Dpg
        sg(k) = EXP(par2) - 1.
      ELSE IF (modes(k) .EQ. 2) THEN
!for FHH modes   
        CALL DPCFHH(dpg(k), dpcm, a_drop, b_drop)
        pwx1 = (dpcm-dpg(k))/(2.*dw)
        pwy1 = -b_drop
        pwr1 = pwx1**pwy1
        sg(k) = akoh_drop/dpcm + (-(a_drop*pwr1))
      END IF
    END DO
!
! *** END OF SUBROUTINE CCNSPEC ****************************************
!
    RETURN
  END SUBROUTINE CCNSPEC
!C *** END OF SUBROUTINE DpcFHH ***************************************
!=======================================================================
!
! *** SUBROUTINE PDFACTIV
! *** THIS SUBROUTINE CALCULATES THE CCN ACTIVATION FRACTION ACCORDING 
!     TO THE Nenes and Seinfeld (2003) PARAMETERIZATION, WITH
!     MODIFICATION FOR NON-CONTUNUUM EFFECTS AS PROPOSED BY Fountoukis
!     and Nenes (in preparation). THIS ROUTINE CALCULATES FOR A PDF OF
!     UPDRAFT VELOCITIES.
!
!  Developed by
!  Athanasios Nenes
!  School of Earth and Atmospheric Sciences
!  School of Chemical and Biomolecular Engineering
!  Georgia Institute of Technology
!  Atlanta, Georgia, 30332-0340
!  e-mail: thanos.nenes@che.gatech.edu
!  URL: http://nenes.eas.gatech.edu
!
!=======================================================================
!
  SUBROUTINE PDFACTIV(wparc, sigw, nact, smax, sig, tp, dpg, xgs, wgs, &
&   npgauss, sg, nmodes, akk, modes, accom, aa, bb)
    IMPLICIT NONE
!
! *** END OF SUBROUTINE PDFACTIV ****************************************
!
    REAL :: sq2pi, aa, bb
    PARAMETER (sq2pi=2.5066282746)
    INTEGER :: isec, i, nmodes, npgauss, modes(nmodes)
    REAL :: sig(nmodes), tp(nmodes), sg(nmodes), dpg(nmodes)
!Sylvia: add hygroscopicity
    REAL :: akk(nmodes)
    REAL :: xgs(npgauss), wgs(npgauss)
    REAL :: tpart
    REAL :: nact, nacti, hold
    REAL :: pdf
! Sylvia
    REAL, INTENT(IN) :: wparc, sigw, accom
    REAL, INTENT(OUT) :: smax
    REAL :: dpnmx, plimt, probi, whi, wlo, scal, wpi
    REAL :: smaxi
    REAL :: wpdbg(npgauss), pddbg(npgauss), nadbg(npgauss), smdbg(&
&   npgauss)
    INTRINSIC SNGL
    INTRINSIC LOG
    INTRINSIC SQRT
    INTRINSIC EXP
    INTRINSIC DBLE
    REAL :: arg1
    REAL :: arg2
    REAL :: arg10
!
! *** Case where updraft is very small
!
    IF (wparc .LE. 1e-6) THEN
      smax = 0.
      nact = 0.
      isec = 1
      dpnmx = 1.e30
      RETURN
    ELSE
!
! *** Single updraft case
!
      IF (sigw .LT. 1e-10) THEN
        CALL ACTIVATE(wparc, nact, smax, sig, tp, sg, akk, modes, dpg, &
&               accom, aa, bb)
! Save debug info
        wpdbg(1) = wparc
        pddbg(1) = 1.0
        nadbg(1) = nact
        smdbg(1) = smax
!
! *** PDF of updrafts
!
      ELSE
        nact = 0.
        smax = 0.
! Probability of High Updraft limit
        plimt = 1e-3
        arg1 = plimt*sigw*sq2pi
        arg2 = -(2.0*LOG(arg1))
        probi = SQRT(arg2)
! Upper updrft limit
        whi = wparc + sigw*probi
! WPARC - SIGW*PROBI     ! Low updrft limit
        wlo = 0.05
! Scaling for updrafts
        scal = 0.5*(whi-wlo)
        DO i=1,npgauss
! Updraft
          wpi = wlo + scal*(1.0-xgs(i))
          CALL ACTIVATE(wpi, nacti, smaxi, sig, tp, sg, akk, modes, dpg&
&                 , accom, aa, bb)
! # of drops
! Prob. of updrafts
          arg10 = -(0.5*((wpi-wparc)/sigw)**2)
          pdf = 1.0/sq2pi/sigw*EXP(arg10)
          hold = wgs(i)*(pdf*nacti)
! Integral for drops
          nact = nact + hold
! Integral for Smax
          smax = smax + wgs(i)*(pdf*smaxi)
! Save debug info
          wpdbg(i) = wpi
          pddbg(i) = pdf
          nadbg(i) = nacti
          smdbg(i) = smaxi
          IF (pdf .LT. plimt) GOTO 100
        END DO
! Scale Integrals
 100    nact = nact*scal
        smax = smax*scal
      END IF
!
      RETURN
    END IF
  END SUBROUTINE PDFACTIV
!=======================================================================
!
! *** SUBROUTINE ACTIVATE
! *** THIS SUBROUTINE CALCULATES THE CCN ACTIVATION FRACTION ACCORDING 
!     TO THE Nenes and Seinfeld (2003) PARAMETERIZATION, WITH
!     MODIFICATION FOR NON-CONTUNUUM EFFECTS AS PROPOSED BY Fountoukis
!     and Nenes (in preparation).
!
!  Developed by
!  Athanasios Nenes
!  School of Earth and Atmospheric Sciences
!  School of Chemical and Biomolecular Engineering
!  Georgia Institute of Technology
!  Atlanta, Georgia, 30332-0340
!  e-mail: thanos.nenes@che.gatech.edu
!  URL: http://nenes.eas.gatech.edu
!
!=======================================================================
!
  SUBROUTINE ACTIVATE(wparc, ndrpl, smax, sig, tp, sg, akk, modei, dpg, &
&   accom, aa, bb)
    IMPLICIT NONE
!
! *** END OF SUBROUTINE ACTIVATE ****************************************
!
    REAL :: eps, wparc
    REAL :: wparcb, accomb, aab, bbb, tpb(nm_drop), sgb(nm_drop), akkb(&
&   nm_drop)
    REAL :: ndrplnrb
    REAL :: dbig, dlow, coef, accom, dv, pwr1, arg1
    INTEGER :: maxit, i
    PARAMETER (maxit=100)
    PARAMETER (eps=1.e-6)
! Convergence criterion
    REAL :: sig(nm_drop), tp(nm_drop), sg(nm_drop), akk(nm_drop), dpg(&
&   nm_drop)
    INTEGER :: modei(nm_drop)
!Sylvia: add hygroscopicity
    REAL :: ndrpl
    REAL :: smax, alfa, bet1, bet2, beta, cf1, cf2
    REAL :: aa, bb, c1, c2, c3, c4
    REAL :: ndrplnr, ndrplnr_b, smaxnr
    REAL :: sinteg1, sinteg2, sinteg3
    REAL :: y1, y2, y3
    REAL*8 :: x1, x2, x3
    INTRINSIC SNGL
    INTRINSIC SIGN
    INTRINSIC ABS
    REAL :: result1
    REAL :: abs0
    INTRINSIC LOG
! Dv average
    dbig = 5.0e-6
    pwr1 = accom**(-0.33048)
    dlow = 0.207683*pwr1
    dlow = dlow*1.e-6
    coef = (2.*pi*amw/(rgas*temp_drop))**0.5
!
    dv = 0.211/(pres_drop/1.013e5)*(temp_drop/273.)**1.94
! Water vapor diffusivity in air
    dv = 1.e-4*dv
! Non-continuum effects
    arg1 = (dbig+2.*dv/accom*coef)/(dlow+2.*dv/accom*coef)
    dv = dv/(dbig-dlow)*(dbig-dlow-2.*dv/accom*coef*LOG(arg1))
! Air thermal conductivity
    aka = (4.39+0.071*temp_drop)*1.e-3
! Saturation vapor pressure
    result1 = VPRES(temp_drop)
    psat = result1*(1.e5/1.0e3)
! Air density
    dair = pres_drop*ama/rgas/temp_drop
! *** Setup constants
!
    alfa = grav*amw*dhv/cpair/rgas/temp_drop/temp_drop - grav*ama/rgas/&
&     temp_drop
    bet1 = pres_drop*ama/psat/amw + amw*dhv*dhv/cpair/rgas/temp_drop/&
&     temp_drop
    bet2 = rgas*temp_drop*denw/psat/dv/amw/4. + dhv*denw/4./aka/&
&     temp_drop*(dhv*amw/rgas/temp_drop-1.)
    beta = 0.5*pi*bet1*denw/bet2/alfa/wparc/dair
    cf1 = 0.5*(1./bet2/(alfa*wparc))**0.5
    cf2 = akoh_drop/6.
!
! *** INITIAL VALUES FOR BISECTION **************************************
!
! Min cloud supersaturation -> 0
    x1 = 1.0d-5
    CALL SINTEGRAL(x1, ndrpl, sinteg1, sinteg2, bet2, alfa, sig, tp, sg&
&            , wparc, sinteg3, modei, aa, bb)
    y1 = (sinteg1*cf1+sinteg2*cf2+sinteg3*cf1)*beta*SNGL(x1) - 1.
!
! MAX cloud supersaturation = 100% Sylvia
    x2 = 1.d0
    CALL SINTEGRAL(x2, ndrpl, sinteg1, sinteg2, bet2, alfa, sig, tp, sg&
&            , wparc, sinteg3, modei, aa, bb)
    y2 = (sinteg1*cf1+sinteg2*cf2+sinteg3*cf1)*beta*SNGL(x2) - 1.
!
! *** PERFORM BISECTION *************************************************
!
    DO i=1,maxit
      x3 = 0.5d0*(x1+x2)
!
      CALL SINTEGRAL(x3, ndrpl, sinteg1, sinteg2, bet2, alfa, sig, tp, &
&              sg, wparc, sinteg3, modei, aa, bb)
      y3 = (sinteg1*cf1+sinteg2*cf2+sinteg3*cf1)*beta*SNGL(x3) - 1.
!
      IF (SIGN(1., y1)*SIGN(1., y3) .LE. 0.) THEN
! (Y1*Y3 .LE. ZERO)
        y2 = y3
        x2 = x3
      ELSE
        y1 = y3
        x1 = x3
      END IF
      IF (SNGL(x2 - x1) .GE. 0.) THEN
        abs0 = SNGL(x2 - x1)
      ELSE
        abs0 = -(1.*SNGL(x2-x1))
      END IF
!
      IF (abs0 .LE. eps*SNGL(x1)) GOTO 40
    END DO
!
!
! *** CONVERGED ; RETURN ************************************************
!
 40 x3 = 0.5d0*(x1+x2)
!
    CALL SINTEGRAL(x3, ndrpl, sinteg1, sinteg2, bet2, alfa, sig, tp, sg&
&            , wparc, sinteg3, modei, aa, bb)
    y3 = (sinteg1*cf1+sinteg2*cf2+sinteg3*cf1)*beta*SNGL(x3) - 1.
    smax = SNGL(x3)
    ndrplnrb = 1.e0
    CALL ACTIVATEP(wparc, tp, sg, akk, x3, ndrplnr, smaxnr, modei, dpg, &
&            sig, accom, aa, bb)
!    CALL ACTIVATEP_b(wparc, wparcb, tp, tpb, sg, sgb, akk, akkb, x3, ndrplnr,&
!&     ndrplnrb, smaxnr, modei, dpg, sig, accom, accomb, aa, aab, bb, bbb)
!
    RETURN
  END SUBROUTINE ACTIVATE
!  Differentiation of activatep in reverse (adjoint) mode (with options no!SliceDeadControl no!SliceDeadInstrs no!tryRecomputatio
!ns):
!   gradient     of useful results: ndrplnr
!   with respect to varying inputs: ndrplnr aa tp accom bb akk
!                wparc
!   RW status of diff variables: ndrplnr:in-zero aa:out tp:out
!                sgg:(loc) accom:out bb:out akk:out wparc:out
  SUBROUTINE ACTIVATEP_B(wparc, wparcb, tp, tpb, sgg, sggb, akk, akkb, &
&   x30, ndrplnr, ndrplnrb, smaxnr, modes, dpg, sigg, accom, accomb, aa&
&   , aab, bb, bbb)
    IMPLICIT NONE
!Sylvia: declarations
    REAL, INTENT(IN) :: tp(nm_drop), dpg(nm_drop), sigg(nm_drop), wparc
    REAL :: tpb(nm_drop), wparcb
    REAL, INTENT(IN) :: aa, bb, accom
    REAL :: aab, bbb, accomb
    REAL*8, INTENT(IN) :: x30
    REAL*8 :: x3f, x1d
    REAL*8 :: x3fb
    REAL :: ndrplnr, smaxnr
    REAL :: ndrplnrb
    REAL :: akk(nm_drop), sgg(nm_drop)
    REAL :: akkb(nm_drop), sggb(nm_drop)
    REAL :: arg1, pwr1
    REAL :: arg1b, pwr1b
    INTEGER, INTENT(IN) :: modes(nm_drop)
    REAL :: dpcm, dpc(nm_drop)
    REAL :: y3, y3d, par1, par2
    REAL :: y3b, y3db, par1b, par2b
    INTEGER :: k
    INTRINSIC SQRT
    INTRINSIC EXP
    INTRINSIC DBLE
    REAL :: pwx1
    REAL :: pwy1
    REAL :: pwy1b
    REAL :: c1, c2, c3, c4
    INTRINSIC SNGL
    INTEGER :: branch
    REAL :: temp
    DO k=1,nm_drop
!    Solve for Kohler Modes     
      IF (modes(k) .EQ. 1) THEN
!   KOHLER ACTIVATION
!VAK KK
        par1 = 4e0/27e0/akk(k)/dpg(k)**3.
        CALL PUSHREAL4(arg1)
        arg1 = par1*akoh_drop**3.
        CALL PUSHREAL4(par2)
        par2 = SQRT(arg1)
! Sc of Dpg
        sgg(k) = EXP(par2) - 1.
!   Finish solving for Kohler Modes
!   Solve for FHH Modes     
        CALL PUSHCONTROL2B(2)
      ELSE IF (modes(k) .EQ. 2) THEN
!   FHH ACTIVATION
!   Calculating Critical Super Saturation by Taylor Series Expansion 
        CALL DPCFHH(dpg(k), dpcm, aa, bb)
        dpc(k) = dpcm
        CALL PUSHREAL4(pwx1)
        pwx1 = (dpc(k)-dpg(k))/(2.*dw)
        CALL PUSHREAL4(pwy1)
        pwy1 = -bb
        CALL PUSHREAL4(pwr1)
        pwr1 = pwx1**pwy1
        sgg(k) = akoh_drop/dpc(k) + (-(aa*pwr1))
!   Finish solving for FHH Modes
        CALL PUSHCONTROL2B(1)
      ELSE
        CALL PUSHCONTROL2B(0)
      END IF
    END DO
    x1d = 1.0d0
    CALL SINTNR_D(wparc, tp, sgg, ndrplnr, x30, x1d, y3, y3d, sigg, &
&           modes, accom, aa, bb)
    x3f = x30 - y3/y3d
    CALL PUSHREAL4(y3)
    CALL SINTNR(wparc, tp, sgg, ndrplnr, x3f, y3, sigg, modes, accom, aa&
&         , bb)
    PRINT*, 'X30, X3f in SINTNR', x30, x3f
    smaxnr = SNGL(x3f)
    CALL POPREAL4(y3)
    CALL SINTNR_B(wparc, tp, tpb, sgg, sggb, ndrplnr, ndrplnrb, x3f, &
&           x3fb, y3, sigg, modes, accom, aa, aab, bb, bbb)
    y3b = -(x3fb/y3d)
    y3db = y3*x3fb/y3d**2
    CALL SINTNR_D_B(wparc, wparcb, tp, tpb, sgg, sggb, ndrplnr, x30, x1d&
&             , y3, y3b, y3d, y3db, sigg, modes, accom, accomb, aa, aab&
&             , bb, bbb)
    akkb = 0.0
    DO k=nm_drop,1,-1
      CALL POPCONTROL2B(branch)
      IF (branch .NE. 0) THEN
        IF (branch .EQ. 1) THEN
          aab = aab - pwr1*sggb(k)
          pwr1b = -(aa*sggb(k))
          sggb(k) = 0.0
          CALL POPREAL4(pwr1)
          IF (pwx1 .LE. 0.0) THEN
            pwy1b = 0.0
          ELSE
            pwy1b = pwx1**pwy1*LOG(pwx1)*pwr1b
          END IF
          CALL POPREAL4(pwy1)
          bbb = bbb - pwy1b
          CALL POPREAL4(pwx1)
        ELSE
          par2b = EXP(par2)*sggb(k)
          sggb(k) = 0.0
          CALL POPREAL4(par2)
          IF (arg1 .EQ. 0.0) THEN
            arg1b = 0.0
          ELSE
            arg1b = par2b/(2.0*SQRT(arg1))
          END IF
          CALL POPREAL4(arg1)
          par1b = akoh_drop**3.*arg1b
          temp = 27e0*dpg(k)**3.
          akkb(k) = akkb(k) - 4e0*par1b/(temp*akk(k)**2)
        END IF
      END IF
    END DO
    ndrplnrb = 0.0
  END SUBROUTINE ACTIVATEP_B
  SUBROUTINE ACTIVATEP(wparc, tp, sgg, akk, x30, ndrplnr, smaxnr, modes&
&   , dpg, sigg, accom, aa, bb)
    IMPLICIT NONE
!Sylvia: declarations
    REAL, INTENT(IN) :: tp(nm_drop), dpg(nm_drop), sigg(nm_drop), wparc
    REAL, INTENT(IN) :: aa, bb, accom
    REAL*8, INTENT(IN) :: x30
    REAL*8 :: x3f, x1d
    REAL, INTENT(OUT) :: ndrplnr, smaxnr
    REAL :: akk(nm_drop), sgg(nm_drop)
    REAL :: arg1, pwr1
    INTEGER, INTENT(IN) :: modes(nm_drop)
    REAL :: dpcm, dpc(nm_drop)
    REAL :: y3, y3d, par1, par2
    INTEGER :: k
    INTRINSIC SQRT
    INTRINSIC EXP
    INTRINSIC DBLE
    REAL :: pwx1
    REAL :: pwy1
    REAL :: c1, c2, c3, c4
    INTRINSIC SNGL
    DO k=1,nm_drop
!    Solve for Kohler Modes     
      IF (modes(k) .EQ. 1) THEN
!   KOHLER ACTIVATION
!VAK KK
        par1 = 4e0/27e0/akk(k)/dpg(k)**3.
        arg1 = par1*akoh_drop**3.
        par2 = SQRT(arg1)
! Sc of Dpg
        sgg(k) = EXP(par2) - 1.
!   Finish solving for Kohler Modes
!   Solve for FHH Modes     
      ELSE IF (modes(k) .EQ. 2) THEN
!   FHH ACTIVATION
!   Calculating Critical Super Saturation by Taylor Series Expansion 
        CALL DPCFHH(dpg(k), dpcm, aa, bb)
        dpc(k) = dpcm
        pwx1 = (dpc(k)-dpg(k))/(2.*dw)
        pwy1 = -bb
        pwr1 = pwx1**pwy1
        sgg(k) = akoh_drop/dpc(k) + (-(aa*pwr1))
!   Finish solving for FHH Modes
      END IF
    END DO
    x1d = 1.0d0
    CALL SINTNR_D(wparc, tp, sgg, ndrplnr, x30, x1d, y3, y3d, sigg, &
&           modes, accom, aa, bb)
    x3f = x30 - y3/y3d
    CALL SINTNR(wparc, tp, sgg, ndrplnr, x3f, y3, sigg, modes, accom, aa&
&         , bb)
    PRINT*, 'X30, X3f in SINTNR', x30, x3f
    smaxnr = SNGL(x3f)
    RETURN
  END SUBROUTINE ACTIVATEP
!C=======================================================================
!C
!C *** SUBROUTINE DpcFHH
!C *** THIS SUBROUTINE CALCULATES THE CRITICAL PARTICLE DIAMETER
!C     ACCORDING TO THE FHH ADSOSPRTION ISOTHERM THEORY.
!C
!C *** WRITTEN BY PRASHANT KUMAR AND ATHANASIOS NENES
!C
!C=======================================================================
!C
  SUBROUTINE DPCFHH(ddry, dc, a, b)
    IMPLICIT NONE
    REAL :: ddry, mu, mu1, mu2, mu3, x1, x2l, dpcm, dpcl, dpcu
    REAL :: x3, f1, f2, x3l, x2u, x3u, fdpcl, fdpcu, fdpcm, x2m, x3m, dc
    REAL, INTENT(IN) :: a, b
    INTRINSIC ABS
    REAL :: pwx1
    REAL :: pwy1
    REAL :: pwr1
    REAL :: abs1
    REAL :: abs0
    mu = 4.*surt*amw/(rgas*temp_drop*denw)
    pwx1 = .2*dw
    pwy1 = b + 1.
    pwr1 = pwx1**pwy1
    mu1 = mu*2.*dw/(a*b*pwr1)
    mu2 = 1./mu1
    pwy1 = 1./(1.+b)
    pwr1 = mu2**pwy1
    mu3 = 1. - pwr1
!Lower Limit
    dpcl = 0.
!Upper Limit
    dpcu = 10e-4
 100 pwy1 = .1/(1.+b)
    x1 = mu2**pwy1
    pwy1 = 2./(1.+b)
    x2l = dpcl**pwy1
    x3l = x1*x2l
    fdpcl = (dpcl-x3l)/ddry - 1.
    pwy1 = 1./(1.+b)
    x1 = mu2**pwy1
    pwy1 = 2./(1.+b)
    x2u = dpcu**pwy1
    x3u = x1*x2u
    fdpcu = (dpcu-x3u)/ddry - 1.
    dpcm = (dpcu+dpcl)/2.
    pwy1 = 1./(1.+b)
    x1 = mu2**pwy1
    pwy1 = 2./(1.+b)
    x2m = dpcm**pwy1
    x3m = x1*x2m
    fdpcm = (dpcm-x3m)/ddry - 1.
    IF (fdpcl*fdpcm .LE. 0.) THEN
      IF (fdpcm .GE. 0.) THEN
        abs0 = fdpcm
      ELSE
        abs0 = -fdpcm
      END IF
      IF (abs0 .GT. 10e-8) THEN
        dpcl = dpcl
        dpcu = dpcm
        GOTO 100
      END IF
    ELSE IF (fdpcl*fdpcm .GE. 0.) THEN
      IF (fdpcm .GE. 0.) THEN
        abs1 = fdpcm
      ELSE
        abs1 = -fdpcm
      END IF
      IF (abs1 .GT. 10e-8) THEN
        dpcl = dpcm
        dpcu = dpcu
        GOTO 100
      END IF
    END IF
    dc = dpcm
    RETURN
  END SUBROUTINE DPCFHH
!  Differentiation of sintnr_d in reverse (adjoint) mode (with options no!SliceDeadControl no!SliceDeadInstrs no!tryRecomputation
!s):
!   gradient     of useful results: y3 aa tp bb y3d sg
!   with respect to varying inputs: aa tp accom bb wparcel sg
!  Differentiation of sintnr in forward (tangent) mode:
!   variations   of useful results: y3
!   with respect to varying inputs: x3
!   RW status of diff variables: y3:out x3:in
  SUBROUTINE SINTNR_D_B(wparcel, wparcelb, tp, tpb, sg, sgb, ndrplnr, x3&
&   , x3d, y3, y3b, y3d, y3db, sig, modei, accom, accomb, aa, aab, bb, &
&   bbb)
    IMPLICIT NONE
    REAL :: bet1, cf1, cf2, sinteg1, sinteg2, sinteg3
    REAL :: cf1b, sinteg1b, sinteg2b, sinteg3b
    REAL :: sinteg1d, sinteg2d, sinteg3d
    REAL :: sinteg1db, sinteg2db, sinteg3db
    REAL :: bet2, alfa, beta, dv
    REAL :: bet2b, betab, dvb
    REAL :: dbig, pwr1, dlow, coef
    REAL :: pwr1b, dlowb
    REAL, INTENT(OUT) :: ndrplnr
    REAL :: y3
    REAL :: y3b
    REAL :: y3d
    REAL :: y3db
    REAL, INTENT(IN) :: wparcel, tp(nm_drop), sg(nm_drop), sig(nm_drop)&
&   , accom, aa, bb
    REAL :: wparcelb, tpb(nm_drop), sgb(nm_drop), accomb, aab, bbb
    REAL*8, INTENT(IN) :: x3
    REAL*8, INTENT(IN) :: x3d
    INTEGER, INTENT(IN) :: modei(nm_drop)
    REAL :: arg1
    REAL :: arg1b
    INTRINSIC LOG
    INTRINSIC SNGL
    REAL :: temp3
    REAL :: temp2
    REAL :: temp1
    REAL :: temp0
    REAL :: tempb7
    REAL :: tempb6
    REAL :: tempb5
    REAL :: tempb4
    REAL :: tempb3
    REAL :: tempb2
    REAL :: tempb1
    REAL :: tempb0
    REAL :: tempb
    REAL :: temp
    REAL :: temp7
    REAL :: temp6
    REAL :: temp5
    REAL :: temp4
! Dv average
    dbig = 5.0e-6
    pwr1 = accom**(-0.33048)
    dlow = 0.207683*pwr1
    dlow = dlow*1.e-6
    coef = (2.*pi*amw/(rgas*temp_drop))**0.5
!
    dv = 0.211/(pres_drop/1.013e5)*(temp_drop/273.)**1.94
! Water vapor diffusivity in air
    dv = 1.e-4*dv
! Non-continuum effects
    arg1 = (dbig+2.*dv/accom*coef)/(dlow+2.*dv/accom*coef)
    CALL PUSHREAL4(dv)
    dv = dv/(dbig-dlow)*(dbig-dlow-2.*dv/accom*coef*LOG(arg1))
    CALL PUSHREAL4(arg1)
    arg1 = pres_drop*ama/psat/amw + amw*dhv*dhv/cpair/rgas/temp_drop/&
&     temp_drop
    bet1 = arg1
    bet2 = rgas*temp_drop*denw/psat/dv/amw/4. + dhv*denw/4./aka/&
&     temp_drop*(dhv*amw/rgas/temp_drop-1.)
    alfa = grav*amw*dhv/cpair/rgas/temp_drop/temp_drop - grav*ama/rgas/&
&     temp_drop
    beta = 0.5e0*pi*bet1*denw/bet2/alfa/wparcel/dair
    cf1 = 0.5e0*(1./bet2/(alfa*wparcel))**0.5e0
    cf2 = akoh_drop/3e0
    CALL SINTEGRAL_D(x3, x3d, ndrplnr, sinteg1, sinteg1d, sinteg2, &
&              sinteg2d, bet2, alfa, sig, tp, sg, wparcel, sinteg3, &
&              sinteg3d, modei, aa, bb)
    y3d = beta*((cf1*sinteg1d+cf2*sinteg2d+cf1*sinteg3d)*SNGL(x3)+(&
&     sinteg1*cf1+sinteg2*cf2+sinteg3*cf1)*SNGL(x3d))
    y3 = (sinteg1*cf1+sinteg2*cf2+sinteg3*cf1)*beta*SNGL(x3) - 1e0
    temp7 = SNGL(x3d)
    temp6 = SNGL(x3)
    tempb2 = beta*temp6*y3db
    tempb1 = beta*temp7*y3db
    tempb = SNGL(x3)*y3b
    tempb0 = beta*tempb
    sinteg1b = cf1*tempb1 + cf1*tempb0
    cf1b = (sinteg3d+sinteg1d)*tempb2 + (sinteg3+sinteg1)*tempb1 + (&
&     sinteg3+sinteg1)*tempb0
    sinteg2b = cf2*tempb1 + cf2*tempb0
    sinteg3b = cf1*tempb1 + cf1*tempb0
    betab = (temp6*(cf1*sinteg1d+cf2*sinteg2d+cf1*sinteg3d)+temp7*(&
&     sinteg1*cf1+cf2*sinteg2+sinteg3*cf1))*y3db + (sinteg1*cf1+cf2*&
&     sinteg2+sinteg3*cf1)*tempb
    sinteg1db = cf1*tempb2
    sinteg2db = cf2*tempb2
    sinteg3db = cf1*tempb2
    CALL SINTEGRAL_D_B(x3, x3d, ndrplnr, sinteg1, sinteg1b, sinteg1d, &
&                sinteg1db, sinteg2, sinteg2b, sinteg2d, sinteg2db, bet2&
&                , bet2b, alfa, sig, tp, tpb, sg, sgb, wparcel, wparcelb&
&                , sinteg3, sinteg3b, sinteg3d, sinteg3db, modei, aa, &
&                aab, bb, bbb)
    temp5 = alfa*bet2*wparcel
    tempb3 = -(0.5e0**2*(1.0/temp5)**(-0.5)*cf1b/temp5**2)
    temp4 = alfa*dair*bet2*wparcel
    tempb4 = -(pi*0.5e0*bet1*denw*alfa*dair*betab/temp4**2)
    bet2b = bet2b + wparcel*tempb4 + wparcel*alfa*tempb3
    wparcelb = wparcelb + bet2*tempb4 + alfa*bet2*tempb3
    temp3 = 4.*psat*amw
    dvb = -(rgas*temp_drop*denw*bet2b/(temp3*dv**2))
    CALL POPREAL4(arg1)
    CALL POPREAL4(dv)
    temp2 = LOG(arg1)
    temp0 = temp2/accom
    temp1 = 2.*dv*coef
    tempb5 = dv*dvb/(dbig-dlow)
    tempb6 = -(temp1*tempb5/accom)
    arg1b = tempb6/arg1
    temp = dlow + 2.*dv*coef/accom
    tempb7 = -((dbig+dv*2.*(coef/accom))*arg1b/temp**2)
    dlowb = tempb7 + ((dbig-dlow-temp1*temp0)/(dbig-dlow)-1.0)*tempb5
    dlowb = 1.e-6*dlowb
    pwr1b = 0.207683*dlowb
    accomb = -(dv*2.*coef*arg1b/(accom**2*temp)) - dv*2.*coef*tempb7/&
&     accom**2 - 0.33048*accom**(-1.33048)*pwr1b - temp0*tempb6
  END SUBROUTINE SINTNR_D_B
!  Differentiation of sintnr in forward (tangent) mode:
!   variations   of useful results: y3
!   with respect to varying inputs: x3
!   RW status of diff variables: y3:out x3:in
  SUBROUTINE SINTNR_D(wparcel, tp, sg, ndrplnr, x3, x3d, y3, y3d, sig, &
&   modei, accom, aa, bb)
    IMPLICIT NONE
    REAL :: bet1, cf1, cf2, sinteg1, sinteg2, sinteg3
    REAL :: sinteg1d, sinteg2d, sinteg3d
    REAL :: bet2, alfa, beta, dv
    REAL :: dbig, pwr1, dlow, coef
    REAL, INTENT(OUT) :: ndrplnr
    REAL, INTENT(OUT) :: y3
    REAL, INTENT(OUT) :: y3d
    REAL, INTENT(IN) :: wparcel, tp(nm_drop), sg(nm_drop), sig(nm_drop)&
&   , accom, aa, bb
    REAL*8, INTENT(IN) :: x3
    REAL*8, INTENT(IN) :: x3d
    INTEGER, INTENT(IN) :: modei(nm_drop)
    REAL :: arg1
    INTRINSIC LOG
    INTRINSIC SNGL
! Dv average
    dbig = 5.0e-6
    pwr1 = accom**(-0.33048)
    dlow = 0.207683*pwr1
    dlow = dlow*1.e-6
    coef = (2.*pi*amw/(rgas*temp_drop))**0.5
!
    dv = 0.211/(pres_drop/1.013e5)*(temp_drop/273.)**1.94
! Water vapor diffusivity in air
    dv = 1.e-4*dv
! Non-continuum effects
    arg1 = (dbig+2.*dv/accom*coef)/(dlow+2.*dv/accom*coef)
    dv = dv/(dbig-dlow)*(dbig-dlow-2.*dv/accom*coef*LOG(arg1))
    arg1 = pres_drop*ama/psat/amw + amw*dhv*dhv/cpair/rgas/temp_drop/&
&     temp_drop
    bet1 = arg1
    bet2 = rgas*temp_drop*denw/psat/dv/amw/4. + dhv*denw/4./aka/&
&     temp_drop*(dhv*amw/rgas/temp_drop-1.)
    alfa = grav*amw*dhv/cpair/rgas/temp_drop/temp_drop - grav*ama/rgas/&
&     temp_drop
    beta = 0.5e0*pi*bet1*denw/bet2/alfa/wparcel/dair
    cf1 = 0.5e0*(1./bet2/(alfa*wparcel))**0.5e0
    cf2 = akoh_drop/3e0
    CALL SINTEGRAL_D(x3, x3d, ndrplnr, sinteg1, sinteg1d, sinteg2, &
&              sinteg2d, bet2, alfa, sig, tp, sg, wparcel, sinteg3, &
&              sinteg3d, modei, aa, bb)
    y3d = beta*((cf1*sinteg1d+cf2*sinteg2d+cf1*sinteg3d)*SNGL(x3)+(&
&     sinteg1*cf1+sinteg2*cf2+sinteg3*cf1)*SNGL(x3d))
    y3 = (sinteg1*cf1+sinteg2*cf2+sinteg3*cf1)*beta*SNGL(x3) - 1e0
    RETURN
  END SUBROUTINE SINTNR_D
!  Differentiation of sintnr in reverse (adjoint) mode (with options no!SliceDeadControl no!SliceDeadInstrs no!tryRecomputations)
!:
!   gradient     of useful results: ndrplnr
!   with respect to varying inputs: aa tp bb sg x3
  SUBROUTINE SINTNR_B(wparcel, tp, tpb, sg, sgb, ndrplnr, ndrplnrb, x3, &
&   x3b, y3, sig, modei, accom, aa, aab, bb, bbb)
    IMPLICIT NONE
    REAL :: bet1, cf1, cf2, sinteg1, sinteg2, sinteg3
    REAL :: bet2, alfa, beta, dv
    REAL :: dbig, pwr1, dlow, coef
    REAL :: ndrplnr
    REAL :: ndrplnrb
    REAL, INTENT(OUT) :: y3
    REAL, INTENT(IN) :: wparcel, tp(nm_drop), sg(nm_drop), sig(nm_drop)&
&   , accom, aa, bb
    REAL :: tpb(nm_drop), sgb(nm_drop), aab, bbb
    REAL*8, INTENT(IN) :: x3
    REAL*8 :: x3b
    INTEGER, INTENT(IN) :: modei(nm_drop)
    REAL :: arg1
    INTRINSIC LOG
    INTRINSIC SNGL
! Dv average
    dbig = 5.0e-6
    pwr1 = accom**(-0.33048)
    dlow = 0.207683*pwr1
    dlow = dlow*1.e-6
    coef = (2.*pi*amw/(rgas*temp_drop))**0.5
!
    dv = 0.211/(pres_drop/1.013e5)*(temp_drop/273.)**1.94
! Water vapor diffusivity in air
    dv = 1.e-4*dv
! Non-continuum effects
    arg1 = (dbig+2.*dv/accom*coef)/(dlow+2.*dv/accom*coef)
    dv = dv/(dbig-dlow)*(dbig-dlow-2.*dv/accom*coef*LOG(arg1))
    arg1 = pres_drop*ama/psat/amw + amw*dhv*dhv/cpair/rgas/temp_drop/&
&     temp_drop
    bet1 = arg1
    bet2 = rgas*temp_drop*denw/psat/dv/amw/4. + dhv*denw/4./aka/&
&     temp_drop*(dhv*amw/rgas/temp_drop-1.)
    alfa = grav*amw*dhv/cpair/rgas/temp_drop/temp_drop - grav*ama/rgas/&
&     temp_drop
    beta = 0.5e0*pi*bet1*denw/bet2/alfa/wparcel/dair
    cf1 = 0.5e0*(1./bet2/(alfa*wparcel))**0.5e0
    cf2 = akoh_drop/3e0
    CALL SINTEGRAL(x3, ndrplnr, sinteg1, sinteg2, bet2, alfa, sig, tp, &
&            sg, wparcel, sinteg3, modei, aa, bb)
    CALL PUSHREAL4(y3)
    y3 = (sinteg1*cf1+sinteg2*cf2+sinteg3*cf1)*beta*SNGL(x3) - 1e0
    CALL POPREAL4(y3)
    CALL SINTEGRAL_B(x3, x3b, ndrplnr, ndrplnrb, sinteg1, sinteg2, bet2&
&              , alfa, sig, tp, tpb, sg, sgb, wparcel, sinteg3, modei, &
&              aa, aab, bb, bbb)
  END SUBROUTINE SINTNR_B
  SUBROUTINE SINTNR(wparcel, tp, sg, ndrplnr, x3, y3, sig, modei, accom&
&   , aa, bb)
    IMPLICIT NONE
    REAL :: bet1, cf1, cf2, sinteg1, sinteg2, sinteg3
    REAL :: bet2, alfa, beta, dv
    REAL :: dbig, pwr1, dlow, coef
    REAL, INTENT(OUT) :: ndrplnr
    REAL, INTENT(OUT) :: y3
    REAL, INTENT(IN) :: wparcel, tp(nm_drop), sg(nm_drop), sig(nm_drop)&
&   , accom, aa, bb
    REAL*8, INTENT(IN) :: x3
    INTEGER, INTENT(IN) :: modei(nm_drop)
    REAL :: arg1
    INTRINSIC LOG
    INTRINSIC SNGL
! Dv average
    dbig = 5.0e-6
    pwr1 = accom**(-0.33048)
    dlow = 0.207683*pwr1
    dlow = dlow*1.e-6
    coef = (2.*pi*amw/(rgas*temp_drop))**0.5
!
    dv = 0.211/(pres_drop/1.013e5)*(temp_drop/273.)**1.94
! Water vapor diffusivity in air
    dv = 1.e-4*dv
! Non-continuum effects
    arg1 = (dbig+2.*dv/accom*coef)/(dlow+2.*dv/accom*coef)
    dv = dv/(dbig-dlow)*(dbig-dlow-2.*dv/accom*coef*LOG(arg1))
    arg1 = pres_drop*ama/psat/amw + amw*dhv*dhv/cpair/rgas/temp_drop/&
&     temp_drop
    bet1 = arg1
    bet2 = rgas*temp_drop*denw/psat/dv/amw/4. + dhv*denw/4./aka/&
&     temp_drop*(dhv*amw/rgas/temp_drop-1.)
    alfa = grav*amw*dhv/cpair/rgas/temp_drop/temp_drop - grav*ama/rgas/&
&     temp_drop
    beta = 0.5e0*pi*bet1*denw/bet2/alfa/wparcel/dair
    cf1 = 0.5e0*(1./bet2/(alfa*wparcel))**0.5e0
    cf2 = akoh_drop/3e0
    CALL SINTEGRAL(x3, ndrplnr, sinteg1, sinteg2, bet2, alfa, sig, tp, &
&            sg, wparcel, sinteg3, modei, aa, bb)
    y3 = (sinteg1*cf1+sinteg2*cf2+sinteg3*cf1)*beta*SNGL(x3) - 1e0
    RETURN
  END SUBROUTINE SINTNR
!  Differentiation of sintegral_d in reverse (adjoint) mode (with options no!SliceDeadControl no!SliceDeadInstrs no!tryRecomputat
!ions):
!   gradient     of useful results: summatd aa tp summat sumfhhd
!                bb sum sg sumd sumfhh
!   with respect to varying inputs: aa tp bet2 bb wparcel sg
!  Differentiation of sintegral in forward (tangent) mode:
!   variations   of useful results: summat sum sumfhh
!   with respect to varying inputs: spar
!=======================================================================
!
! *** SUBROUTINE SINTEGRAL
! *** THIS SUBROUTINE CALCULATES THE CONDENSATION INTEGRALS, ACCORDING
!     TO THE POPULATION SPLITTING ALGORITHM AND THE SUBSEQUENT VERSIONS:
!
!       - Nenes and Seinfeld (2003)       Population Splitting
!       - Fountoukis and Nenes (2004)     Modal formulation
!       - Barahona and Nenes (2010)       Approach for large CCN
!       - Morales and Nenes (2014)        Population Splitting revised
!
! *** WRITTEN BY ATHANASIOS NENES for Kohler Particles
! *** MODFIFIED BY PRASHANT KUMAR AND ATHANASIOS NENES TO INCLUDE FHH
!     PARTICLES
!=======================================================================
  SUBROUTINE SINTEGRAL_D_B(spar, spard, summa, sum, sumb, sumd, sumdb, &
&   summat, summatb, summatd, summatdb, bet2, bet2b, alfa, sig, tp, tpb&
&   , sg, sgb, wparcel, wparcelb, sumfhh, sumfhhb, sumfhhd, sumfhhdb, &
&   modei, aa, aab, bb, bbb)
    IMPLICIT NONE
    REAL :: sum, summat, summa, nd(nm_drop), sumfhh, integ1(nm_drop), &
&   integ2(nm_drop), integ1f(nm_drop), ndf(nm_drop)
    REAL :: sumb, summatb, sumfhhb, integ1b(nm_drop), integ2b(nm_drop), &
&   integ1fb(nm_drop)
    REAL :: sumd, summatd, sumfhhd, integ1d(nm_drop), integ2d(nm_drop), &
&   integ1fd(nm_drop)
    REAL :: sumdb, summatdb, sumfhhdb, integ1db(nm_drop), integ2db(&
&   nm_drop), integ1fdb(nm_drop)
    REAL, INTENT(IN) :: aa, bb
    REAL :: aab, bbb
    REAL :: c1, c2, c3, c4, xfhh
    REAL :: c1b, c2b, c3b, c4b, xfhhb
    REAL :: wparcel, tp(nm_drop), sg(nm_drop), bet2, sig(nm_drop)
    REAL :: wparcelb, tpb(nm_drop), sgb(nm_drop), bet2b
    REAL :: erf1, erf2, erf3, erf4, erf5, erf6, erf4f, erf5f
    REAL :: erf1b, erf2b, erf3b, erf4b, erf6b, erf4fb, erf5fb
    REAL :: erf1d, erf2d, erf3d, erf4d, erf6d, erf4fd, erf5fd
    REAL :: erf1db, erf2db, erf3db, erf4db, erf6db, erf4fdb, erf5fdb
    REAL :: orism1, orism2, orism3, orism4, orism5, orism6
    REAL :: orism1b, orism2b, orism3b, orism4b, orism5b, orism6b
    REAL :: orism1d, orism2d, orism3d, orism4d, orism5d, orism6d
    REAL :: orism1db, orism2db, orism3db, orism4db, orism5db, orism6db
    REAL :: scrit, deq, dw3
    REAL :: scritb, deqb, dw3b
    REAL :: dw3d
    REAL :: dw3db
    REAL :: orism1f, orism2f, orism3f, orism4f, orism5f, orism6f, &
&   orism7f
    REAL :: orism1fb, orism2fb, orism3fb, orism4fb, orism5fb, orism6fb, &
&   orism7fb
    REAL :: orism1fd, orism4fd, orism5fd, orism6fd, orism7fd
    REAL :: orism1fdb, orism4fdb, orism5fdb, orism6fdb, orism7fdb
    REAL :: orism8f, orism9f
    REAL :: orism8fb, orism9fb
    REAL :: orism8fd, orism9fd
    REAL :: orism8fdb, orism9fdb
    LOGICAL :: crit2
!Sylvia
    REAL :: alfa, ratio
    REAL :: ratiob
    REAL :: ratiod
    REAL*8 :: descr, ssplt1, ssplt2, spar
    REAL*8 :: descrb, ssplt1b, ssplt2b
    REAL*8 :: descrd, ssplt1d, ssplt2d, spard
    REAL*8 :: descrdb, ssplt1db, ssplt2db
    REAL :: ekth, xl, z, p1, p2
    REAL :: dlgsgf, dlgspf
    REAL :: dlgspfb
    REAL :: dlgspfd
    REAL :: dlgspfdb
    REAL :: sqtwo, dlgsg, dlgsp, dlgsp2, dlgsp1, intaux1p2, intaux1p1
    REAL :: dlgspb, dlgsp2b, dlgsp1b, intaux1p2b, intaux1p1b
    REAL :: dlgspd, dlgsp2d, dlgsp1d, intaux1p2d, intaux1p1d
    REAL :: dlgspdb, dlgsp2db, dlgsp1db, intaux1p2db, intaux1p1db
    INTEGER :: j, i, modei(nm_drop)
    INTRINSIC SQRT
    INTRINSIC DBLE
    INTRINSIC LOG
    INTRINSIC SNGL
    INTRINSIC EXP
    REAL :: arg1
    REAL :: arg1b
    REAL :: arg1d
    REAL :: arg1db
    REAL :: pwr1
    REAL :: pwr1d
    REAL :: pwr2
    REAL :: pwr2b
    REAL*8 :: result1
    REAL*8 :: result1b
    REAL*8 :: result1d
    REAL*8 :: result1db
    REAL :: result10
    REAL :: arg10
    REAL :: arg2
    REAL :: arg2b
    REAL :: arg11
    REAL :: arg11b
    REAL :: arg12
    REAL :: arg12b
    REAL :: arg12d
    REAL :: arg12db
    REAL*8 :: pwr10
    REAL*8 :: pwr10d
    REAL :: arg13
    REAL :: arg13b
    REAL :: arg13d
    REAL :: arg13db
    INTRINSIC ABS
    INTEGER :: branch
    REAL :: temp3
    REAL :: temp29
    REAL :: temp2
    REAL :: temp28
    REAL :: temp1
    REAL :: temp27
    REAL :: temp0
    REAL :: temp26
    REAL :: temp25
    REAL :: temp24
    REAL :: temp23
    REAL :: temp22
    REAL :: temp21
    REAL :: temp20
    REAL :: tempb9
    REAL :: tempb8
    REAL :: tempb7
    REAL :: tempb6
    REAL :: temp51
    REAL :: tempb5
    REAL :: temp50
    REAL*8 :: tempb4
    REAL :: tempb19
    REAL*8 :: tempb3
    REAL :: tempb18
    REAL*8 :: tempb2
    REAL :: tempb17
    REAL*8 :: tempb1
    REAL :: tempb16
    REAL :: tempb0
    REAL :: tempb15
    REAL :: tempb14
    REAL :: tempb13
    REAL :: tempb12
    REAL :: tempb11
    REAL :: tempb10
    REAL :: temp19
    REAL :: temp18
    REAL :: temp17
    REAL :: temp16
    REAL :: temp15
    REAL :: temp14
    REAL :: temp13
    REAL*8 :: temp12
    REAL :: temp49
    REAL*8 :: temp11
    REAL :: temp48
    REAL*8 :: temp10
    REAL :: temp47
    REAL :: temp46
    REAL :: temp45
    REAL :: temp44
    REAL :: temp43
    REAL :: temp42
    REAL :: temp41
    REAL :: temp40
    REAL :: tempb
    REAL :: tempb38
    REAL :: tempb37
    REAL :: tempb36
    REAL :: tempb35
    REAL :: tempb34
    REAL :: tempb33
    REAL :: tempb32
    REAL :: tempb31
    REAL :: tempb30
    REAL :: temp39
    REAL :: temp38
    REAL :: temp37
    REAL :: temp36
    REAL :: temp35
    REAL :: temp34
    REAL :: temp33
    REAL :: temp32
    REAL :: temp31
    REAL*8 :: abs3
    REAL :: temp30
    REAL*8 :: abs2
    REAL*8 :: abs1
    REAL*8 :: abs0
    REAL :: tempb29
    REAL :: tempb28
    REAL :: tempb27
    REAL :: tempb26
    REAL :: tempb25
    REAL :: temp
    REAL :: tempb24
    REAL :: tempb23
    REAL :: tempb22
    REAL*8 :: temp9
    REAL :: tempb21
    REAL :: temp8
    REAL :: tempb20
    REAL :: temp7
    REAL :: temp6
    REAL :: temp5
    REAL :: temp4
!
! *** Here is where the criterion with the descriminant is put. When it
!     is < 0, then set CRIT2 = .TRUE. Otherwise, set the two values of
!     SSPLT and continue.
!C ** Population Splitting -- Modified by Ricardo Morales 2013
    c1 = d11 + d12/aa + d13/(aa*aa) + d14/(aa*aa*aa) + d15/(aa*aa*aa*aa)
    c2 = d21 + d22/aa + d23/(aa*aa) + d24/(aa*aa*aa) + d25/(aa*aa*aa*aa)
    c3 = d31 + d32/aa + d33/(aa*aa) + d34/(aa*aa*aa) + d35/(aa*aa*aa*aa)
    c4 = d41 + d42/aa + d43/(aa*aa) + d44/(aa*aa*aa) + d45/(aa*aa*aa*aa)
    xfhh = c1 + c2/bb + c3/(bb*bb) + c4/(bb*bb*bb)
    sqtwo = SQRT(2.)
    arg1 = alfa*wparcel*bet2
    descrd = 16d0*DBLE(arg1)*2d0**2*DBLE(akoh_drop)**2*spar*spard/(9d0*(&
&     spar**2d0)**3)
    descr = 1d0 - 16d0/9d0*DBLE(arg1)*(DBLE(akoh_drop)/spar**2d0)**2d0
    IF (descr .LE. 0d0) THEN
      crit2 = .true.
! Scrit - (only for DELTA < 0 )
      scrit = (16./9.*alfa*wparcel*bet2*akoh_drop**2.)**0.25
! Computing sp1 and sp2 (sp1 = sp2)
      IF (spar .GT. 0.0) THEN
        pwr10d = -(0.3824d0*spar**(-1.3824d0)*spard)
        CALL PUSHCONTROL1B(0)
      ELSE
        pwr10d = 0.0
        CALL PUSHCONTROL1B(1)
      END IF
      pwr10 = spar**(-0.3824d0)
      pwr1d = SNGL(pwr10d)
      pwr1 = SNGL(pwr10)
      pwr2 = scrit**(-0.3824)
      ratiod = 2.0e7*akoh_drop*pwr1d/3.0
      ratio = 2.0e7/3.0*akoh_drop*(pwr1-pwr2)
      ratio = 1./sqtwo + ratio
      IF (ratio .GT. 1.0) THEN
        ratio = 1.0
        ratiod = 0.0
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      ssplt2d = spard*DBLE(ratio) + spar*ratiod
      ssplt2 = spar*DBLE(ratio)
      ssplt1d = 0.0_8
      CALL PUSHCONTROL1B(0)
    ELSE
      crit2 = .false.
      IF (descr .GE. 0.) THEN
        abs0 = descr
        CALL PUSHCONTROL1B(0)
      ELSE
        abs0 = -descr
        CALL PUSHCONTROL1B(1)
      END IF
! min root of both
      IF (abs0 .LE. 1d-10) THEN
        result1d = 0.0_8
        CALL PUSHCONTROL1B(1)
      ELSE
        result1d = descrd/(2.0*SQRT(descr))
        CALL PUSHCONTROL1B(0)
      END IF
      result1 = SQRT(descr)
      ssplt1d = -(0.5d0*result1d)
      ssplt1 = 0.5d0*(1.d0-result1)
      IF (descr .GE. 0.) THEN
        abs1 = descr
        CALL PUSHCONTROL1B(0)
      ELSE
        abs1 = -descr
        CALL PUSHCONTROL1B(1)
      END IF
! max root of both
      IF (abs1 .LE. 1d-10) THEN
        result1d = 0.0_8
        CALL PUSHCONTROL1B(1)
      ELSE
        result1d = descrd/(2.0*SQRT(descr))
        CALL PUSHCONTROL1B(0)
      END IF
      result1 = SQRT(descr)
      ssplt2d = 0.5d0*result1d
      ssplt2 = 0.5d0*(1.d0+result1)
      IF (ssplt1 .GE. 0.) THEN
        abs2 = ssplt1
        CALL PUSHCONTROL1B(0)
      ELSE
        abs2 = -ssplt1
        CALL PUSHCONTROL1B(1)
      END IF
! Multiply ratios with Smax
      IF (abs2 .LE. 1d-10) THEN
        result1d = 0.0_8
        CALL PUSHCONTROL1B(1)
      ELSE
        result1d = ssplt1d/(2.0*SQRT(ssplt1))
        CALL PUSHCONTROL1B(0)
      END IF
      result1 = SQRT(ssplt1)
      CALL PUSHREAL8(ssplt1d)
      ssplt1d = result1d*spar + result1*spard
      CALL PUSHREAL8(ssplt1)
      ssplt1 = result1*spar
      IF (ssplt2 .GE. 0.) THEN
        abs3 = ssplt2
        CALL PUSHCONTROL1B(0)
      ELSE
        abs3 = -ssplt2
        CALL PUSHCONTROL1B(1)
      END IF
      IF (abs3 .LE. 1d-10) THEN
        result1d = 0.0_8
        CALL PUSHCONTROL1B(0)
      ELSE
        result1d = ssplt2d/(2.0*SQRT(ssplt2))
        CALL PUSHCONTROL1B(1)
      END IF
      result1 = SQRT(ssplt2)
      CALL PUSHREAL8(ssplt2d)
      ssplt2d = result1d*spar + result1*spard
      CALL PUSHREAL8(ssplt2)
      ssplt2 = result1*spar
      CALL PUSHCONTROL1B(1)
    END IF
! *** Computing the condensation integrals I1 and I2
!
!Contribution of integral 1 for Kohler 
    sum = 0.0
!Contribution of integral 2 for kohler
    summat = 0.0
!Variable that stores all droplets
    summa = 0.0
!Contribution of FHH integral
    sumfhh = 0.0
    summatd = 0.0
    sumd = 0.0
    sumfhhd = 0.0
    integ1d = 0.0
    integ2d = 0.0
    integ1fd = 0.0
    DO j=1,nm_drop
      IF (modei(j) .EQ. 1) THEN
! Koehler modes
!ln(sigmai)
        CALL PUSHREAL4(dlgsg)
        dlgsg = LOG(sig(j))
!ln(sg/smax)
        CALL PUSHREAL4(arg13d)
        arg13d = -(sg(j)*SNGL(spard)/SNGL(spar)**2)
        CALL PUSHREAL4(arg13)
        arg13 = sg(j)/SNGL(spar)
        dlgspd = arg13d/arg13
        dlgsp = LOG(arg13)
!RM: ln(sg/sp2)
        CALL PUSHREAL4(arg1d)
        arg1d = -(sg(j)*SNGL(ssplt2d)/SNGL(ssplt2)**2)
        CALL PUSHREAL4(arg1)
        arg1 = sg(j)/SNGL(ssplt2)
        dlgsp2d = arg1d/arg1
        dlgsp2 = LOG(arg1)
! u(sp2)
        CALL PUSHREAL4(orism1d)
        orism1d = 2.*dlgsp2d/(3.*sqtwo*dlgsg)
        CALL PUSHREAL4(orism1)
        orism1 = 2.*dlgsp2/(3.*sqtwo*dlgsg)
! u(sp2)-3ln(sigmai)/(2sqrt(2)
        CALL PUSHREAL4(orism2d)
        orism2d = orism1d
        CALL PUSHREAL4(orism2)
        orism2 = orism1 - 3.*dlgsg/(2.*sqtwo)
! RM: u(smax)
        orism5d = 2.*dlgspd/(3.*sqtwo*dlgsg)
        orism5 = 2.*dlgsp/(3.*sqtwo*dlgsg)
! u(smax)-3ln(sigmai)/(2sqrt(2)
        CALL PUSHREAL4(orism3d)
        orism3d = orism5d
        CALL PUSHREAL4(orism3)
        orism3 = orism5 - 3.*dlgsg/(2.*sqtwo)
! RM: Dp0 = Dpc/sqrt(3) - Equilibrium diameter
        CALL PUSHREAL4(result10)
        result10 = SQRT(3.)
        CALL PUSHREAL4(deq)
        deq = akoh_drop*2./sg(j)/3./result10
        CALL PUSHREAL4(erf2d)
        CALL PUSHREAL4(erf2)
        erf2d = ERFP_D(orism2, orism2d, erf2)
        CALL PUSHREAL4(erf3d)
        CALL PUSHREAL4(erf3)
        erf3d = ERFP_D(orism3, orism3d, erf3)
        CALL PUSHREAL4(arg10)
        arg10 = 9./8.*dlgsg*dlgsg
        CALL PUSHREAL4(arg2)
        arg2 = tp(j)/sg(j)
        integ2d(j) = EXP(arg10)*arg2*(erf2d-erf3d)
        integ2(j) = EXP(arg10)*arg2*(erf2-erf3)
! I2(sp2,smax)
        IF (crit2) THEN
          CALL PUSHREAL4(orism6d)
          orism6d = sqtwo*dlgsp2d/3./dlgsg
          CALL PUSHREAL4(orism6)
          orism6 = sqtwo*dlgsp2/3./dlgsg - 1.5*dlgsg/sqtwo
          CALL PUSHREAL4(erf6d)
          CALL PUSHREAL4(erf6)
          erf6d = ERFP_D(orism6, orism6d, erf6)
          integ1d(j) = 0.0
          integ1(j) = 0.0
! 'inertially' limited particles
          CALL PUSHREAL4(arg11)
          arg11 = 9./8.*dlgsg*dlgsg
          dw3d = -(tp(j)*deq*EXP(arg11)*(bet2*alfa*wparcel)**0.5*erf6d)
          dw3 = tp(j)*deq*EXP(arg11)*(1.-erf6)*(bet2*alfa*wparcel)**0.5
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHREAL4(ekth)
          ekth = EXP(9./2.*dlgsg*dlgsg)
! RM: ln(sg/sp1)
          CALL PUSHREAL4(arg12d)
          arg12d = -(sg(j)*SNGL(ssplt1d)/SNGL(ssplt1)**2)
          CALL PUSHREAL4(arg12)
          arg12 = sg(j)/SNGL(ssplt1)
          dlgsp1d = arg12d/arg12
          dlgsp1 = LOG(arg12)
! u(sp2) + 3ln(sigmai)/sqrt(2)
          CALL PUSHREAL4(orism4d)
          orism4d = orism1d
          CALL PUSHREAL4(orism4)
          orism4 = orism1 + 3.*dlgsg/sqtwo
          CALL PUSHREAL4(erf1d)
          CALL PUSHREAL4(erf1)
          erf1d = ERFP_D(orism1, orism1d, erf1)
          CALL PUSHREAL4(erf4d)
          CALL PUSHREAL4(erf4)
          erf4d = ERFP_D(orism4, orism4d, erf4)
! I1(0,sp2)
          intaux1p2d = tp(j)*(SNGL(spard)*(1.-erf1-0.5*(sg(j)/SNGL(spar)&
&           )**2.*ekth*(1.-erf4))+SNGL(spar)*(-erf1d-0.5*ekth*(-(2.*sg(j&
&           )**2*SNGL(spard)*(1.-erf4)/SNGL(spar)**3)-(sg(j)/SNGL(spar))&
&           **2.*erf4d)))
          intaux1p2 = tp(j)*SNGL(spar)*(1.-erf1-0.5*(sg(j)/SNGL(spar))**&
&           2.*ekth*(1.-erf4))
! u(sp1) 
          CALL PUSHREAL4(orism1d)
          orism1d = 2.*dlgsp1d/(3.*sqtwo*dlgsg)
          CALL PUSHREAL4(orism1)
          orism1 = 2.*dlgsp1/(3.*sqtwo*dlgsg)
! u(sp1) + 3ln(sigmai)/sqrt(2)
          CALL PUSHREAL4(orism4d)
          orism4d = orism1d
          CALL PUSHREAL4(orism4)
          orism4 = orism1 + 3.*dlgsg/sqtwo
          CALL PUSHREAL4(orism6d)
          orism6d = sqtwo*dlgsp1d/3./dlgsg
          CALL PUSHREAL4(orism6)
          orism6 = sqtwo*dlgsp1/3./dlgsg - 1.5*dlgsg/sqtwo
          CALL PUSHREAL4(erf1d)
          CALL PUSHREAL4(erf1)
          erf1d = ERFP_D(orism1, orism1d, erf1)
          CALL PUSHREAL4(erf4d)
          CALL PUSHREAL4(erf4)
          erf4d = ERFP_D(orism4, orism4d, erf4)
          CALL PUSHREAL4(erf6d)
          CALL PUSHREAL4(erf6)
          erf6d = ERFP_D(orism6, orism6d, erf6)
! I1(0,sp1)
          intaux1p1d = tp(j)*(SNGL(spard)*(1.-erf1-0.5*(sg(j)/SNGL(spar)&
&           )**2.*ekth*(1.-erf4))+SNGL(spar)*(-erf1d-0.5*ekth*(-(2.*sg(j&
&           )**2*SNGL(spard)*(1.-erf4)/SNGL(spar)**3)-(sg(j)/SNGL(spar))&
&           **2.*erf4d)))
          intaux1p1 = tp(j)*SNGL(spar)*(1.-erf1-0.5*(sg(j)/SNGL(spar))**&
&           2.*ekth*(1.-erf4))
! I1(sp1,sp2) = I1(0,sp2) - I1(0,sp1)
          integ1d(j) = intaux1p2d - intaux1p1d
          integ1(j) = intaux1p2 - intaux1p1
! 'inertially' limited particles.
          CALL PUSHREAL4(arg11)
          arg11 = 9./8.*dlgsg*dlgsg
          dw3d = -(tp(j)*deq*EXP(arg11)*(bet2*alfa*wparcel)**0.5*erf6d)
          dw3 = tp(j)*deq*EXP(arg11)*(1.-erf6)*(bet2*alfa*wparcel)**0.5
          CALL PUSHCONTROL1B(1)
        END IF
!C *** Calculate number of Drops
        erf5 = ERFP(orism5)
        nd(j) = tp(j)/2.*(1.-erf5)
!SUM OF INTEGRAL 1 FOR KOHLER
        sumd = sumd + integ1d(j) + dw3d
        sum = sum + integ1(j) + dw3
!SUM OF INTEGRAL 2 FOR KOHLER
        summatd = summatd + integ2d(j)
        summat = summat + integ2(j)
!SUM OF ACTIVATED KOHLER PARTICLES
        summa = summa + nd(j)
        CALL PUSHCONTROL2B(2)
      ELSE IF (modei(j) .EQ. 2) THEN
! FHH modes
! ln(sigma,i)
        CALL PUSHREAL4(dlgsgf)
        dlgsgf = LOG(sig(j))
! ln(sg/smax)
        CALL PUSHREAL4(arg13d)
        arg13d = -(sg(j)*SNGL(spard)/SNGL(spar)**2)
        CALL PUSHREAL4(arg13)
        arg13 = sg(j)/SNGL(spar)
        CALL PUSHREAL4(dlgspfd)
        dlgspfd = arg13d/arg13
        CALL PUSHREAL4(dlgspf)
        dlgspf = LOG(arg13)
! (sg/smax)^2
        CALL PUSHREAL4(orism1fd)
        orism1fd = -(sg(j)**2*SNGL(spard*spar+spar*spard)/SNGL(spar*spar&
&         )**2)
        CALL PUSHREAL4(orism1f)
        orism1f = sg(j)*sg(j)/SNGL(spar*spar)
! exp(term)
        CALL PUSHREAL4(arg11)
        arg11 = 2.*xfhh*xfhh*dlgsgf*dlgsgf
        CALL PUSHREAL4(orism2f)
        orism2f = EXP(arg11)
! sqrt(2).x.ln(sigma,i)
        CALL PUSHREAL4(orism3f)
        orism3f = sqtwo*xfhh*dlgsgf
! Umax
        CALL PUSHREAL4(orism4fd)
        orism4fd = dlgspfd/(-(1.*orism3f))
        CALL PUSHREAL4(orism4f)
        orism4f = dlgspf/(-(1.*orism3f))
        CALL PUSHREAL4(orism5fd)
        orism5fd = -orism4fd
        CALL PUSHREAL4(orism5f)
        orism5f = orism3f - orism4f
        erf5fd = ERFP_D(orism5f, orism5fd, erf5f)
        orism6fd = erf5fd
        orism6f = erf5f
        CALL PUSHREAL4(orism7fd)
        orism7fd = orism6fd
        CALL PUSHREAL4(orism7f)
        orism7f = orism6f + 1.
        orism8fd = 0.5*orism2f*(orism1fd*orism7f+orism1f*orism7fd)
        orism8f = 0.5*orism1f*orism2f*orism7f
        erf4fd = ERFP_D(orism4f, orism4fd, erf4f)
        CALL PUSHREAL4(orism9fd)
        orism9fd = orism8fd + erf4fd
        CALL PUSHREAL4(orism9f)
        orism9f = orism8f + erf4f - 1.
        CALL PUSHREAL4(arg1d)
        arg1d = tp(j)*(SNGL(spard)*orism9f+SNGL(spar)*orism9fd)
        CALL PUSHREAL4(arg1)
        arg1 = tp(j)*SNGL(spar)*orism9f
        integ1fd(j) = -arg1d
        integ1f(j) = -(1.*arg1)
!C
!C *** Calculate number of drops activated by FHH theory
!C
        erf4f = ERFP(orism4f)
        ndf(j) = tp(j)/2.*(1.-erf4f)
!Sum of Integral 1 for FHH
        sumfhhd = sumfhhd + integ1fd(j)
        sumfhh = sumfhh + integ1f(j)
!Sum of ACTIVATED Kohler + FHH particles
        summa = summa + ndf(j)
        CALL PUSHCONTROL2B(1)
      ELSE
        CALL PUSHCONTROL2B(0)
      END IF
    END DO
    bet2b = 0.0
    wparcelb = 0.0
    ssplt1b = 0.0_8
    ssplt2b = 0.0_8
    integ1fdb = 0.0
    integ1b = 0.0
    integ2b = 0.0
    integ1db = 0.0
    integ1fb = 0.0
    ssplt1db = 0.0_8
    integ2db = 0.0
    xfhhb = 0.0
    ssplt2db = 0.0_8
    DO j=nm_drop,1,-1
      CALL POPCONTROL2B(branch)
      IF (branch .NE. 0) THEN
        IF (branch .EQ. 1) THEN
          temp50 = SNGL(spard)
          temp51 = SNGL(spar)
          integ1fb(j) = integ1fb(j) + sumfhhb
          integ1fdb(j) = integ1fdb(j) + sumfhhdb
          arg1b = -integ1fb(j)
          integ1fb(j) = 0.0
          arg1db = -integ1fdb(j)
          integ1fdb(j) = 0.0
          CALL POPREAL4(arg1)
          tempb36 = SNGL(spar)*arg1b
          tpb(j) = tpb(j) + (temp50*orism9f+temp51*orism9fd)*arg1db + &
&           orism9f*tempb36
          orism9fb = tp(j)*temp50*arg1db + tp(j)*tempb36
          CALL POPREAL4(arg1d)
          orism9fdb = tp(j)*temp51*arg1db
          CALL POPREAL4(orism9f)
          orism8fb = orism9fb
          erf4fb = orism9fb
          CALL POPREAL4(orism9fd)
          orism8fdb = orism9fdb
          erf4fdb = orism9fdb
          CALL ERFP_D_B(orism4f, orism4fb, orism4fd, orism4fdb, erf4f, &
&                 erf4fb, erf4fdb)
          tempb37 = 0.5*orism7f*orism8fb
          orism2fb = 0.5*(orism1fd*orism7f+orism1f*orism7fd)*orism8fdb +&
&           orism1f*tempb37
          tempb38 = 0.5*orism2f*orism8fdb
          orism1fb = orism7fd*tempb38 + orism2f*tempb37
          orism7fb = orism1fd*tempb38 + 0.5*orism1f*orism2f*orism8fb
          orism1fdb = orism7f*tempb38
          orism7fdb = orism1f*tempb38
          CALL POPREAL4(orism7f)
          orism6fb = orism7fb
          CALL POPREAL4(orism7fd)
          orism6fdb = orism7fdb
          erf5fb = orism6fb
          erf5fdb = orism6fdb
          CALL ERFP_D_B(orism5f, orism5fb, orism5fd, orism5fdb, erf5f, &
&                 erf5fb, erf5fdb)
          CALL POPREAL4(orism5f)
          orism4fb = orism4fb - orism5fb
          CALL POPREAL4(orism5fd)
          orism4fdb = orism4fdb - orism5fdb
          orism3fb = dlgspf*orism4fb/orism3f**2 + dlgspfd*orism4fdb/&
&           orism3f**2 + orism5fb
          CALL POPREAL4(orism4f)
          dlgspfb = -(orism4fb/orism3f)
          CALL POPREAL4(orism4fd)
          dlgspfdb = -(orism4fdb/orism3f)
          CALL POPREAL4(orism3f)
          CALL POPREAL4(orism2f)
          arg11b = EXP(arg11)*orism2fb
          xfhhb = xfhhb + dlgsgf**2*2.*2*xfhh*arg11b + sqtwo*dlgsgf*&
&           orism3fb
          CALL POPREAL4(arg11)
          CALL POPREAL4(orism1f)
          CALL POPREAL4(orism1fd)
          CALL POPREAL4(dlgspf)
          arg13b = dlgspfb/arg13 - arg13d*dlgspfdb/arg13**2
          CALL POPREAL4(dlgspfd)
          arg13db = dlgspfdb/arg13
          sgb(j) = sgb(j) + arg13b/SNGL(spar) - SNGL(spard)*arg13db/SNGL&
&           (spar)**2 - SNGL(spard*spar+spar*spard)*2*sg(j)*orism1fdb/&
&           SNGL(spar**2)**2 + 2*sg(j)*orism1fb/SNGL(spar**2)
          CALL POPREAL4(arg13)
          CALL POPREAL4(arg13d)
          CALL POPREAL4(dlgsgf)
        ELSE
          integ2b(j) = integ2b(j) + summatb
          integ2db(j) = integ2db(j) + summatdb
          integ1b(j) = integ1b(j) + sumb
          dw3b = sumb
          integ1db(j) = integ1db(j) + sumdb
          dw3db = sumdb
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            temp17 = alfa*bet2*wparcel
            tempb14 = -(EXP(arg11)*dw3db)
            tempb13 = 0.5*temp17**(-0.5)*tp(j)*deq*erf6d*alfa*tempb14
            tempb12 = temp17**0.5*tempb14
            temp18 = alfa*bet2*wparcel
            tempb9 = EXP(arg11)*dw3b
            tempb10 = temp18**0.5*tempb9
            tempb11 = 0.5*temp18**(-0.5)*tp(j)*deq*(1.-erf6)*alfa*tempb9
            tpb(j) = tpb(j) + deq*erf6d*tempb12 + deq*(1.-erf6)*tempb10
            deqb = tp(j)*erf6d*tempb12 + tp(j)*(1.-erf6)*tempb10
            erf6b = -(deq*tp(j)*tempb10)
            bet2b = bet2b + wparcel*tempb13 + wparcel*tempb11
            wparcelb = wparcelb + bet2*tempb13 + bet2*tempb11
            erf6db = tp(j)*deq*tempb12
            CALL POPREAL4(arg11)
            integ1b(j) = 0.0
            integ1db(j) = 0.0
            CALL POPREAL4(erf6)
            CALL POPREAL4(erf6d)
            CALL ERFP_D_B(orism6, orism6b, orism6d, orism6db, erf6, &
&                   erf6b, erf6db)
            CALL POPREAL4(orism6)
            dlgsp2b = sqtwo*orism6b/(3.*dlgsg)
            CALL POPREAL4(orism6d)
            dlgsp2db = sqtwo*orism6db/(3.*dlgsg)
            orism1db = 0.0
            orism1b = 0.0
          ELSE
            temp19 = SNGL(ssplt1d)
            temp22 = SNGL(spard)
            temp25 = SNGL(spar)
            temp24 = sg(j)/temp25
            temp23 = temp24**2.
            temp26 = SNGL(spar)
            temp27 = 2.*SNGL(spard)
            temp28 = SNGL(spar)**3
            temp31 = SNGL(spar)
            temp30 = sg(j)/temp31
            temp29 = temp30**2.
            intaux1p1b = -integ1b(j)
            intaux1p1db = -integ1db(j)
            temp47 = SNGL(spar)
            temp46 = sg(j)/temp47
            temp45 = temp46**2.
            tempb19 = SNGL(spar)*intaux1p1b
            temp44 = SNGL(spar)
            temp43 = sg(j)/temp44
            temp42 = temp43**2.
            temp41 = SNGL(spar)**3
            temp40 = 2.*SNGL(spard)
            temp39 = SNGL(spar)
            temp38 = SNGL(spar)
            temp37 = sg(j)/temp38
            temp36 = temp37**2.
            temp35 = SNGL(spard)
            tempb26 = tp(j)*temp35*intaux1p1db
            tempb23 = -(ekth*0.5*tempb26)
            tempb27 = tp(j)*temp39*intaux1p1db
            tempb25 = -(ekth*0.5*tempb27)
            tempb24 = -(temp40*tempb25/temp41)
            temp48 = alfa*bet2*wparcel
            tempb21 = -(EXP(arg11)*dw3db)
            tempb20 = 0.5*temp48**(-0.5)*tp(j)*deq*erf6d*alfa*tempb21
            tempb18 = temp48**0.5*tempb21
            temp49 = alfa*bet2*wparcel
            tempb15 = EXP(arg11)*dw3b
            tempb16 = temp49**0.5*tempb15
            tempb17 = 0.5*temp49**(-0.5)*tp(j)*deq*(1.-erf6)*alfa*&
&             tempb15
            tpb(j) = tpb(j) + deq*erf6d*tempb18 + (temp35*(1.-ekth*0.5*(&
&             temp36*(1.-erf4))-erf1)+temp39*(-erf1d-ekth*0.5*(-(temp40*&
&             (sg(j)**2*(1.-erf4)/temp41))-temp42*erf4d)))*intaux1p1db +&
&             (1.-ekth*0.5*(temp45*(1.-erf4))-erf1)*tempb19 + deq*(1.-&
&             erf6)*tempb16
            deqb = tp(j)*erf6d*tempb18 + tp(j)*(1.-erf6)*tempb16
            erf6b = -(deq*tp(j)*tempb16)
            bet2b = bet2b + wparcel*tempb20 + wparcel*tempb17
            wparcelb = wparcelb + bet2*tempb20 + bet2*tempb17
            erf6db = tp(j)*deq*tempb18
            CALL POPREAL4(arg11)
            intaux1p2b = integ1b(j)
            integ1b(j) = 0.0
            intaux1p2db = integ1db(j)
            integ1db(j) = 0.0
            tempb22 = -(tp(j)*ekth*0.5*tempb19)
            sgb(j) = sgb(j) + 2.*temp37*(1.-erf4)*tempb23/temp38 + (1.-&
&             erf4)*2*sg(j)*tempb24 - 2.*temp43*erf4d*tempb25/temp44 + &
&             2.*temp46*(1.-erf4)*tempb22/temp47
            erf4b = -(temp36*tempb23) - sg(j)**2*tempb24 - temp45*&
&             tempb22
            erf1b = -tempb26 - tp(j)*tempb19
            erf1db = -tempb27
            erf4db = -(temp42*tempb25)
            CALL POPREAL4(erf6)
            CALL POPREAL4(erf6d)
            CALL ERFP_D_B(orism6, orism6b, orism6d, orism6db, erf6, &
&                   erf6b, erf6db)
            CALL POPREAL4(erf4)
            CALL POPREAL4(erf4d)
            CALL ERFP_D_B(orism4, orism4b, orism4d, orism4db, erf4, &
&                   erf4b, erf4db)
            CALL POPREAL4(erf1)
            CALL POPREAL4(erf1d)
            CALL ERFP_D_B(orism1, orism1b, orism1d, orism1db, erf1, &
&                   erf1b, erf1db)
            CALL POPREAL4(orism6)
            CALL POPREAL4(orism6d)
            CALL POPREAL4(orism4)
            orism1b = orism1b + orism4b
            dlgsp1b = 2.*orism1b/(3.*sqtwo*dlgsg) + sqtwo*orism6b/(3.*&
&             dlgsg)
            CALL POPREAL4(orism4d)
            orism1db = orism1db + orism4db
            dlgsp1db = 2.*orism1db/(3.*sqtwo*dlgsg) + sqtwo*orism6db/(3.&
&             *dlgsg)
            CALL POPREAL4(orism1)
            CALL POPREAL4(orism1d)
            temp34 = SNGL(spar)
            temp33 = sg(j)/temp34
            temp32 = temp33**2.
            tempb28 = SNGL(spar)*intaux1p2b
            tempb29 = -(tp(j)*ekth*0.5*tempb28)
            tpb(j) = tpb(j) + (temp22*(1.-ekth*0.5*(temp23*(1.-erf4))-&
&             erf1)+temp26*(-erf1d-ekth*0.5*(-(temp27*(sg(j)**2*(1.-erf4&
&             )/temp28))-temp29*erf4d)))*intaux1p2db + (1.-ekth*0.5*(&
&             temp32*(1.-erf4))-erf1)*tempb28
            tempb34 = tp(j)*temp22*intaux1p2db
            erf1b = -tempb34 - tp(j)*tempb28
            tempb30 = -(ekth*0.5*tempb34)
            tempb35 = tp(j)*temp26*intaux1p2db
            tempb32 = -(ekth*0.5*tempb35)
            tempb31 = -(temp27*tempb32/temp28)
            erf4b = -(temp23*tempb30) - sg(j)**2*tempb31 - temp32*&
&             tempb29
            erf1db = -tempb35
            erf4db = -(temp29*tempb32)
            arg12b = dlgsp1b/arg12 - arg12d*dlgsp1db/arg12**2
            arg12db = dlgsp1db/arg12
            temp21 = SNGL(ssplt1)
            temp20 = SNGL(ssplt1)
            tempb33 = -(arg12db/temp20**2)
            sgb(j) = sgb(j) + 2.*temp24*(1.-erf4)*tempb30/temp25 + (1.-&
&             erf4)*2*sg(j)*tempb31 - 2.*temp30*erf4d*tempb32/temp31 + &
&             temp19*tempb33 + arg12b/temp21 + 2.*temp33*(1.-erf4)*&
&             tempb29/temp34
            CALL POPREAL4(erf4)
            CALL POPREAL4(erf4d)
            CALL ERFP_D_B(orism4, orism4b, orism4d, orism4db, erf4, &
&                   erf4b, erf4db)
            CALL POPREAL4(erf1)
            CALL POPREAL4(erf1d)
            CALL ERFP_D_B(orism1, orism1b, orism1d, orism1db, erf1, &
&                   erf1b, erf1db)
            CALL POPREAL4(orism4)
            orism1b = orism1b + orism4b
            CALL POPREAL4(orism4d)
            orism1db = orism1db + orism4db
            CALL POPREAL4(arg12)
            ssplt1b = ssplt1b - 2*sg(j)*temp19*tempb33/temp20 - sg(j)*&
&             arg12b/temp21**2
            CALL POPREAL4(arg12d)
            ssplt1db = ssplt1db + sg(j)*tempb33
            CALL POPREAL4(ekth)
            dlgsp2db = 0.0
            dlgsp2b = 0.0
          END IF
          temp13 = SNGL(ssplt2d)
          tempb6 = EXP(arg10)*integ2db(j)
          tempb5 = EXP(arg10)*integ2b(j)
          arg2b = (erf2d-erf3d)*tempb6 + (erf2-erf3)*tempb5
          erf2b = arg2*tempb5
          erf3b = -(arg2*tempb5)
          integ2b(j) = 0.0
          erf2db = arg2*tempb6
          erf3db = -(arg2*tempb6)
          integ2db(j) = 0.0
          CALL POPREAL4(arg2)
          tempb7 = arg2b/sg(j)
          tpb(j) = tpb(j) + tempb7
          CALL POPREAL4(arg10)
          CALL POPREAL4(erf3)
          CALL POPREAL4(erf3d)
          CALL ERFP_D_B(orism3, orism3b, orism3d, orism3db, erf3, erf3b&
&                 , erf3db)
          CALL POPREAL4(erf2)
          CALL POPREAL4(erf2d)
          CALL ERFP_D_B(orism2, orism2b, orism2d, orism2db, erf2, erf2b&
&                 , erf2db)
          CALL POPREAL4(deq)
          temp16 = 3.*result10*sg(j)
          orism5b = orism3b
          orism5db = orism3db
          dlgspb = 2.*orism5b/(3.*sqtwo*dlgsg)
          dlgspdb = 2.*orism5db/(3.*sqtwo*dlgsg)
          orism1b = orism1b + orism2b
          orism1db = orism1db + orism2db
          dlgsp2b = dlgsp2b + 2.*orism1b/(3.*sqtwo*dlgsg)
          dlgsp2db = dlgsp2db + 2.*orism1db/(3.*sqtwo*dlgsg)
          arg1b = dlgsp2b/arg1 - arg1d*dlgsp2db/arg1**2
          arg1db = dlgsp2db/arg1
          temp15 = SNGL(ssplt2)
          temp14 = SNGL(ssplt2)
          tempb8 = -(arg1db/temp14**2)
          ssplt2b = ssplt2b - 2*sg(j)*temp13*tempb8/temp14 - sg(j)*arg1b&
&           /temp15**2
          ssplt2db = ssplt2db + sg(j)*tempb8
          arg13b = dlgspb/arg13 - arg13d*dlgspdb/arg13**2
          arg13db = dlgspdb/arg13
          sgb(j) = sgb(j) + temp13*tempb8 - akoh_drop*2.*3.*result10*&
&           deqb/temp16**2 - SNGL(spard)*arg13db/SNGL(spar)**2 + arg13b/&
&           SNGL(spar) + arg1b/temp15 - tp(j)*tempb7/sg(j)
          CALL POPREAL4(result10)
          CALL POPREAL4(orism3)
          CALL POPREAL4(orism3d)
          CALL POPREAL4(orism2)
          CALL POPREAL4(orism2d)
          CALL POPREAL4(orism1)
          CALL POPREAL4(orism1d)
          CALL POPREAL4(arg1)
          CALL POPREAL4(arg1d)
          CALL POPREAL4(arg13)
          CALL POPREAL4(arg13d)
          CALL POPREAL4(dlgsg)
        END IF
      END IF
    END DO
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      ratiob = spard*ssplt2db + spar*ssplt2b
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) ratiob = 0.0
      pwr2b = -(akoh_drop*2.0e7*ratiob/3.0)
      scritb = -(0.3824*scrit**(-1.3824)*pwr2b)
      CALL POPCONTROL1B(branch)
      temp8 = akoh_drop**2.
      tempb0 = temp8*0.25*(temp8*(alfa*16.*(wparcel/9.*bet2)))**(-0.75)*&
&       alfa*16.*scritb
      wparcelb = wparcelb + bet2*tempb0/9.
      bet2b = bet2b + wparcel*tempb0/9.
      descrdb = 0.0_8
      descrb = 0.0_8
    ELSE
      CALL POPREAL8(ssplt2)
      result1b = spard*ssplt2db + spar*ssplt2b
      CALL POPREAL8(ssplt2d)
      result1db = spar*ssplt2db
      IF (ssplt2 .EQ. 0.0) THEN
        ssplt2b = 0.0
      ELSE
        ssplt2b = result1b/(2.0*SQRT(ssplt2))
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        ssplt2db = 0.0_8
      ELSE
        temp12 = SQRT(ssplt2)
        tempb4 = result1db/(2.0*temp12)
        ssplt2db = tempb4
        IF (.NOT.ssplt2 .EQ. 0.0) ssplt2b = ssplt2b - ssplt2d*tempb4/(&
&           2.0*temp12**2)
      END IF
      CALL POPCONTROL1B(branch)
      CALL POPREAL8(ssplt1)
      result1b = spard*ssplt1db + spar*ssplt1b
      CALL POPREAL8(ssplt1d)
      result1db = spar*ssplt1db
      IF (ssplt1 .EQ. 0.0) THEN
        ssplt1b = 0.0
      ELSE
        ssplt1b = result1b/(2.0*SQRT(ssplt1))
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        temp11 = SQRT(ssplt1)
        tempb3 = result1db/(2.0*temp11)
        ssplt1db = tempb3
        IF (.NOT.ssplt1 .EQ. 0.0) ssplt1b = ssplt1b - ssplt1d*tempb3/(&
&           2.0*temp11**2)
      ELSE
        ssplt1db = 0.0_8
      END IF
      CALL POPCONTROL1B(branch)
      result1b = 0.5d0*ssplt2b
      result1db = 0.5d0*ssplt2db
      IF (descr .EQ. 0.0) THEN
        descrb = 0.0
      ELSE
        descrb = result1b/(2.0*SQRT(descr))
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        temp10 = SQRT(descr)
        tempb2 = result1db/(2.0*temp10)
        descrdb = tempb2
        IF (.NOT.descr .EQ. 0.0) descrb = descrb - descrd*tempb2/(2.0*&
&           temp10**2)
      ELSE
        descrdb = 0.0_8
      END IF
      CALL POPCONTROL1B(branch)
      result1b = -(0.5d0*ssplt1b)
      result1db = -(0.5d0*ssplt1db)
      IF (.NOT.descr .EQ. 0.0) descrb = descrb + result1b/(2.0*SQRT(&
&         descr))
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        temp9 = SQRT(descr)
        tempb1 = result1db/(2.0*temp9)
        descrdb = descrdb + tempb1
        IF (.NOT.descr .EQ. 0.0) descrb = descrb - descrd*tempb1/(2.0*&
&           temp9**2)
      END IF
      CALL POPCONTROL1B(branch)
    END IF
    temp = aa**4
    temp0 = aa**3
    temp1 = aa**4
    temp2 = aa**3
    temp3 = aa**4
    temp4 = aa**3
    arg1b = 2d0**2*spard*spar*16d0*DBLE(akoh_drop)**2*descrdb/(9d0*(spar&
&     **2d0)**3) - 16d0*(DBLE(akoh_drop)/spar**2d0)**2d0*descrb/9d0
    wparcelb = wparcelb + alfa*bet2*arg1b
    bet2b = bet2b + alfa*wparcel*arg1b
    tempb = xfhhb/bb**2
    temp7 = bb**3
    c1b = xfhhb
    c2b = xfhhb/bb
    bbb = bbb + (-(c4*3*bb**2/temp7**2)-c2/bb**2)*xfhhb - c3*2*tempb/bb
    c3b = tempb
    c4b = xfhhb/temp7
    temp6 = aa**3
    temp5 = aa**4
    aab = aab + (-(d35*4*aa**3/temp3**2)-d34*3*aa**2/temp4**2-d33*2/aa**&
&     3-d32/aa**2)*c3b + (-(d15*4*aa**3/temp**2)-d14*3*aa**2/temp0**2-&
&     d13*2/aa**3-d12/aa**2)*c1b + (-(d25*4*aa**3/temp1**2)-d24*3*aa**2/&
&     temp2**2-d23*2/aa**3-d22/aa**2)*c2b + (-(d45*4*aa**3/temp5**2)-d44&
&     *3*aa**2/temp6**2-d43*2/aa**3-d42/aa**2)*c4b
  END SUBROUTINE SINTEGRAL_D_B
!  Differentiation of sintegral in forward (tangent) mode:
!   variations   of useful results: summat sum sumfhh
!   with respect to varying inputs: spar
!=======================================================================
!
! *** SUBROUTINE SINTEGRAL
! *** THIS SUBROUTINE CALCULATES THE CONDENSATION INTEGRALS, ACCORDING
!     TO THE POPULATION SPLITTING ALGORITHM AND THE SUBSEQUENT VERSIONS:
!
!       - Nenes and Seinfeld (2003)       Population Splitting
!       - Fountoukis and Nenes (2004)     Modal formulation
!       - Barahona and Nenes (2010)       Approach for large CCN
!       - Morales and Nenes (2014)        Population Splitting revised
!
! *** WRITTEN BY ATHANASIOS NENES for Kohler Particles
! *** MODFIFIED BY PRASHANT KUMAR AND ATHANASIOS NENES TO INCLUDE FHH
!     PARTICLES
!=======================================================================
  SUBROUTINE SINTEGRAL_D(spar, spard, summa, sum, sumd, summat, summatd&
&   , bet2, alfa, sig, tp, sg, wparcel, sumfhh, sumfhhd, modei, aa, bb)
    IMPLICIT NONE
    REAL :: sum, summat, summa, nd(nm_drop), sumfhh, integ1(nm_drop), &
&   integ2(nm_drop), integ1f(nm_drop), ndf(nm_drop)
    REAL :: sumd, summatd, sumfhhd, integ1d(nm_drop), integ2d(nm_drop), &
&   integ1fd(nm_drop)
    REAL, INTENT(IN) :: aa, bb
    REAL :: c1, c2, c3, c4, xfhh
    REAL :: wparcel, tp(nm_drop), sg(nm_drop), bet2, sig(nm_drop)
    REAL :: erf1, erf2, erf3, erf4, erf5, erf6, erf4f, erf5f
    REAL :: erf1d, erf2d, erf3d, erf4d, erf6d, erf4fd, erf5fd
    REAL :: orism1, orism2, orism3, orism4, orism5, orism6
    REAL :: orism1d, orism2d, orism3d, orism4d, orism5d, orism6d
    REAL :: scrit, deq, dw3
    REAL :: dw3d
    REAL :: orism1f, orism2f, orism3f, orism4f, orism5f, orism6f, &
&   orism7f
    REAL :: orism1fd, orism4fd, orism5fd, orism6fd, orism7fd
    REAL :: orism8f, orism9f
    REAL :: orism8fd, orism9fd
    LOGICAL :: crit2
!Sylvia
    REAL :: alfa, ratio
    REAL :: ratiod
    REAL*8 :: descr, ssplt1, ssplt2, spar
    REAL*8 :: descrd, ssplt1d, ssplt2d, spard
    REAL :: ekth, xl, z, p1, p2
    REAL :: dlgsgf, dlgspf
    REAL :: dlgspfd
    REAL :: sqtwo, dlgsg, dlgsp, dlgsp2, dlgsp1, intaux1p2, intaux1p1
    REAL :: dlgspd, dlgsp2d, dlgsp1d, intaux1p2d, intaux1p1d
    INTEGER :: j, i, modei(nm_drop)
    INTRINSIC SQRT
    INTRINSIC DBLE
    INTRINSIC LOG
    INTRINSIC SNGL
    INTRINSIC EXP
    REAL :: arg1
    REAL :: arg1d
    REAL :: pwr1
    REAL :: pwr1d
    REAL :: pwr2
    REAL*8 :: result1
    REAL*8 :: result1d
    REAL :: result10
    REAL :: arg10
    REAL :: arg2
    REAL :: arg11
    REAL :: arg12
    REAL :: arg12d
    REAL*8 :: pwr10
    REAL*8 :: pwr10d
    REAL :: arg13
    REAL :: arg13d
    INTRINSIC ABS
    REAL*8 :: abs3
    REAL*8 :: abs2
    REAL*8 :: abs1
    REAL*8 :: abs0
!
! *** Here is where the criterion with the descriminant is put. When it
!     is < 0, then set CRIT2 = .TRUE. Otherwise, set the two values of
!     SSPLT and continue.
!C ** Population Splitting -- Modified by Ricardo Morales 2013
    c1 = d11 + d12/aa + d13/(aa*aa) + d14/(aa*aa*aa) + d15/(aa*aa*aa*aa)
    c2 = d21 + d22/aa + d23/(aa*aa) + d24/(aa*aa*aa) + d25/(aa*aa*aa*aa)
    c3 = d31 + d32/aa + d33/(aa*aa) + d34/(aa*aa*aa) + d35/(aa*aa*aa*aa)
    c4 = d41 + d42/aa + d43/(aa*aa) + d44/(aa*aa*aa) + d45/(aa*aa*aa*aa)
    xfhh = c1 + c2/bb + c3/(bb*bb) + c4/(bb*bb*bb)
    sqtwo = SQRT(2.)
    arg1 = alfa*wparcel*bet2
    descrd = 16d0*DBLE(arg1)*2d0**2*DBLE(akoh_drop)**2*spar*spard/(9d0*(&
&     spar**2d0)**3)
    descr = 1d0 - 16d0/9d0*DBLE(arg1)*(DBLE(akoh_drop)/spar**2d0)**2d0
    IF (descr .LE. 0d0) THEN
      crit2 = .true.
! Scrit - (only for DELTA < 0 )
      scrit = (16./9.*alfa*wparcel*bet2*akoh_drop**2.)**0.25
! Computing sp1 and sp2 (sp1 = sp2)
      IF (spar .GT. 0.0) THEN
        pwr10d = -(0.3824d0*spar**(-1.3824d0)*spard)
      ELSE
        pwr10d = 0.0
      END IF
      pwr10 = spar**(-0.3824d0)
      pwr1d = SNGL(pwr10d)
      pwr1 = SNGL(pwr10)
      pwr2 = scrit**(-0.3824)
      ratiod = 2.0e7*akoh_drop*pwr1d/3.0
      ratio = 2.0e7/3.0*akoh_drop*(pwr1-pwr2)
      ratio = 1./sqtwo + ratio
      IF (ratio .GT. 1.0) THEN
        ratio = 1.0
        ratiod = 0.0
      END IF
      ssplt2d = spard*DBLE(ratio) + spar*ratiod
      ssplt2 = spar*DBLE(ratio)
      ssplt1d = 0.0_8
    ELSE
      crit2 = .false.
      IF (descr .GE. 0.) THEN
        abs0 = descr
      ELSE
        abs0 = -descr
      END IF
! min root of both
      IF (abs0 .LE. 1d-10) THEN
        result1d = 0.0_8
      ELSE
        result1d = descrd/(2.0*SQRT(descr))
      END IF
      result1 = SQRT(descr)
      ssplt1d = -(0.5d0*result1d)
      ssplt1 = 0.5d0*(1.d0-result1)
      IF (descr .GE. 0.) THEN
        abs1 = descr
      ELSE
        abs1 = -descr
      END IF
! max root of both
      IF (abs1 .LE. 1d-10) THEN
        result1d = 0.0_8
      ELSE
        result1d = descrd/(2.0*SQRT(descr))
      END IF
      result1 = SQRT(descr)
      ssplt2d = 0.5d0*result1d
      ssplt2 = 0.5d0*(1.d0+result1)
      IF (ssplt1 .GE. 0.) THEN
        abs2 = ssplt1
      ELSE
        abs2 = -ssplt1
      END IF
! Multiply ratios with Smax
      IF (abs2 .LE. 1d-10) THEN
        result1d = 0.0_8
      ELSE
        result1d = ssplt1d/(2.0*SQRT(ssplt1))
      END IF
      result1 = SQRT(ssplt1)
      ssplt1d = result1d*spar + result1*spard
      ssplt1 = result1*spar
      IF (ssplt2 .GE. 0.) THEN
        abs3 = ssplt2
      ELSE
        abs3 = -ssplt2
      END IF
      IF (abs3 .LE. 1d-10) THEN
        result1d = 0.0_8
      ELSE
        result1d = ssplt2d/(2.0*SQRT(ssplt2))
      END IF
      result1 = SQRT(ssplt2)
      ssplt2d = result1d*spar + result1*spard
      ssplt2 = result1*spar
    END IF
! *** Computing the condensation integrals I1 and I2
!
!Contribution of integral 1 for Kohler 
    sum = 0.0
!Contribution of integral 2 for kohler
    summat = 0.0
!Variable that stores all droplets
    summa = 0.0
!Contribution of FHH integral
    sumfhh = 0.0
    summatd = 0.0
    sumd = 0.0
    sumfhhd = 0.0
    integ1d = 0.0
    integ2d = 0.0
    integ1fd = 0.0
    DO j=1,nm_drop
      IF (modei(j) .EQ. 1) THEN
! Koehler modes
!ln(sigmai)
        dlgsg = LOG(sig(j))
!ln(sg/smax)
        arg13d = -(sg(j)*SNGL(spard)/SNGL(spar)**2)
        arg13 = sg(j)/SNGL(spar)
        dlgspd = arg13d/arg13
        dlgsp = LOG(arg13)
!RM: ln(sg/sp2)
        arg1d = -(sg(j)*SNGL(ssplt2d)/SNGL(ssplt2)**2)
        arg1 = sg(j)/SNGL(ssplt2)
        dlgsp2d = arg1d/arg1
        dlgsp2 = LOG(arg1)
! u(sp2)
        orism1d = 2.*dlgsp2d/(3.*sqtwo*dlgsg)
        orism1 = 2.*dlgsp2/(3.*sqtwo*dlgsg)
! u(sp2)-3ln(sigmai)/(2sqrt(2)
        orism2d = orism1d
        orism2 = orism1 - 3.*dlgsg/(2.*sqtwo)
! RM: u(smax)
        orism5d = 2.*dlgspd/(3.*sqtwo*dlgsg)
        orism5 = 2.*dlgsp/(3.*sqtwo*dlgsg)
! u(smax)-3ln(sigmai)/(2sqrt(2)
        orism3d = orism5d
        orism3 = orism5 - 3.*dlgsg/(2.*sqtwo)
! RM: Dp0 = Dpc/sqrt(3) - Equilibrium diameter
        result10 = SQRT(3.)
        deq = akoh_drop*2./sg(j)/3./result10
        erf2d = ERFP_D(orism2, orism2d, erf2)
        erf3d = ERFP_D(orism3, orism3d, erf3)
        arg10 = 9./8.*dlgsg*dlgsg
        arg2 = tp(j)/sg(j)
        integ2d(j) = EXP(arg10)*arg2*(erf2d-erf3d)
        integ2(j) = EXP(arg10)*arg2*(erf2-erf3)
! I2(sp2,smax)
        IF (crit2) THEN
          orism6d = sqtwo*dlgsp2d/3./dlgsg
          orism6 = sqtwo*dlgsp2/3./dlgsg - 1.5*dlgsg/sqtwo
          erf6d = ERFP_D(orism6, orism6d, erf6)
          integ1d(j) = 0.0
          integ1(j) = 0.0
! 'inertially' limited particles
          arg11 = 9./8.*dlgsg*dlgsg
          dw3d = -(tp(j)*deq*EXP(arg11)*(bet2*alfa*wparcel)**0.5*erf6d)
          dw3 = tp(j)*deq*EXP(arg11)*(1.-erf6)*(bet2*alfa*wparcel)**0.5
        ELSE
          ekth = EXP(9./2.*dlgsg*dlgsg)
! RM: ln(sg/sp1)
          arg12d = -(sg(j)*SNGL(ssplt1d)/SNGL(ssplt1)**2)
          arg12 = sg(j)/SNGL(ssplt1)
          dlgsp1d = arg12d/arg12
          dlgsp1 = LOG(arg12)
! u(sp2) + 3ln(sigmai)/sqrt(2)
          orism4d = orism1d
          orism4 = orism1 + 3.*dlgsg/sqtwo
          erf1d = ERFP_D(orism1, orism1d, erf1)
          erf4d = ERFP_D(orism4, orism4d, erf4)
! I1(0,sp2)
          intaux1p2d = tp(j)*(SNGL(spard)*(1.-erf1-0.5*(sg(j)/SNGL(spar)&
&           )**2.*ekth*(1.-erf4))+SNGL(spar)*(-erf1d-0.5*ekth*(-(2.*sg(j&
&           )**2*SNGL(spard)*(1.-erf4)/SNGL(spar)**3)-(sg(j)/SNGL(spar))&
&           **2.*erf4d)))
          intaux1p2 = tp(j)*SNGL(spar)*(1.-erf1-0.5*(sg(j)/SNGL(spar))**&
&           2.*ekth*(1.-erf4))
! u(sp1) 
          orism1d = 2.*dlgsp1d/(3.*sqtwo*dlgsg)
          orism1 = 2.*dlgsp1/(3.*sqtwo*dlgsg)
! u(sp1) + 3ln(sigmai)/sqrt(2)
          orism4d = orism1d
          orism4 = orism1 + 3.*dlgsg/sqtwo
          orism6d = sqtwo*dlgsp1d/3./dlgsg
          orism6 = sqtwo*dlgsp1/3./dlgsg - 1.5*dlgsg/sqtwo
          erf1d = ERFP_D(orism1, orism1d, erf1)
          erf4d = ERFP_D(orism4, orism4d, erf4)
          erf6d = ERFP_D(orism6, orism6d, erf6)
! I1(0,sp1)
          intaux1p1d = tp(j)*(SNGL(spard)*(1.-erf1-0.5*(sg(j)/SNGL(spar)&
&           )**2.*ekth*(1.-erf4))+SNGL(spar)*(-erf1d-0.5*ekth*(-(2.*sg(j&
&           )**2*SNGL(spard)*(1.-erf4)/SNGL(spar)**3)-(sg(j)/SNGL(spar))&
&           **2.*erf4d)))
          intaux1p1 = tp(j)*SNGL(spar)*(1.-erf1-0.5*(sg(j)/SNGL(spar))**&
&           2.*ekth*(1.-erf4))
! I1(sp1,sp2) = I1(0,sp2) - I1(0,sp1)
          integ1d(j) = intaux1p2d - intaux1p1d
          integ1(j) = intaux1p2 - intaux1p1
! 'inertially' limited particles.
          arg11 = 9./8.*dlgsg*dlgsg
          dw3d = -(tp(j)*deq*EXP(arg11)*(bet2*alfa*wparcel)**0.5*erf6d)
          dw3 = tp(j)*deq*EXP(arg11)*(1.-erf6)*(bet2*alfa*wparcel)**0.5
        END IF
!C *** Calculate number of Drops
        erf5 = ERFP(orism5)
        nd(j) = tp(j)/2.*(1.-erf5)
!SUM OF INTEGRAL 1 FOR KOHLER
        sumd = sumd + integ1d(j) + dw3d
        sum = sum + integ1(j) + dw3
!SUM OF INTEGRAL 2 FOR KOHLER
        summatd = summatd + integ2d(j)
        summat = summat + integ2(j)
!SUM OF ACTIVATED KOHLER PARTICLES
        summa = summa + nd(j)
      ELSE IF (modei(j) .EQ. 2) THEN
! FHH modes
! ln(sigma,i)
        dlgsgf = LOG(sig(j))
! ln(sg/smax)
        arg13d = -(sg(j)*SNGL(spard)/SNGL(spar)**2)
        arg13 = sg(j)/SNGL(spar)
        dlgspfd = arg13d/arg13
        dlgspf = LOG(arg13)
! (sg/smax)^2
        orism1fd = -(sg(j)**2*SNGL(spard*spar+spar*spard)/SNGL(spar*spar&
&         )**2)
        orism1f = sg(j)*sg(j)/SNGL(spar*spar)
! exp(term)
        arg11 = 2.*xfhh*xfhh*dlgsgf*dlgsgf
        orism2f = EXP(arg11)
! sqrt(2).x.ln(sigma,i)
        orism3f = sqtwo*xfhh*dlgsgf
! Umax
        orism4fd = dlgspfd/(-(1.*orism3f))
        orism4f = dlgspf/(-(1.*orism3f))
        orism5fd = -orism4fd
        orism5f = orism3f - orism4f
        erf5fd = ERFP_D(orism5f, orism5fd, erf5f)
        orism6fd = erf5fd
        orism6f = erf5f
        orism7fd = orism6fd
        orism7f = orism6f + 1.
        orism8fd = 0.5*orism2f*(orism1fd*orism7f+orism1f*orism7fd)
        orism8f = 0.5*orism1f*orism2f*orism7f
        erf4fd = ERFP_D(orism4f, orism4fd, erf4f)
        orism9fd = orism8fd + erf4fd
        orism9f = orism8f + erf4f - 1.
        arg1d = tp(j)*(SNGL(spard)*orism9f+SNGL(spar)*orism9fd)
        arg1 = tp(j)*SNGL(spar)*orism9f
        integ1fd(j) = -arg1d
        integ1f(j) = -(1.*arg1)
!C
!C *** Calculate number of drops activated by FHH theory
!C
        erf4f = ERFP(orism4f)
        ndf(j) = tp(j)/2.*(1.-erf4f)
!Sum of Integral 1 for FHH
        sumfhhd = sumfhhd + integ1fd(j)
        sumfhh = sumfhh + integ1f(j)
!Sum of ACTIVATED Kohler + FHH particles
        summa = summa + ndf(j)
      END IF
    END DO
    RETURN
  END SUBROUTINE SINTEGRAL_D
!  Differentiation of sintegral in reverse (adjoint) mode (with options no!SliceDeadControl no!SliceDeadInstrs no!tryRecomputatio
!ns):
!   gradient     of useful results: summa
!   with respect to varying inputs: aa tp spar bb sg
!=======================================================================
!
! *** SUBROUTINE SINTEGRAL
! *** THIS SUBROUTINE CALCULATES THE CONDENSATION INTEGRALS, ACCORDING
!     TO THE POPULATION SPLITTING ALGORITHM AND THE SUBSEQUENT VERSIONS:
!
!       - Nenes and Seinfeld (2003)       Population Splitting
!       - Fountoukis and Nenes (2004)     Modal formulation
!       - Barahona and Nenes (2010)       Approach for large CCN
!       - Morales and Nenes (2014)        Population Splitting revised
!
! *** WRITTEN BY ATHANASIOS NENES for Kohler Particles
! *** MODFIFIED BY PRASHANT KUMAR AND ATHANASIOS NENES TO INCLUDE FHH
!     PARTICLES
!=======================================================================
  SUBROUTINE SINTEGRAL_B(spar, sparb, summa, summab, sum, summat, bet2, &
&   alfa, sig, tp, tpb, sg, sgb, wparcel, sumfhh, modei, aa, aab, bb, &
&   bbb)
    IMPLICIT NONE
    REAL :: sum, summat, summa, nd(nm_drop), sumfhh, integ1(nm_drop), &
&   integ2(nm_drop), integ1f(nm_drop), ndf(nm_drop)
    REAL :: summab, ndb(nm_drop), ndfb(nm_drop)
    REAL, INTENT(IN) :: aa, bb
    REAL :: aab, bbb
    REAL :: c1, c2, c3, c4, xfhh
    REAL :: c1b, c2b, c3b, c4b, xfhhb
    REAL :: wparcel, tp(nm_drop), sg(nm_drop), bet2, sig(nm_drop)
    REAL :: tpb(nm_drop), sgb(nm_drop)
    REAL :: erf1, erf2, erf3, erf4, erf5, erf6, erf4f, erf5f
    REAL :: erf5b, erf4fb
    REAL :: orism1, orism2, orism3, orism4, orism5, orism6
    REAL :: orism5b
    REAL :: scrit, deq, dw3
    REAL :: orism1f, orism2f, orism3f, orism4f, orism5f, orism6f, &
&   orism7f
    REAL :: orism3fb, orism4fb
    REAL :: orism8f, orism9f
    LOGICAL :: crit2
!Sylvia
    REAL :: alfa, ratio
    REAL*8 :: descr, ssplt1, ssplt2, spar
    REAL*8 :: sparb
    REAL :: ekth, xl, z, p1, p2
    REAL :: dlgsgf, dlgspf
    REAL :: dlgspfb
    REAL :: sqtwo, dlgsg, dlgsp, dlgsp2, dlgsp1, intaux1p2, intaux1p1
    REAL :: dlgspb
    INTEGER :: j, i, modei(nm_drop)
    INTRINSIC SQRT
    INTRINSIC DBLE
    INTRINSIC LOG
    INTRINSIC SNGL
    INTRINSIC EXP
    REAL :: arg1
    REAL :: pwr1
    REAL :: pwr2
    REAL*8 :: result1
    REAL :: result10
    REAL :: arg10
    REAL :: arg2
    REAL :: arg11
    REAL :: arg12
    REAL*8 :: pwr10
    REAL :: arg13
    REAL :: arg13b
    INTEGER :: branch
    REAL :: temp3
    REAL :: temp2
    REAL :: temp1
    REAL :: temp0
    REAL :: temp15
    REAL :: temp14
    REAL :: temp13
    REAL :: temp12
    REAL :: temp11
    REAL :: temp10
    REAL :: tempb
    REAL :: temp
    REAL :: temp9
    REAL :: temp8
    REAL :: temp7
    REAL :: temp6
    REAL :: temp5
    REAL :: temp4
!
! *** Here is where the criterion with the descriminant is put. When it
!     is < 0, then set CRIT2 = .TRUE. Otherwise, set the two values of
!     SSPLT and continue.
!C ** Population Splitting -- Modified by Ricardo Morales 2013
    c1 = d11 + d12/aa + d13/(aa*aa) + d14/(aa*aa*aa) + d15/(aa*aa*aa*aa)
    c2 = d21 + d22/aa + d23/(aa*aa) + d24/(aa*aa*aa) + d25/(aa*aa*aa*aa)
    c3 = d31 + d32/aa + d33/(aa*aa) + d34/(aa*aa*aa) + d35/(aa*aa*aa*aa)
    c4 = d41 + d42/aa + d43/(aa*aa) + d44/(aa*aa*aa) + d45/(aa*aa*aa*aa)
    xfhh = c1 + c2/bb + c3/(bb*bb) + c4/(bb*bb*bb)
    sqtwo = SQRT(2.)
    arg1 = alfa*wparcel*bet2
    descr = 1d0 - 16d0/9d0*DBLE(arg1)*(DBLE(akoh_drop)/spar**2d0)**2d0
    IF (descr .LE. 0d0) THEN
      crit2 = .true.
! Scrit - (only for DELTA < 0 )
      scrit = (16./9.*alfa*wparcel*bet2*akoh_drop**2.)**0.25
! Computing sp1 and sp2 (sp1 = sp2)
      pwr10 = spar**(-0.3824d0)
      pwr1 = SNGL(pwr10)
      pwr2 = scrit**(-0.3824)
      ratio = 2.0e7/3.0*akoh_drop*(pwr1-pwr2)
      ratio = 1./sqtwo + ratio
      IF (ratio .GT. 1.0) THEN
        ratio = 1.0
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      ssplt2 = spar*DBLE(ratio)
      CALL PUSHCONTROL1B(0)
    ELSE
      crit2 = .false.
! min root of both
      result1 = SQRT(descr)
      ssplt1 = 0.5d0*(1.d0-result1)
! max root of both
      result1 = SQRT(descr)
      ssplt2 = 0.5d0*(1.d0+result1)
! Multiply ratios with Smax
      result1 = SQRT(ssplt1)
      ssplt1 = result1*spar
      result1 = SQRT(ssplt2)
      ssplt2 = result1*spar
      CALL PUSHCONTROL1B(1)
    END IF
! *** Computing the condensation integrals I1 and I2
!
!Contribution of integral 1 for Kohler 
    sum = 0.0
!Contribution of integral 2 for kohler
    summat = 0.0
!Variable that stores all droplets
    summa = 0.0
!Contribution of FHH integral
    sumfhh = 0.0
    DO j=1,nm_drop
      IF (modei(j) .EQ. 1) THEN
! Koehler modes
!ln(sigmai)
        CALL PUSHREAL4(dlgsg)
        dlgsg = LOG(sig(j))
!ln(sg/smax)
        CALL PUSHREAL4(arg13)
        arg13 = sg(j)/SNGL(spar)
        dlgsp = LOG(arg13)
!RM: ln(sg/sp2)
        arg1 = sg(j)/SNGL(ssplt2)
        dlgsp2 = LOG(arg1)
! u(sp2)
        orism1 = 2.*dlgsp2/(3.*sqtwo*dlgsg)
! u(sp2)-3ln(sigmai)/(2sqrt(2)
        orism2 = orism1 - 3.*dlgsg/(2.*sqtwo)
! RM: u(smax)
        CALL PUSHREAL4(orism5)
        orism5 = 2.*dlgsp/(3.*sqtwo*dlgsg)
! u(smax)-3ln(sigmai)/(2sqrt(2)
        orism3 = orism5 - 3.*dlgsg/(2.*sqtwo)
! RM: Dp0 = Dpc/sqrt(3) - Equilibrium diameter
        result10 = SQRT(3.)
        deq = akoh_drop*2./sg(j)/3./result10
        erf2 = ERFP(orism2)
        erf3 = ERFP(orism3)
        arg10 = 9./8.*dlgsg*dlgsg
        arg2 = tp(j)/sg(j)
        integ2(j) = EXP(arg10)*arg2*(erf2-erf3)
! I2(sp2,smax)
        IF (crit2) THEN
          orism6 = sqtwo*dlgsp2/3./dlgsg - 1.5*dlgsg/sqtwo
          erf6 = ERFP(orism6)
          integ1(j) = 0.0
! 'inertially' limited particles
          arg11 = 9./8.*dlgsg*dlgsg
          dw3 = tp(j)*deq*EXP(arg11)*(1.-erf6)*(bet2*alfa*wparcel)**0.5
          CALL PUSHCONTROL1B(0)
        ELSE
          ekth = EXP(9./2.*dlgsg*dlgsg)
! RM: ln(sg/sp1)
          arg12 = sg(j)/SNGL(ssplt1)
          dlgsp1 = LOG(arg12)
! u(sp2) + 3ln(sigmai)/sqrt(2)
          orism4 = orism1 + 3.*dlgsg/sqtwo
          erf1 = ERFP(orism1)
          erf4 = ERFP(orism4)
! I1(0,sp2)
          intaux1p2 = tp(j)*SNGL(spar)*(1.-erf1-0.5*(sg(j)/SNGL(spar))**&
&           2.*ekth*(1.-erf4))
! u(sp1) 
          orism1 = 2.*dlgsp1/(3.*sqtwo*dlgsg)
! u(sp1) + 3ln(sigmai)/sqrt(2)
          orism4 = orism1 + 3.*dlgsg/sqtwo
          orism6 = sqtwo*dlgsp1/3./dlgsg - 1.5*dlgsg/sqtwo
          erf1 = ERFP(orism1)
          erf4 = ERFP(orism4)
          erf6 = ERFP(orism6)
! I1(0,sp1)
          intaux1p1 = tp(j)*SNGL(spar)*(1.-erf1-0.5*(sg(j)/SNGL(spar))**&
&           2.*ekth*(1.-erf4))
! I1(sp1,sp2) = I1(0,sp2) - I1(0,sp1)
          integ1(j) = intaux1p2 - intaux1p1
! 'inertially' limited particles.
          arg11 = 9./8.*dlgsg*dlgsg
          dw3 = tp(j)*deq*EXP(arg11)*(1.-erf6)*(bet2*alfa*wparcel)**0.5
          CALL PUSHCONTROL1B(1)
        END IF
!C *** Calculate number of Drops
        CALL PUSHREAL4(erf5)
        erf5 = ERFP(orism5)
        nd(j) = tp(j)/2.*(1.-erf5)
!SUM OF INTEGRAL 1 FOR KOHLER
        sum = sum + integ1(j) + dw3
!SUM OF INTEGRAL 2 FOR KOHLER
        summat = summat + integ2(j)
!SUM OF ACTIVATED KOHLER PARTICLES
        summa = summa + nd(j)
        CALL PUSHCONTROL2B(2)
      ELSE IF (modei(j) .EQ. 2) THEN
! FHH modes
! ln(sigma,i)
        CALL PUSHREAL4(dlgsgf)
        dlgsgf = LOG(sig(j))
! ln(sg/smax)
        CALL PUSHREAL4(arg13)
        arg13 = sg(j)/SNGL(spar)
        CALL PUSHREAL4(dlgspf)
        dlgspf = LOG(arg13)
! (sg/smax)^2
        orism1f = sg(j)*sg(j)/SNGL(spar*spar)
! exp(term)
        arg11 = 2.*xfhh*xfhh*dlgsgf*dlgsgf
        orism2f = EXP(arg11)
! sqrt(2).x.ln(sigma,i)
        CALL PUSHREAL4(orism3f)
        orism3f = sqtwo*xfhh*dlgsgf
! Umax
        CALL PUSHREAL4(orism4f)
        orism4f = dlgspf/(-(1.*orism3f))
        orism5f = orism3f - orism4f
        erf5f = ERFP(orism5f)
        orism6f = erf5f
        orism7f = orism6f + 1.
        orism8f = 0.5*orism1f*orism2f*orism7f
        CALL PUSHREAL4(erf4f)
        erf4f = ERFP(orism4f)
        orism9f = orism8f + erf4f - 1.
        arg1 = tp(j)*SNGL(spar)*orism9f
        integ1f(j) = -(1.*arg1)
!C
!C *** Calculate number of drops activated by FHH theory
!C
        erf4f = ERFP(orism4f)
        ndf(j) = tp(j)/2.*(1.-erf4f)
!Sum of Integral 1 for FHH
        sumfhh = sumfhh + integ1f(j)
!Sum of ACTIVATED Kohler + FHH particles
        summa = summa + ndf(j)
        CALL PUSHCONTROL2B(1)
      ELSE
        CALL PUSHCONTROL2B(0)
      END IF
    END DO
    tpb = 0.0
    sparb = 0.0_8
    sgb = 0.0
    ndb = 0.0
    ndfb = 0.0
    xfhhb = 0.0
    DO j=nm_drop,1,-1
      CALL POPCONTROL2B(branch)
      IF (branch .NE. 0) THEN
        IF (branch .EQ. 1) THEN
          ndfb(j) = ndfb(j) + summab
          tpb(j) = tpb(j) + (1.-erf4f)*ndfb(j)/2.
          erf4fb = -(tp(j)*ndfb(j)/2.)
          ndfb(j) = 0.0
          CALL ERFP_B(orism4f, orism4fb, erf4fb)
          CALL POPREAL4(erf4f)
          CALL POPREAL4(orism4f)
          dlgspfb = -(orism4fb/orism3f)
          orism3fb = dlgspf*orism4fb/orism3f**2
          CALL POPREAL4(orism3f)
          xfhhb = xfhhb + sqtwo*dlgsgf*orism3fb
          CALL POPREAL4(dlgspf)
          arg13b = dlgspfb/arg13
          CALL POPREAL4(arg13)
          temp15 = SNGL(spar)
          sgb(j) = sgb(j) + arg13b/temp15
          sparb = sparb - sg(j)*arg13b/temp15**2
          CALL POPREAL4(dlgsgf)
        ELSE
          ndb(j) = ndb(j) + summab
          tpb(j) = tpb(j) + (1.-erf5)*ndb(j)/2.
          erf5b = -(tp(j)*ndb(j)/2.)
          ndb(j) = 0.0
          CALL POPREAL4(erf5)
          CALL ERFP_B(orism5, orism5b, erf5b)
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) THEN
            temp14 = SNGL(spar)
            temp13 = sg(j)/temp14
            temp12 = 0.5*ekth*(-erf4+1.)
            temp11 = SNGL(spar)
            temp10 = sg(j)/temp11
            temp9 = 0.5*ekth*(-erf4+1.)
          END IF
          CALL POPREAL4(orism5)
          dlgspb = 2.*orism5b/(3.*sqtwo*dlgsg)
          arg13b = dlgspb/arg13
          CALL POPREAL4(arg13)
          temp8 = SNGL(spar)
          sgb(j) = sgb(j) + arg13b/temp8
          sparb = sparb - sg(j)*arg13b/temp8**2
          CALL POPREAL4(dlgsg)
        END IF
      END IF
    END DO
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) CALL POPCONTROL1B(branch)
    temp = aa**4
    temp0 = aa**3
    temp1 = aa**4
    temp2 = aa**3
    temp3 = aa**4
    temp4 = aa**3
    tempb = xfhhb/bb**2
    temp7 = bb**3
    c1b = xfhhb
    c2b = xfhhb/bb
    bbb = (-(c4*3*bb**2/temp7**2)-c2/bb**2)*xfhhb - c3*2*tempb/bb
    c3b = tempb
    c4b = xfhhb/temp7
    temp6 = aa**3
    temp5 = aa**4
    aab = (-(d35*4*aa**3/temp3**2)-d34*3*aa**2/temp4**2-d33*2/aa**3-d32/&
&     aa**2)*c3b + (-(d15*4*aa**3/temp**2)-d14*3*aa**2/temp0**2-d13*2/aa&
&     **3-d12/aa**2)*c1b + (-(d25*4*aa**3/temp1**2)-d24*3*aa**2/temp2**2&
&     -d23*2/aa**3-d22/aa**2)*c2b + (-(d45*4*aa**3/temp5**2)-d44*3*aa**2&
&     /temp6**2-d43*2/aa**3-d42/aa**2)*c4b
  END SUBROUTINE SINTEGRAL_B
!=======================================================================
!
! *** SUBROUTINE SINTEGRAL
! *** THIS SUBROUTINE CALCULATES THE CONDENSATION INTEGRALS, ACCORDING
!     TO THE POPULATION SPLITTING ALGORITHM AND THE SUBSEQUENT VERSIONS:
!
!       - Nenes and Seinfeld (2003)       Population Splitting
!       - Fountoukis and Nenes (2004)     Modal formulation
!       - Barahona and Nenes (2010)       Approach for large CCN
!       - Morales and Nenes (2014)        Population Splitting revised
!
! *** WRITTEN BY ATHANASIOS NENES for Kohler Particles
! *** MODFIFIED BY PRASHANT KUMAR AND ATHANASIOS NENES TO INCLUDE FHH
!     PARTICLES
!=======================================================================
  SUBROUTINE SINTEGRAL(spar, summa, sum, summat, bet2, alfa, sig, tp, sg&
&   , wparcel, sumfhh, modei, aa, bb)
    IMPLICIT NONE
    REAL :: sum, summat, summa, nd(nm_drop), sumfhh, integ1(nm_drop), &
&   integ2(nm_drop), integ1f(nm_drop), ndf(nm_drop)
    REAL, INTENT(IN) :: aa, bb
    REAL :: c1, c2, c3, c4, xfhh
    REAL :: wparcel, tp(nm_drop), sg(nm_drop), bet2, sig(nm_drop)
    REAL :: erf1, erf2, erf3, erf4, erf5, erf6, erf4f, erf5f
    REAL :: orism1, orism2, orism3, orism4, orism5, orism6
    REAL :: scrit, deq, dw3
    REAL :: orism1f, orism2f, orism3f, orism4f, orism5f, orism6f, &
&   orism7f
    REAL :: orism8f, orism9f
    LOGICAL :: crit2
!Sylvia
    REAL :: alfa, ratio
    REAL*8 :: descr, ssplt1, ssplt2, spar
    REAL :: ekth, xl, z, p1, p2
    REAL :: dlgsgf, dlgspf
    REAL :: sqtwo, dlgsg, dlgsp, dlgsp2, dlgsp1, intaux1p2, intaux1p1
    INTEGER :: j, i, modei(nm_drop)
    INTRINSIC SQRT
    INTRINSIC DBLE
    INTRINSIC LOG
    INTRINSIC SNGL
    INTRINSIC EXP
    REAL :: arg1
    REAL :: pwr1
    REAL :: pwr2
    REAL*8 :: result1
    REAL :: result10
    REAL :: arg10
    REAL :: arg2
    REAL :: arg11
    REAL :: arg12
    REAL*8 :: pwr10
    REAL :: arg13
!
! *** Here is where the criterion with the descriminant is put. When it
!     is < 0, then set CRIT2 = .TRUE. Otherwise, set the two values of
!     SSPLT and continue.
!C ** Population Splitting -- Modified by Ricardo Morales 2013
    c1 = d11 + d12/aa + d13/(aa*aa) + d14/(aa*aa*aa) + d15/(aa*aa*aa*aa)
    c2 = d21 + d22/aa + d23/(aa*aa) + d24/(aa*aa*aa) + d25/(aa*aa*aa*aa)
    c3 = d31 + d32/aa + d33/(aa*aa) + d34/(aa*aa*aa) + d35/(aa*aa*aa*aa)
    c4 = d41 + d42/aa + d43/(aa*aa) + d44/(aa*aa*aa) + d45/(aa*aa*aa*aa)
    xfhh = c1 + c2/bb + c3/(bb*bb) + c4/(bb*bb*bb)
    sqtwo = SQRT(2.)
    arg1 = alfa*wparcel*bet2
    descr = 1d0 - 16d0/9d0*DBLE(arg1)*(DBLE(akoh_drop)/spar**2d0)**2d0
    IF (descr .LE. 0d0) THEN
      crit2 = .true.
! Scrit - (only for DELTA < 0 )
      scrit = (16./9.*alfa*wparcel*bet2*akoh_drop**2.)**0.25
! Computing sp1 and sp2 (sp1 = sp2)
      pwr10 = spar**(-0.3824d0)
      pwr1 = SNGL(pwr10)
      pwr2 = scrit**(-0.3824)
      ratio = 2.0e7/3.0*akoh_drop*(pwr1-pwr2)
      ratio = 1./sqtwo + ratio
      IF (ratio .GT. 1.0) ratio = 1.0
      ssplt2 = spar*DBLE(ratio)
    ELSE
      crit2 = .false.
! min root of both
      result1 = SQRT(descr)
      ssplt1 = 0.5d0*(1.d0-result1)
! max root of both
      result1 = SQRT(descr)
      ssplt2 = 0.5d0*(1.d0+result1)
! Multiply ratios with Smax
      result1 = SQRT(ssplt1)
      ssplt1 = result1*spar
      result1 = SQRT(ssplt2)
      ssplt2 = result1*spar
    END IF
! *** Computing the condensation integrals I1 and I2
!
!Contribution of integral 1 for Kohler 
    sum = 0.0
!Contribution of integral 2 for kohler
    summat = 0.0
!Variable that stores all droplets
    summa = 0.0
!Contribution of FHH integral
    sumfhh = 0.0
    DO j=1,nm_drop
      IF (modei(j) .EQ. 1) THEN
! Koehler modes
!ln(sigmai)
        dlgsg = LOG(sig(j))
!ln(sg/smax)
        arg13 = sg(j)/SNGL(spar)
        dlgsp = LOG(arg13)
!RM: ln(sg/sp2)
        arg1 = sg(j)/SNGL(ssplt2)
        dlgsp2 = LOG(arg1)
! u(sp2)
        orism1 = 2.*dlgsp2/(3.*sqtwo*dlgsg)
! u(sp2)-3ln(sigmai)/(2sqrt(2)
        orism2 = orism1 - 3.*dlgsg/(2.*sqtwo)
! RM: u(smax)
        orism5 = 2.*dlgsp/(3.*sqtwo*dlgsg)
! u(smax)-3ln(sigmai)/(2sqrt(2)
        orism3 = orism5 - 3.*dlgsg/(2.*sqtwo)
! RM: Dp0 = Dpc/sqrt(3) - Equilibrium diameter
        result10 = SQRT(3.)
        deq = akoh_drop*2./sg(j)/3./result10
        erf2 = ERFP(orism2)
        erf3 = ERFP(orism3)
        arg10 = 9./8.*dlgsg*dlgsg
        arg2 = tp(j)/sg(j)
        integ2(j) = EXP(arg10)*arg2*(erf2-erf3)
! I2(sp2,smax)
        IF (crit2) THEN
          orism6 = sqtwo*dlgsp2/3./dlgsg - 1.5*dlgsg/sqtwo
          erf6 = ERFP(orism6)
          integ1(j) = 0.0
! 'inertially' limited particles
          arg11 = 9./8.*dlgsg*dlgsg
          dw3 = tp(j)*deq*EXP(arg11)*(1.-erf6)*(bet2*alfa*wparcel)**0.5
        ELSE
          ekth = EXP(9./2.*dlgsg*dlgsg)
! RM: ln(sg/sp1)
          arg12 = sg(j)/SNGL(ssplt1)
          dlgsp1 = LOG(arg12)
! u(sp2) + 3ln(sigmai)/sqrt(2)
          orism4 = orism1 + 3.*dlgsg/sqtwo
          erf1 = ERFP(orism1)
          erf4 = ERFP(orism4)
! I1(0,sp2)
          intaux1p2 = tp(j)*SNGL(spar)*(1.-erf1-0.5*(sg(j)/SNGL(spar))**&
&           2.*ekth*(1.-erf4))
! u(sp1) 
          orism1 = 2.*dlgsp1/(3.*sqtwo*dlgsg)
! u(sp1) + 3ln(sigmai)/sqrt(2)
          orism4 = orism1 + 3.*dlgsg/sqtwo
          orism6 = sqtwo*dlgsp1/3./dlgsg - 1.5*dlgsg/sqtwo
          erf1 = ERFP(orism1)
          erf4 = ERFP(orism4)
          erf6 = ERFP(orism6)
! I1(0,sp1)
          intaux1p1 = tp(j)*SNGL(spar)*(1.-erf1-0.5*(sg(j)/SNGL(spar))**&
&           2.*ekth*(1.-erf4))
! I1(sp1,sp2) = I1(0,sp2) - I1(0,sp1)
          integ1(j) = intaux1p2 - intaux1p1
! 'inertially' limited particles.
          arg11 = 9./8.*dlgsg*dlgsg
          dw3 = tp(j)*deq*EXP(arg11)*(1.-erf6)*(bet2*alfa*wparcel)**0.5
        END IF
!C *** Calculate number of Drops
        erf5 = ERFP(orism5)
        nd(j) = tp(j)/2.*(1.-erf5)
!SUM OF INTEGRAL 1 FOR KOHLER
        sum = sum + integ1(j) + dw3
!SUM OF INTEGRAL 2 FOR KOHLER
        summat = summat + integ2(j)
!SUM OF ACTIVATED KOHLER PARTICLES
        summa = summa + nd(j)
      ELSE IF (modei(j) .EQ. 2) THEN
! FHH modes
! ln(sigma,i)
        dlgsgf = LOG(sig(j))
! ln(sg/smax)
        arg13 = sg(j)/SNGL(spar)
        dlgspf = LOG(arg13)
! (sg/smax)^2
        orism1f = sg(j)*sg(j)/SNGL(spar*spar)
! exp(term)
        arg11 = 2.*xfhh*xfhh*dlgsgf*dlgsgf
        orism2f = EXP(arg11)
! sqrt(2).x.ln(sigma,i)
        orism3f = sqtwo*xfhh*dlgsgf
! Umax
        orism4f = dlgspf/(-(1.*orism3f))
        orism5f = orism3f - orism4f
        erf5f = ERFP(orism5f)
        orism6f = erf5f
        orism7f = orism6f + 1.
        orism8f = 0.5*orism1f*orism2f*orism7f
        erf4f = ERFP(orism4f)
        orism9f = orism8f + erf4f - 1.
        arg1 = tp(j)*SNGL(spar)*orism9f
        integ1f(j) = -(1.*arg1)
!C
!C *** Calculate number of drops activated by FHH theory
!C
        erf4f = ERFP(orism4f)
        ndf(j) = tp(j)/2.*(1.-erf4f)
!Sum of Integral 1 for FHH
        sumfhh = sumfhh + integ1f(j)
!Sum of ACTIVATED Kohler + FHH particles
        summa = summa + ndf(j)
      END IF
    END DO
    RETURN
  END SUBROUTINE SINTEGRAL
!=======================================================================
!
! *** FUNCTION VPRES
! *** THIS FUNCTION CALCULATES SATURATED WATER VAPOUR PRESSURE AS A 
!     FUNCTION OF TEMPERATURE. VALID FOR TEMPERATURES BETWEEN -50 AND 
!     50 C.
!
! ======================== ARGUMENTS / USAGE ===========================
!
!  INPUT:
!     [T] 
!     REAL variable.
!     Ambient temperature expressed in Kelvin. 
!
!  OUTPUT:
!     [VPRES] 
!     REAL variable.  
!     Saturated vapor pressure expressed in mbar.
!
!=======================================================================
!
  REAL FUNCTION VPRES(t)
    IMPLICIT NONE
    REAL :: a(0:6), t, ttemp
    INTEGER :: i
    DATA a /6.107799610e+0, 4.436518521e-1, 1.428945805e-2, &
&        2.650648471e-4, 3.031240396e-6, 2.034080948e-8, 6.136820929e-11&
&       /
!
! Calculate polynomial (without exponentiation).
!
    ttemp = t - 273.
    vpres = a(6)*ttemp
    DO i=5,1,-1
      vpres = (vpres+a(i))*ttemp
    END DO
    vpres = vpres + a(0)
!
! End of FUNCTION VPRES
!
    RETURN
  END FUNCTION VPRES
!=======================================================================
!
! *** FUNCTION SFT
! *** THIS FUNCTION CALCULATES WATER SURFACE TENSION AS A 
!     FUNCTION OF TEMPERATURE. VALID FOR TEMPERATURES BETWEEN -40 AND 
!     40 C.
!
! ======================== ARGUMENTS / USAGE ===========================
!
!  INPUT:
!     [T] 
!     REAL variable.
!     Ambient temperature expressed in Kelvin.
!
!  OUTPUT:
!     [SFT] 
!     REAL variable.  
!     Surface Tension expressed in J m-2.
!
!=======================================================================
!
  REAL FUNCTION SFT(t)
    IMPLICIT NONE
    REAL :: t, tpars
!
    tpars = t - 273.
    sft = 0.0761 - 1.55e-4*tpars
!
    RETURN
  END FUNCTION SFT
! ***********************************************************************
!
  SUBROUTINE GAULEG(x, w, n)
    IMPLICIT NONE
!
! Calculation of points and weights for N point GAUSS integration
! ***********************************************************************
    INTEGER, INTENT(IN) :: n
    REAL :: eps, x1, x2, xm, xl
    REAL, DIMENSION(n) :: x, w
    PARAMETER (eps=1.e-6)
    PARAMETER (x1=-1.0, x2=1.0)
    INTEGER :: i, j, m
    REAL :: z, p1, p, p2, p3, pp, z1
    INTRINSIC REAL
    INTRINSIC COS
    INTRINSIC ABS
    REAL :: arg1
    REAL :: abs0
!
! Calculation
!
    m = (n+1)/2
    xm = 0.5*(x2+x1)
    xl = 0.5*(x2-x1)
    DO i=1,m
      arg1 = 3.141592654*(REAL(i)-.25)/(REAL(n)+.5)
      z = COS(arg1)
 1    p1 = 1.
      p2 = 0.
      DO j=1,n
        p3 = p2
        p2 = p1
        p1 = ((2.*REAL(j)-1.)*z*p2-(REAL(j)-1.)*p3)/REAL(j)
      END DO
      pp = REAL(n)*(z*p1-p2)/(z*z-1.)
      z1 = z
      z = z1 - p1/pp
      IF (z - z1 .GE. 0.) THEN
        abs0 = z - z1
      ELSE
        abs0 = -(z-z1)
      END IF
      IF (abs0 .GT. eps) THEN
        GOTO 1
      ELSE
        x(i) = xm - xl*z
        x(n+1-i) = xm + xl*z
        w(i) = 2.*xl/((1.-z*z)*pp*pp)
        w(n+1-i) = w(i)
      END IF
    END DO
    RETURN
  END SUBROUTINE GAULEG
!=======================================================================
!
! *** REAL FUNCTION ERF
! *** THIS SUBROUTINE CALCULATES THE ERROR FUNCTION
!
! *** OBTAINED FROM NUMERICAL RECIPIES
!
!=======================================================================
!
  REAL FUNCTION ERF(x)
    IMPLICIT NONE
    REAL, INTENT(IN) :: x
    REAL :: result1
    REAL :: arg1
    IF (x .LT. 0.) THEN
      arg1 = x**2
      result1 = GAMMP(.5, arg1)
      erf = -result1
    ELSE
      arg1 = x**2
      erf = GAMMP(.5, arg1)
    END IF
    RETURN
  END FUNCTION ERF
!  Differentiation of erfp_d in reverse (adjoint) mode (with options no!SliceDeadControl no!SliceDeadInstrs no!tryRecomputations)
!:
!   gradient     of useful results: erfp_d erfp
!   with respect to varying inputs: xd x
!  Differentiation of erfp in forward (tangent) mode:
!   variations   of useful results: erfp
!   with respect to varying inputs: x
!C=======================================================================
!C
!C *** REAL FUNCTION erfp
!C *** THIS SUBROUTINE CALCULATES THE ERROR FUNCTION USING A
!C *** POLYNOMIAL APPROXIMATION
!C
!C=======================================================================
!C
  SUBROUTINE ERFP_D_B(x, xb, xd, xdb, erfp, erfpb, erfp_db)
    IMPLICIT NONE
    REAL :: x
    REAL :: xb
    REAL :: xd
    REAL :: xdb
    REAL :: aa(4), axx, y
    REAL :: axxb, yb
    REAL :: axxd, yd
    REAL :: axxdb, ydb
    INTRINSIC ABS
    REAL :: erfp
    REAL :: erfpb
    INTEGER :: branch
    REAL :: erfp_d
    REAL :: erfp_db
    REAL :: temp3
    REAL :: temp2
    REAL :: temp1
    REAL :: temp0
    REAL :: tempb3
    REAL :: tempb2
    REAL :: tempb1
    REAL :: tempb0
    REAL :: tempb
    REAL :: temp
    REAL :: temp6
    REAL :: temp5
    REAL :: temp4
    DATA aa /0.278393, 0.230389, 0.000972, 0.078108/
    IF (x .GE. 0.) THEN
      yd = xd
      y = x
      CALL PUSHCONTROL1B(0)
    ELSE
      yd = -xd
      y = -x
      CALL PUSHCONTROL1B(1)
    END IF
    axxd = yd*(aa(1)+y*(aa(2)+y*(aa(3)+y*aa(4)))) + y*(yd*(aa(2)+y*(aa(3&
&     )+y*aa(4)))+y*(yd*(aa(3)+y*aa(4))+y*aa(4)*yd))
    axx = 1. + y*(aa(1)+y*(aa(2)+y*(aa(3)+y*aa(4))))
    CALL PUSHREAL4(axxd)
    axxd = axxd*axx + axx*axxd
    CALL PUSHREAL4(axx)
    axx = axx*axx
    CALL PUSHREAL4(axxd)
    axxd = axxd*axx + axx*axxd
    CALL PUSHREAL4(axx)
    axx = axx*axx
    CALL PUSHREAL4(axxd)
    axxd = axxd/axx**2
    CALL PUSHREAL4(axx)
    axx = 1. - 1./axx
    IF (x .LE. 0.) THEN
      erfp_d = -axxd
      CALL PUSHREAL4(erfp)
      erfp = -axx
      CALL PUSHCONTROL1B(0)
    ELSE
      erfp_d = axxd
      CALL PUSHREAL4(erfp)
      erfp = axx
      CALL PUSHCONTROL1B(1)
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL4(erfp)
      axxb = -erfpb
      axxdb = -erfp_db
    ELSE
      CALL POPREAL4(erfp)
      axxb = erfpb
      axxdb = erfp_db
    END IF
    CALL POPREAL4(axx)
    CALL POPREAL4(axxd)
    tempb = axxdb/axx**2
    axxb = axxb/axx**2 - axxd*2*tempb/axx
    axxdb = tempb
    CALL POPREAL4(axx)
    CALL POPREAL4(axxd)
    axxb = 2*axxd*axxdb + 2*axx*axxb
    axxdb = 2*axx*axxdb
    CALL POPREAL4(axx)
    CALL POPREAL4(axxd)
    axxb = 2*axxd*axxdb + 2*axx*axxb
    axxdb = 2*axx*axxdb
    temp6 = aa(3) + aa(4)*y
    temp5 = aa(2) + y*temp6
    tempb0 = y*axxb
    temp4 = aa(3) + aa(4)*y
    temp3 = aa(2) + y*temp4
    tempb1 = yd*axxdb
    temp2 = aa(3) + aa(4)*y
    temp = yd*temp2 + aa(4)*y*yd
    temp1 = aa(3) + aa(4)*y
    temp0 = aa(2) + y*temp1
    tempb2 = y*axxdb
    tempb3 = y*tempb2
    yb = (y**2*aa(4)+y*temp4+temp3)*tempb1 + (yd*temp0+y*temp)*axxdb + (&
&     temp+y*yd*aa(4)+yd*temp1)*tempb2 + (aa(4)*yd+yd*aa(4))*tempb3 + (y&
&     **2*aa(4)+y*temp6+temp5)*tempb0 + (aa(1)+y*temp5)*axxb
    ydb = (aa(4)*y+temp2)*tempb3 + temp0*tempb2 + (aa(1)+y*temp3)*axxdb
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      xb = yb
      xdb = ydb
    ELSE
      xb = -yb
      xdb = -ydb
    END IF
  END SUBROUTINE ERFP_D_B
!  Differentiation of erfp in forward (tangent) mode:
!   variations   of useful results: erfp
!   with respect to varying inputs: x
!C=======================================================================
!C
!C *** REAL FUNCTION erfp
!C *** THIS SUBROUTINE CALCULATES THE ERROR FUNCTION USING A
!C *** POLYNOMIAL APPROXIMATION
!C
!C=======================================================================
!C
  REAL FUNCTION ERFP_D(x, xd, erfp)
    IMPLICIT NONE
    REAL :: x
    REAL :: xd
    REAL :: aa(4), axx, y
    REAL :: axxd, yd
    INTRINSIC ABS
    REAL :: erfp
    DATA aa /0.278393, 0.230389, 0.000972, 0.078108/
    IF (x .GE. 0.) THEN
      yd = xd
      y = x
    ELSE
      yd = -xd
      y = -x
    END IF
    axxd = yd*(aa(1)+y*(aa(2)+y*(aa(3)+y*aa(4)))) + y*(yd*(aa(2)+y*(aa(3&
&     )+y*aa(4)))+y*(yd*(aa(3)+y*aa(4))+y*aa(4)*yd))
    axx = 1. + y*(aa(1)+y*(aa(2)+y*(aa(3)+y*aa(4))))
    axxd = axxd*axx + axx*axxd
    axx = axx*axx
    axxd = axxd*axx + axx*axxd
    axx = axx*axx
    axxd = axxd/axx**2
    axx = 1. - 1./axx
    IF (x .LE. 0.) THEN
      erfp_d = -axxd
      erfp = -axx
    ELSE
      erfp_d = axxd
      erfp = axx
    END IF
    RETURN
  END FUNCTION ERFP_D
!  Differentiation of erfp in reverse (adjoint) mode (with options no!SliceDeadControl no!SliceDeadInstrs no!tryRecomputations):
!   gradient     of useful results: erfp
!   with respect to varying inputs: x
!C=======================================================================
!C
!C *** REAL FUNCTION erfp
!C *** THIS SUBROUTINE CALCULATES THE ERROR FUNCTION USING A
!C *** POLYNOMIAL APPROXIMATION
!C
!C=======================================================================
!C
  SUBROUTINE ERFP_B(x, xb, erfpb)
    IMPLICIT NONE
    REAL :: x
    REAL :: xb
    REAL :: aa(4), axx, y
    REAL :: axxb, yb
    INTRINSIC ABS
    INTEGER :: branch
    REAL :: erfp
    REAL :: erfpb
    REAL :: temp0
    REAL :: tempb
    REAL :: temp
    DATA aa /0.278393, 0.230389, 0.000972, 0.078108/
    IF (x .GE. 0.) THEN
      y = x
      CALL PUSHCONTROL1B(0)
    ELSE
      y = -x
      CALL PUSHCONTROL1B(1)
    END IF
    axx = 1. + y*(aa(1)+y*(aa(2)+y*(aa(3)+y*aa(4))))
    CALL PUSHREAL4(axx)
    axx = axx*axx
    CALL PUSHREAL4(axx)
    axx = axx*axx
    CALL PUSHREAL4(axx)
    axx = 1. - 1./axx
    IF (x .LE. 0.) THEN
      erfp = -axx
      CALL PUSHCONTROL1B(0)
    ELSE
      erfp = axx
      CALL PUSHCONTROL1B(1)
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      axxb = -erfpb
    ELSE
      axxb = erfpb
    END IF
    CALL POPREAL4(axx)
    axxb = axxb/axx**2
    CALL POPREAL4(axx)
    axxb = 2*axx*axxb
    CALL POPREAL4(axx)
    axxb = 2*axx*axxb
    temp0 = aa(3) + aa(4)*y
    temp = aa(2) + y*temp0
    tempb = y*axxb
    yb = (y**2*aa(4)+y*temp0+temp)*tempb + (aa(1)+y*temp)*axxb
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      xb = yb
    ELSE
      xb = -yb
    END IF
  END SUBROUTINE ERFP_B
!C=======================================================================
!C
!C *** REAL FUNCTION erfp
!C *** THIS SUBROUTINE CALCULATES THE ERROR FUNCTION USING A
!C *** POLYNOMIAL APPROXIMATION
!C
!C=======================================================================
!C
  REAL FUNCTION ERFP(x)
    IMPLICIT NONE
    REAL :: x
    REAL :: aa(4), axx, y
    INTRINSIC ABS
    DATA aa /0.278393, 0.230389, 0.000972, 0.078108/
    IF (x .GE. 0.) THEN
      y = x
    ELSE
      y = -x
    END IF
    axx = 1. + y*(aa(1)+y*(aa(2)+y*(aa(3)+y*aa(4))))
    axx = axx*axx
    axx = axx*axx
    axx = 1. - 1./axx
    IF (x .LE. 0.) THEN
      erfp = -axx
    ELSE
      erfp = axx
    END IF
    RETURN
  END FUNCTION ERFP
!
!=======================================================================
!
  REAL FUNCTION GAMMP(a, x)
    IMPLICIT NONE
!
!=======================================================================
!
    REAL, INTENT(IN) :: a, x
    REAL :: gamser, gln, gammcf
    IF (x .LT. 0. .OR. a .LE. 0.) PRINT*, 'Nenes-GAMMP:', x, a
    IF (x .LT. a + 1.) THEN
      CALL GSER(gamser, a, x, gln)
      gammp = gamser
    ELSE
      CALL GCF(gammcf, a, x, gln)
      gammp = 1. - gammcf
    END IF
    RETURN
  END FUNCTION GAMMP
!
!=======================================================================
!
  SUBROUTINE GCF(gammcf, a, x, gln)
    IMPLICIT NONE
!
!=======================================================================
!
    INTEGER :: itmax, n
    REAL :: eps, gamser, a, x, gln, gammcf
    REAL :: gold, a0, a1, b0, b1, fac, an, ana, anf, g
    PARAMETER (itmax=100, eps=3.e-7)
    INTRINSIC FLOAT
    INTRINSIC ABS
    INTRINSIC LOG
    INTRINSIC EXP
    REAL :: arg1
    REAL :: abs0
    REAL :: abs1
    gln = GAMMLN(a)
    gold = 0.
    a0 = 1.
    a1 = x
    b0 = 0.
    b1 = 1.
    fac = 1.
    DO n=1,itmax
      an = FLOAT(n)
      ana = an - a
      a0 = (a1+a0*ana)*fac
      b0 = (b1+b0*ana)*fac
      anf = an*fac
      a1 = x*a0 + anf*a1
      b1 = x*b0 + anf*b1
      IF (a1 .GE. 0.) THEN
        abs1 = a1
      ELSE
        abs1 = -a1
      END IF
      IF (abs1 .GT. 1.e-9) THEN
        fac = 1./a1
        g = b1*fac
        IF ((g-gold)/g .GE. 0.) THEN
          abs0 = (g-gold)/g
        ELSE
          abs0 = -((g-gold)/g)
        END IF
        IF (abs0 .LT. eps) THEN
          GOTO 1
        ELSE
          gold = g
        END IF
      END IF
    END DO
    PRINT*, 'Nenes-GCF: A too large, ITMAX too small', a, x, gln
 1  arg1 = -x + a*LOG(x) - gln
    gammcf = EXP(arg1)*g
    RETURN
  END SUBROUTINE GCF
!
!=======================================================================
!
  SUBROUTINE GSER(gamser, a, x, gln)
    IMPLICIT NONE
!
!=======================================================================
!
    INTEGER :: itmax, n
    REAL :: eps, gamser, a, x, gln, ap, sum, del
    PARAMETER (itmax=100, eps=3.e-7)
    INTRINSIC ABS
    INTRINSIC LOG
    INTRINSIC EXP
    REAL :: arg1
    REAL :: abs1
    REAL :: abs0
    gln = GAMMLN(a)
    IF (x .LE. 0.) THEN
      IF (x .LT. 0.) PRINT*, 'Nenes-SGER:', x, a, gln
      gamser = 0.
      RETURN
    ELSE
      ap = a
      sum = 1./a
      del = sum
      DO n=1,itmax
        ap = ap + 1.
        del = del*x/ap
        sum = sum + del
        IF (del .GE. 0.) THEN
          abs0 = del
        ELSE
          abs0 = -del
        END IF
        IF (sum .GE. 0.) THEN
          abs1 = sum
        ELSE
          abs1 = -sum
        END IF
        IF (abs0 .LT. abs1*eps) GOTO 1
      END DO
      PRINT*, 'Nenes-GSER: A too large, ITMAX too small', a, x, gln
 1    arg1 = -x + a*LOG(x) - gln
      gamser = sum*EXP(arg1)
      RETURN
    END IF
  END SUBROUTINE GSER
!
!=======================================================================
!
  REAL FUNCTION GAMMLN(xx)
    IMPLICIT NONE
!
!=======================================================================
!
    REAL :: cof(6), stp, half, one, fpf, x, xx, tmp, ser
    INTEGER :: j
    INTRINSIC LOG
    DATA cof, stp /76.18009173, -86.50532033, 24.01409822, -1.231739516&
&        , .120858003e-2, -.536382e-5, 2.50662827465/
    x = xx - 1.
    tmp = x + 5.5
    tmp = (x+0.5)*LOG(tmp) - tmp
    ser = 1.
    DO j=1,6
      x = x + 1.
      ser = ser + cof(j)/x
    END DO
    gammln = tmp + LOG(stp*ser)
    RETURN
  END FUNCTION GAMMLN
!
!=======================================================================
!
! *** SUBROUTINE AerTyp
! *** LOGNORMAL DISTRIBUTION INFO, SCALED TO SULFATE MASS
!
!  Developed by
!  Athanasios Nenes
!  School of Earth and Atmospheric Sciences
!  School of Chemical and Biomolecular Engineering
!  Georgia Institute of Technology
!  Atlanta, Georgia, 30332-0340
!  e-mail: thanos.nenes@che.gatech.edu
!  URL: http:\\nenes.eas.gatech.edu
!
!=======================================================================
!
  SUBROUTINE AERTYP(tpi, dpgi, sigi, vhfi, amsi, densi, denii, amfsi, &
&   nmdm, nmd, sulfi, ityp, indx, snns, mode)
    IMPLICIT NONE
!
    INTEGER :: indx, nmd, i, nmdm
!
    REAL :: tpi(nmdm), dpgi(nmdm), sigi(nmdm), vhfi(nmdm), amsi(nmdm), &
&   densi(nmdm), denii(nmdm), amfsi(nmdm), sulfi(nmdm), snns(4*nmdm)
!Sylvia
    INTEGER :: ityp, mode(nmdm)
! dmlee
    REAL :: surad(36), bcrad(36), ocrad(36)
    REAL :: amts
    REAL :: rsalt
    DATA surad /0.0695, 0.0724, 0.0753, 0.0781, 0.0810, 0.0839, 0.0868, &
&        0.0897, 0.0925, 0.0954, 0.0983, 0.1010, 0.1036, 0.1063, 0.1090&
&        , 0.1135, 0.1180, 0.1190, 0.1200, 0.1210, 0.1225, 0.1240, &
&        0.1255, 0.1275, 0.1295, 0.1320, 0.1350, 0.1380, 0.1420, 0.1460&
&        , 0.1510, 0.1580, 0.1660, 0.1770, 0.1950, 0.2310/
    DATA bcrad /0.0118, 0.0118, 0.0118, 0.0118, 0.0118, 0.0118, 0.0118, &
&        0.0118, 0.0118, 0.0118, 0.0118, 0.0118, 0.0119, 0.0119, 0.0122&
&        , 0.0130, 0.0140, 0.0143, 0.0145, 0.0148, 0.0150, 0.0153, &
&        0.0156, 0.0158, 0.0161, 0.0163, 0.0166, 0.0169, 0.0172, 0.0175&
&        , 0.0179, 0.0183, 0.0188, 0.0195, 0.0203, 0.0223/
    DATA ocrad /0.0212, 0.0217, 0.0222, 0.0227, 0.0232, 0.0237, 0.0242, &
&        0.0247, 0.0252, 0.0257, 0.0262, 0.0268, 0.0274, 0.0279, 0.0285&
&        , 0.0294, 0.0306, 0.0309, 0.0312, 0.0315, 0.0318, 0.0322, &
&        0.0326, 0.0331, 0.0336, 0.0342, 0.0348, 0.0355, 0.0363, 0.0373&
&        , 0.0384, 0.0399, 0.0418, 0.0440, 0.0476, 0.0534/
    IF (indx .GE. 1 .AND. indx .LT. 11) rsalt = 1.
    IF (indx .GE. 11 .AND. indx .LT. 15) rsalt = 1.6
    IF (indx .GE. 15 .AND. indx .LT. 17) rsalt = 1.8
    IF (indx .GE. 17 .AND. indx .LT. 27) rsalt = 2.0
    IF (indx .GE. 27 .AND. indx .LT. 32) rsalt = 2.4
    IF (indx .GE. 32 .AND. indx .LT. 36) rsalt = 2.9
    IF (indx .EQ. 36) rsalt = 4.8
!
! *********************************************************************
! *** "POLLUTED" (NORTH ATLANTIC) MARINE AEROSOL
! *********************************************************************
!
    IF (ityp .EQ. 1) THEN
!
! Nucleation mode
!
! Total concentration (# m-3)
      tpi(1) = 230.e6
! Modal diameter (m)
      dpgi(1) = 0.02e-6
! Geometric dispersion (sigma_g)
      sigi(1) = 1.47
! Density of Soluble fraction (kg m-3)
      densi(1) = 1760.0
! Density of Insoluble fraction (kg m-3)
      denii(1) = 2100.0
! Soluble mass fraction
      amfsi(1) = 0.33
! Molar mass of Soluble fraction (kg mol-1)
      amsi(1) = 1.3200e-01
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(1) = 3.0
! Sylvia: logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(1) = 1
!
! Accumulation mode
!
! Total concentration (# m-3)
      tpi(2) = 176.7e6
! Modal diameter (m)
      dpgi(2) = 0.092e-6
! Geometric dispersion (sigma_g)
      sigi(2) = 1.6
! Density of Soluble fraction (kg m-3)
      densi(2) = 1760.0
! Density of Insoluble fraction (kg m-3)
      denii(2) = 2100.0
! Soluble mass fraction
      amfsi(2) = 0.33
! Molar mass of Soluble fraction (kg mol-1)
      amsi(2) = 1.3200e-01
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(2) = 3.0
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(2) = 1
!
! Coarse mode
!
! Total concentration (# m-3)
      tpi(3) = 3.1e6
! Modal diameter (m)
      dpgi(3) = 0.58e-6
! Geometric dispersion (sigma_g)
      sigi(3) = 2.49
! Density of Soluble fraction (kg m-3)
      densi(3) = 1760.0
! Density of Insoluble fraction (kg m-3)
      denii(3) = 2100.0
! Soluble mass fraction
      amfsi(3) = 0.95
! Molar mass of Soluble fraction (kg mol-1)
      amsi(3) = 1.3200e-01
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(3) = 3.0
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(3) = 1
!
! Cumulative properties
!
      amts = 1.75
      nmd = 3
!
! *********************************************************************
! *** CONTINENTAL AEROSOL
! *********************************************************************
!
    ELSE IF (ityp .EQ. 2) THEN
!
! Nucleation mode
!
! Total concentration (# m-3)
      tpi(1) = 1000e6
! Modal diameter (m)
      dpgi(1) = 0.016e-6
! Geometric dispersion (sigma_g)
      sigi(1) = 1.6
! Density of Soluble fraction (kg m-3)
      densi(1) = 1760.0
! Density of Insoluble fraction (kg m-3)
      denii(1) = 2100.0
! Soluble mass fraction
      amfsi(1) = 0.5
! Molar mass of Soluble fraction (kg mol-1)
      amsi(1) = 1.3200e-01
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(1) = 3.0
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(1) = 1
!
! Accumulation mode
!
! Total concentration (# m-3)
      tpi(2) = 800e6
! Modal diameter (m)
      dpgi(2) = 0.067e-6
! Geometric dispersion (sigma_g)
      sigi(2) = 2.1
! Density of Soluble fraction (kg m-3)
      densi(2) = 1760.0
! Density of Insoluble fraction (kg m-3)
      denii(2) = 2100.0
! Soluble mass fraction
      amfsi(2) = 0.5
! Molar mass of Soluble fraction (kg mol-1)
      amsi(2) = 1.3200e-01
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(2) = 3.0
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(2) = 1
!
! Coarse mode
!
! Total concentration (# m-3)
      tpi(3) = 0.72e6
! Modal diameter (m)
      dpgi(3) = 0.93e-6
! Geometric dispersion (sigma_g)
      sigi(3) = 2.2
! Density of Soluble fraction (kg m-3)
      densi(3) = 1760.0
! Density of Insoluble fraction (kg m-3)
      denii(3) = 2100.0
! Soluble mass fraction
      amfsi(3) = 0.5
! Molar mass of Soluble fraction (kg mol-1)
      amsi(3) = 1.3200e-01
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(3) = 3.0
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(3) = 1
!
! Cumulative properties
!
      amts = 4.46
      nmd = 3
!
! *********************************************************************
! *** "CLEAN" (SOUTHERN OCEANS) MARINE AEROSOL
! *********************************************************************
!
    ELSE IF (ityp .EQ. 3) THEN
!
! Nucleation mode
!
! Total concentration (# m-3)
      tpi(1) = 310.e6
! Modal diameter (m)
      dpgi(1) = 0.018e-6
! Geometric dispersion (sigma_g)
      sigi(1) = 1.4
! Density of Soluble fraction (kg m-3)
      densi(1) = 1760.0
! Density of Insoluble fraction (kg m-3)
      denii(1) = 2100.0
! Soluble mass fraction
      amfsi(1) = 0.33
! Molar mass of Soluble fraction (kg mol-1)
      amsi(1) = 1.3200e-01
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(1) = 3.0
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(1) = 1
!
! Accumulation mode
!
! Total concentration (# m-3)
      tpi(2) = 70.e6
! Modal diameter (m)
      dpgi(2) = 0.075e-6
! Geometric dispersion (sigma_g)
      sigi(2) = 1.6
! Density of Soluble fraction (kg m-3)
      densi(2) = 1760.0
! Density of Insoluble fraction (kg m-3)
      denii(2) = 2100.0
! Soluble mass fraction
      amfsi(2) = 0.33
! Molar mass of Soluble fraction (kg mol-1)
      amsi(2) = 1.3200e-01
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(2) = 3.0
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(2) = 1
!
! Coarse mode
!
! Total concentration (# m-3)
      tpi(3) = 3.1e6
! Modal diameter (m)
      dpgi(3) = 0.62e-6
! Geometric dispersion (sigma_g)
      sigi(3) = 2.7
! Density of Soluble fraction (kg m-3)
      densi(3) = 1760.0
! Density of Insoluble fraction (kg m-3)
      denii(3) = 2100.0
! Soluble mass fraction
      amfsi(3) = 0.95
! Molar mass of Soluble fraction (kg mol-1)
      amsi(3) = 1.3200e-01
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(3) = 3.0
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(3) = 1
!
! Cumulative properties
!
      amts = 1.75
      nmd = 3
!
! *********************************************************************
! *** GOCART type, Dongmin's Number
! *** Modified for SeaSalt bins, numbers from Donifan's
! *********************************************************************
!
    ELSE IF (ityp .EQ. 4) THEN
!
! OC
!
! Total concentration (# m-3)
      tpi(1) = 224.7e6
! Modal diameter (m)
      dpgi(1) = 2.*0.0212e-6
! Geometric dispersion (sigma_g)
      sigi(1) = 2.20
! Density of Soluble fraction (kg m-3)
      densi(1) = 1800.0
! Density of Insoluble fraction (kg m-3)
      denii(1) = 1800.0
! Soluble mass fraction
      amfsi(1) = 0.80
! Molar mass of Soluble fraction (kg mol-1)
      amsi(1) = 1.5000e-01
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(1) = 2.0
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(1) = 1
!
! Sulfate
!
! Total concentration (# m-3)
      tpi(2) = 40.1e6
! Modal diameter (m)
      dpgi(2) = 0.0695*2.e-6
! Geometric dispersion (sigma_g)
      sigi(2) = 2.03
! Density of Soluble fraction (kg m-3)
      densi(2) = 1700.0
! Density of Insoluble fraction (kg m-3)
      denii(2) = 1700.0
! Soluble mass fraction
      amfsi(2) = 0.95
! Molar mass of Soluble fraction (kg mol-1)
      amsi(2) = 1.3200e-01
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(2) = 3.0
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(2) = 1
!
! Sea Salt bin 1: 0.03 - 0.1
!
! Total concentration (# m-3)
      tpi(3) = 1.664e+07
! Modal diameter (m)
      dpgi(3) = 0.132e-6
! Geometric dispersion (sigma_g)
      sigi(3) = 2.0
! Density of Soluble fraction (kg m-3)
      densi(3) = 2200.0
! Density of Insoluble fraction (kg m-3)
      denii(3) = 2200.0
! Soluble mass fraction
      amfsi(3) = 1.00
! Molar mass of Soluble fraction (kg mol-1)
      amsi(3) = 58.44e-03
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(3) = 2.0
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(3) = 1
!
! Sea Salt bin 2: 0.1 - 0.5
!
! Total concentration (# m-3)
      tpi(4) = 8.773e+05
! Modal diameter (m)
      dpgi(4) = 0.352e-06
! Geometric dispersion (sigma_g)
      sigi(4) = 2.0
! Density of Soluble fraction (kg m-3)
      densi(4) = 2200.0
! Density of Insoluble fraction (kg m-3)
      denii(4) = 2200.0
! Soluble mass fraction
      amfsi(4) = 1.00
! Molar mass of Soluble fraction (kg mol-1)
      amsi(4) = 58.44e-03
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(4) = 2.0
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(4) = 1
!
! Sea Salt bin 3: 0.5 - 1.5
!
! Total concentration (# m-3)
      tpi(5) = 7.019e+03
! Modal diameter (m)
      dpgi(5) = 1.76e-06
! Geometric dispersion (sigma_g)
      sigi(5) = 2.0
! Density of Soluble fraction (kg m-3)
      densi(5) = 2200.0
! Density of Insoluble fraction (kg m-3)
      denii(5) = 2200.0
! Soluble mass fraction
      amfsi(5) = 1.00
! Molar mass of Soluble fraction (kg mol-1)
      amsi(5) = 58.44e-03
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(5) = 2.0
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(5) = 1
!
! Sea Salt bin 4: 1.5 - 5
!
! Total concentration (# m-3)
      tpi(6) = 5.471e+02
! Modal diameter (m)
      dpgi(6) = 4.12e-6
! Geometric dispersion (sigma_g)
      sigi(6) = 2.0
! Density of Soluble fraction (kg m-3)
      densi(6) = 2200.0
! Density of Insoluble fraction (kg m-3)
      denii(6) = 2200.0
! Soluble mass fraction
      amfsi(6) = 1.00
! Molar mass of Soluble fraction (kg mol-1)
      amsi(6) = 58.44e-03
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(6) = 2.0
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(6) = 1
!
! Sea Salt bin 5: 5 - 10
!
! Total concentration (# m-3)
      tpi(7) = 1.456e+01
! Modal diameter (m)
      dpgi(7) = 13.8e-6
! Geometric dispersion (sigma_g)
      sigi(7) = 2.0
! Density of Soluble fraction (kg m-3)
      densi(7) = 2200.0
! Density of Insoluble fraction (kg m-3)
      denii(7) = 2200.0
! Soluble mass fraction
      amfsi(7) = 1.00
! Molar mass of Soluble fraction (kg mol-1)
      amsi(7) = 58.44e-03
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(7) = 2.0
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(7) = 1
!
! BC
!
! Total concentration (# m-3)
      tpi(8) = 4074.e6
! Modal diameter (m)
      dpgi(8) = 0.0118*2.e-6
! Geometric dispersion (sigma_g)
      sigi(8) = 2.0
! Density of Soluble fraction (kg m-3)
      densi(8) = 1000.0
! Density of Insoluble fraction (kg m-3)
      denii(8) = 1000.0
! Soluble mass fraction
      amfsi(8) = 0.5
! Molar mass of Soluble fraction (kg mol-1)
      amsi(8) = 72.0e-03
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(8) = 1.0
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(8) = 1
!
! Cumulative properties
!
      amts = 1.
      nmd = 8
!
! *********************************************************************
! *** MIRAGE type sulfate
! *********************************************************************
!
    ELSE IF (ityp .EQ. 5) THEN
!
! BC Accumulation
!
! Total concentration (# m-3)
      tpi(1) = 1.e6
! Modal diameter (m)
      dpgi(1) = 0.068e-6
! Geometric dispersion (sigma_g)
      sigi(1) = 1.8
! Density of Soluble fraction (kg m-3)
      densi(1) = 1700.0
! Density of Insoluble fraction (kg m-3)
      denii(1) = 1700.0
! Soluble mass fraction
      amfsi(1) = 0.5
! Molar mass of Soluble fraction (kg mol-1)
      amsi(1) = 48.0e-03
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(1) = 1.0
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(1) = 1
!
! BC Aitken
!
! Total concentration (# m-3)
      tpi(2) = 1.e6
! Modal diameter (m)
      dpgi(2) = 0.013e-6
! Geometric dispersion (sigma_g)
      sigi(2) = 1.6
! Density of Soluble fraction (kg m-3)
      densi(2) = 1700.0
! Density of Insoluble fraction (kg m-3)
      denii(2) = 1700.0
! Soluble mass fraction
      amfsi(2) = 0.5
! Molar mass of Soluble fraction (kg mol-1)
      amsi(2) = 48.0e-03
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(2) = 1.0
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(2) = 1
!
! Sea Salt Accumulation
!
! Total concentration (# m-3)
      tpi(3) = 1.e6
! Modal diameter (m)
      dpgi(3) = 0.2e-6
! Geometric dispersion (sigma_g)
      sigi(3) = 1.8
! Density of Soluble fraction (kg m-3)
      densi(3) = 1900.0
! Density of Insoluble fraction (kg m-3)
      denii(3) = 1900.0
! Soluble mass fraction
      amfsi(3) = 0.95
! Molar mass of Soluble fraction (kg mol-1)
      amsi(3) = 59.0e-03
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(3) = 2.0
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(3) = 1
!
! Sea Salt Coarse
!
! Total concentration (# m-3)
      tpi(4) = 1.e6
! Modal diameter (m)
      dpgi(4) = 2.0e-6
! Geometric dispersion (sigma_g)
      sigi(4) = 2.0
! Density of Soluble fraction (kg m-3)
      densi(4) = 1900.0
! Density of Insoluble fraction (kg m-3)
      denii(4) = 1900.0
! Soluble mass fraction
      amfsi(4) = 0.95
! Molar mass of Soluble fraction (kg mol-1)
      amsi(4) = 59.0e-03
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(4) = 2.0
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(4) = 1
!
! OC Accumulation
!
! Total concentration (# m-3)
      tpi(5) = 1.e6
! Modal diameter (m)
      dpgi(5) = 0.068e-6
! Geometric dispersion (sigma_g)
      sigi(5) = 1.8
! Density of Soluble fraction (kg m-3)
      densi(5) = 1000.0
! Density of Insoluble fraction (kg m-3)
      denii(5) = 1000.0
! Soluble mass fraction
      amfsi(5) = 0.8
! Molar mass of Soluble fraction (kg mol-1)
      amsi(5) = 150.0e-03
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(5) = 2.0
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(5) = 1
!
! OC Aitken
!
! Total concentration (# m-3)
      tpi(6) = 1.e6
! Modal diameter (m)
      dpgi(6) = 0.013e-6
! Geometric dispersion (sigma_g)
      sigi(6) = 1.6
! Density of Soluble fraction (kg m-3)
      densi(6) = 1000.0
! Density of Insoluble fraction (kg m-3)
      denii(6) = 1000.0
! Soluble mass fraction
      amfsi(6) = 0.8
! Molar mass of Soluble fraction (kg mol-1)
      amsi(6) = 150.0e-03
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(6) = 2.0
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(6) = 1
!
! Sulfate Accumulation
!
! Total concentration (# m-3)
      tpi(7) = 1.e6
! Modal diameter (m)
      dpgi(7) = 0.068e-6
! Geometric dispersion (sigma_g)
      sigi(7) = 1.8
! Density of Soluble fraction (kg m-3)
      densi(7) = 1770.0
! Density of Insoluble fraction (kg m-3)
      denii(7) = 1770.0
! Soluble mass fraction
      amfsi(7) = 0.95
! Molar mass of Soluble fraction (kg mol-1)
      amsi(7) = 150.0e-03
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(7) = 3.0
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(7) = 1
!
! Sulfate Accumulation
!
! Total concentration (# m-3)
      tpi(8) = 1.e6
! Modal diameter (m)
      dpgi(8) = 0.013e-6
! Geometric dispersion (sigma_g)
      sigi(8) = 1.6
! Density of Soluble fraction (kg m-3)
      densi(8) = 1770.0
! Density of Insoluble fraction (kg m-3)
      denii(8) = 1770.0
! Soluble mass fraction
      amfsi(8) = 0.95
! Molar mass of Soluble fraction (kg mol-1)
      amsi(8) = 150.0e-03
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(8) = 3.0
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(8) = 1
!
! Sulfate, Coarse Sea Salt
!
! Total concentration (# m-3)
      tpi(9) = 1.e6
! Modal diameter (m)
      dpgi(9) = 2.0e-6
! Geometric dispersion (sigma_g)
      sigi(9) = 2.0
! Density of Soluble fraction (kg m-3)
      densi(9) = 1770.0
! Density of Insoluble fraction (kg m-3)
      denii(9) = 1770.0
! Soluble mass fraction
      amfsi(9) = 0.95
! Molar mass of Soluble fraction (kg mol-1)
      amsi(9) = 150.0e-03
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(9) = 3.0
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(9) = 1
!
! Sulfate, Coarse Sea Salt
!
! Total concentration (# m-3)
      tpi(10) = 1.e6
! Modal diameter (m)
      dpgi(10) = 1.0e-6
! Geometric dispersion (sigma_g)
      sigi(10) = 1.8
! Density of Soluble fraction (kg m-3)
      densi(10) = 1770.0
! Density of Insoluble fraction (kg m-3)
      denii(10) = 1770.0
! Soluble mass fraction
      amfsi(10) = 0.95
! Molar mass of Soluble fraction (kg mol-1)
      amsi(10) = 150.0e-03
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(10) = 3.0
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(10) = 1
!
! Cumulative properties
!
      amts = 1.
      nmd = 10
!
! *********************************************************************
! *** MIRAGE type sulfate - internally mixed
! *********************************************************************
!
    ELSE IF (ityp .EQ. 6) THEN
!
! Accumulation mode
!
! Total concentration (# m-3)
      tpi(1) = 1.e6
! Modal diameter (m)
      dpgi(1) = 0.11e-6
! Geometric dispersion (sigma_g)
      sigi(1) = 1.8
! Density of Soluble fraction (kg m-3)
      densi(1) = snns(1)*1.e3
! Density of Insoluble fraction (kg m-3)
      denii(1) = snns(1)*1.e3
! Soluble mass fraction
      amfsi(1) = snns(2)
! Molar mass of Soluble fraction (kg mol-1)
      amsi(1) = snns(3)*1.e-3
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(1) = snns(4)
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(1) = 1
!
! Aitken mode
!
! Total concentration (# m-3)
      tpi(2) = 1.e6
! Modal diameter (m)
      dpgi(2) = 0.026e-6
! Geometric dispersion (sigma_g)
      sigi(2) = 1.6
! Density of Soluble fraction (kg m-3)
      densi(2) = snns(5)*1.e3
! Density of Insoluble fraction (kg m-3)
      denii(2) = snns(5)*1.e3
! Soluble mass fraction
      amfsi(2) = snns(6)
! Molar mass of Soluble fraction (kg mol-1)
      amsi(2) = snns(7)*1.e-3
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(2) = snns(8)
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(2) = 1
!
! Coarse sea salt
!
! Total concentration (# m-3)
      tpi(3) = 1.e6
! Modal diameter (m)
      dpgi(3) = 2.0e-6
! Geometric dispersion (sigma_g)
      sigi(3) = 2.0
! Density of Soluble fraction (kg m-3)
      densi(3) = snns(9)*1.e3
! Density of Insoluble fraction (kg m-3)
      denii(3) = snns(9)*1.e3
! Soluble mass fraction
      amfsi(3) = snns(10)
! Molar mass of Soluble fraction (kg mol-1)
      amsi(3) = snns(11)*1.e-3
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(3) = snns(12)
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(3) = 1
!
! Coarse dust
!
! Total concentration (# m-3)
      tpi(4) = 1.e6
! Modal diameter (m)
      dpgi(4) = 1.0e-6
! Geometric dispersion (sigma_g)
      sigi(4) = 1.8
! Density of Soluble fraction (kg m-3)
      densi(4) = snns(13)*1.e3
! Density of Insoluble fraction (kg m-3)
      denii(4) = snns(13)*1.e3
! Soluble mass fraction
      amfsi(4) = snns(14)
! Molar mass of Soluble fraction (kg mol-1)
      amsi(4) = snns(15)*1.e-3
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(4) = snns(16)
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(4) = 1
!
! Cumulative properties
!
      amts = 1.
      nmd = 4
!
! *********************************************************************
! *** GOCART type sulfate, sea salt, BCphilic and OCphilic
! *** Donifan using
! *********************************************************************
!
    ELSE IF (ityp .EQ. 7) THEN
!
!!     OC (hydrophilic)
!
! Total concentration (# m-3)
      tpi(1) = 9.547e+08
! Modal diameter (m)
      dpgi(1) = 0.0212*2.e-6
! Geometric dispersion (sigma_g)
      sigi(1) = 2.20
! Density of Soluble fraction (kg m-3)
      densi(1) = 1600.0
! Density of Insoluble fraction (kg m-3)
      denii(1) = 1600.0
! Soluble mass fraction
      amfsi(1) = 0.50
! Molar mass of Soluble fraction (kg mol-1)
      amsi(1) = 1.8000e-01
! Van't Hoff factor for soluble frac.(ions molec-1) nenes and seind
      vhfi(1) = 3.5
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(1) = 1
!
!    ! Sulfate
!     
! Total concentration (# m-3)
      tpi(2) = 4.383e+07
! Modal diameter (m)
      dpgi(2) = 0.0695*2.e-6
! Geometric dispersion (sigma_g)
      sigi(2) = 2.03e0
! Density of Soluble fraction (kg m-3)
      densi(2) = 1700.0
! Density of Insoluble fraction (kg m-3)
      denii(2) = 1700.0
! Soluble mass fraction
      amfsi(2) = 0.95
! Molar mass of Soluble fraction (kg mol-1)
      amsi(2) = 1.3200e-01
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(2) = 3.0
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(2) = 1
! Sea Salt bin 1: 0.03 - 0.1
! 
! Total concentration (# m-3)
      tpi(3) = 1.664e+07
! Modal diameter (m)
      dpgi(3) = 2.*0.066e-6
! Geometric dispersion (sigma_g)
      sigi(3) = 2.3
! Density of Soluble fraction (kg m-3)
      densi(3) = 2200.0
! Density of Insoluble fraction (kg m-3)
      denii(3) = 2200.0
! Soluble mass fraction
      amfsi(3) = 1.00
! Molar mass of Soluble fraction (kg mol-1)
      amsi(3) = 58.44e-03
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(3) = 2.0
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(3) = 1
!     
! Sea Salt bin 2: 0.1-0.5
! 
! Total concentration (# m-3)
      tpi(4) = 8.773e+05
! Modal diameter (m)
      dpgi(4) = 2.*0.176e-6
! Geometric dispersion (sigma_g)
      sigi(4) = 2.3
! Density of Soluble fraction (kg m-3)
      densi(4) = 2200.0
! Density of Insoluble fraction (kg m-3)
      denii(4) = 2200.0
! Soluble mass fraction
      amfsi(4) = 1.00
! Molar mass of Soluble fraction (kg mol-1)
      amsi(4) = 58.44e-03
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(4) = 2.0
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(4) = 1
!     
! Sea Salt bin 3: 0.5-1.5
! 
! Total concentration (# m-3)
      tpi(5) = 7.019e+03
! Modal diameter (m)
      dpgi(5) = 2.*0.88e-6
! Geometric dispersion (sigma_g)
      sigi(5) = 2.3
! Density of Soluble fraction (kg m-3)
      densi(5) = 2200.0
! Density of Insoluble fraction (kg m-3)
      denii(5) = 2200.0
! Soluble mass fraction
      amfsi(5) = 1.00
! Molar mass of Soluble fraction (kg mol-1)
      amsi(5) = 58.44e-03
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(5) = 2.0
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(5) = 1
!
! Sea Salt bin 4: 1.5-5 (radius)
!
! Total concentration (# m-3)
      tpi(6) = 5.471e+02
! Modal diameter (m)
      dpgi(6) = 2.*2.06e-6
! Geometric dispersion (sigma_g)
      sigi(6) = 2.3
! Density of Soluble fraction (kg m-3)
      densi(6) = 2200.0
! Density of Insoluble fraction (kg m-3)
      denii(6) = 2200.0
! Soluble mass fraction
      amfsi(6) = 1.00
! Molar mass of Soluble fraction (kg mol-1)
      amsi(6) = 58.44e-03
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(6) = 2.0
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(6) = 1
!
!! Sea Salt bin 5: 5-10 (radius)
!     
! Total concentration (# m-3)
      tpi(7) = 1.456e+01
! Modal diameter (m)
      dpgi(7) = 2.*6.90e-6
! Geometric dispersion (sigma_g)
      sigi(7) = 2.3
! Density of Soluble fraction (kg m-3)
      densi(7) = 2200.0
! Density of Insoluble fraction (kg m-3)
      denii(7) = 2200.0
! Soluble mass fraction 
      amfsi(7) = 1.00
! Molar mass of Soluble fraction (kg mol-1)
      amsi(7) = 58.44e-03
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(7) = 2.0
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(7) = 1
!
!   !      BC (hydrophilic)
!     
! Total concentration (# m-3)
      tpi(8) = 1.045e+10
! Modal diameter (m) 
      dpgi(8) = 0.0118*2.e-6
! Geometric dispersion (sigma_g)
      sigi(8) = 2.00
! Density of Soluble fraction (kg m-3)
      densi(8) = 1600.0
! Density of Insoluble fraction (kg m-3)
      denii(8) = 1600.0
! Soluble mass fraction
      amfsi(8) = 0.1
! Molar mass of Soluble fraction (kg mol-1)
      amsi(8) = 1.3200e-01
! Van't Hoff factor for soluble frac.(ions molec-1) nenes and seind
      vhfi(8) = 3.5
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(8) = 1
!
      amts = 1.
      nmd = 8
!     
! *********************************************************************
! *** GOCART type sulfate
! *** Numbers from Pete Colarco
! *********************************************************************
!
    ELSE IF (ityp .EQ. 8) THEN
!     
! OC  
!     
! Total concentration (# m-3) 
      tpi(1) = 9.76e8
! Modal diameter (m) 
      dpgi(1) = 0.0212*2.e-6
! Geometric dispersion (sigma_g)
      sigi(1) = 2.20
! Density of Soluble fraction (kg m-3)
      densi(1) = 1800.0
! Density of Insoluble fraction (kg m-3)
      denii(1) = 1800.0
! Soluble mass fraction
      amfsi(1) = 0.50
! Molar mass of Soluble fraction (kg mol-1)
      amsi(1) = 1.5000e-01
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(1) = 2.0
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(1) = 1
!     
! Sulfate
!     
! Total concentration (# m-3) 
      tpi(2) = 9.01e7
! Modal diameter (m) 
      dpgi(2) = 0.0695*2.e-6
! Geometric dispersion (sigma_g)
      sigi(2) = 2.03
! Density of Soluble fraction (kg m-3)
      densi(2) = 1700.0
! Density of Insoluble fraction (kg m-3)
      denii(2) = 1700.0
! Soluble mass fraction
      amfsi(2) = 0.95
! Molar mass of Soluble fraction (kg mol-1)
      amsi(2) = 1.3200e-01
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(2) = 3.0
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(2) = 1
!     
! Sea Salt bin 1: 0.03 - 0.1
!     
! Total concentration (# m-3) 
      tpi(3) = 3.017e8
! Modal diameter (m)
      dpgi(3) = 0.158e-6
! Geometric dispersion (sigma_g)
      sigi(3) = 2.0
! Density of Soluble fraction (kg m-3)
      densi(3) = 2200.0
! Density of Insoluble fraction (kg m-3)
      denii(3) = 2200.0
! Soluble mass fraction
      amfsi(3) = 1.00
! Molar mass of Soluble fraction (kg mol-1)
      amsi(3) = 58.44e-03
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(3) = 2.0
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(3) = 1
!
! Sea Salt bin 2: 0.1 - 0.5
!
! Total concentration (# m-3)
      tpi(4) = 1.085e7
! Modal diameter (m)
      dpgi(4) = 0.632e-6
! Geometric dispersion (sigma_g)
      sigi(4) = 2.0
! Density of Soluble fraction (kg m-3)
      densi(4) = 2200.0
! Density of Insoluble fraction (kg m-3)
      denii(4) = 2200.0
! Soluble mass fraction
      amfsi(4) = 1.00
! Molar mass of Soluble fraction (kg mol-1)
      amsi(4) = 58.44e-03
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(4) = 2.0
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(4) = 1
!
! Sea Salt bin 3: 0.5 - 1.5
!
! Total concentration (# m-3)
      tpi(5) = 1.207e5
! Modal diameter (m)
      dpgi(5) = 2.238e-6
! Geometric dispersion (sigma_g)
      sigi(5) = 2.0
! Density of Soluble fraction (kg m-3)
      densi(5) = 2200.0
! Density of Insoluble fraction (kg m-3)
      denii(5) = 2200.0
! Soluble mass fraction
      amfsi(5) = 1.00
! Molar mass of Soluble fraction (kg mol-1)
      amsi(5) = 58.44e-03
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(5) = 2.0
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(5) = 1
!
! Sea Salt bin 4: 1.5 - 5
!
! Total concentration (# m-3)
      tpi(6) = 9.391e3
! Modal diameter (m)
      dpgi(6) = 5.64e-6
! Geometric dispersion (sigma_g)
      sigi(6) = 2.0
! Density of Soluble fraction (kg m-3)
      densi(6) = 2200.0
! Density of Insoluble fraction (kg m-3)
      denii(6) = 2200.0
! Soluble mass fraction
      amfsi(6) = 1.00
! Molar mass of Soluble fraction (kg mol-1)
      amsi(6) = 58.44e-03
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(6) = 2.0
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(6) = 1
!
! Sea Salt bin 5: 5 - 10
!
! Total concentration (# m-3)
      tpi(7) = 2.922e2
! Modal diameter (m)
      dpgi(7) = 15.54e-6
! Geometric dispersion (sigma_g)
      sigi(7) = 2.0
! Density of Soluble fraction (kg m-3)
      densi(7) = 2200.0
! Density of Insoluble fraction (kg m-3)
      denii(7) = 2200.0
! Soluble mass fraction
      amfsi(7) = 1.00
! Molar mass of Soluble fraction (kg mol-1)
      amsi(7) = 58.44e-03
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(7) = 2.0
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(7) = 1
!
! BC
!
! Total concentration (# m-3)
      tpi(8) = 1.50e10
! Modal diameter (m)
      dpgi(8) = 0.0118*2.e-6
! Geometric dispersion (sigma_g)
      sigi(8) = 2.0
! Density of Soluble fraction (kg m-3)
      densi(8) = 1000.0
! Density of Insoluble fraction (kg m-3)
      denii(8) = 1000.0
! Soluble mass fraction
      amfsi(8) = 0.2
! Molar mass of Soluble fraction (kg mol-1)
      amsi(8) = 90.0e-03
! Van't Hoff factor for soluble frac.(ions molec-1)
      vhfi(8) = 1.0
! logical variable: 1 = Koehler; 2 = FHH insoluble
      mode(8) = 1
!
! Cumulative properties
!
      amts = 1.
      nmd = 8
    END IF
!
! *********************************************************************
! *** PROCESS DISTRIBUTIONS AND RETURN
! *********************************************************************
!
    DO i=1,nmd
      IF (sulfi(i) .LT. 0.) THEN
        sulfi(i) = amts
      ELSE
! Scale dist. by sulfate mass
        tpi(i) = tpi(i)*sulfi(i)/amts
! Senstivity test 
!        TPI(I) = min(TPI(I),5.e8)
      END IF
    END DO
! Senstivity test
! BC
    amfsi(8) = 0.10
! OC
    amfsi(1) = 0.20
! SSx8
    DO i=3,7
      dpgi(i) = dpgi(i)*0.5
    END DO
! cfac
    dpgi(1) = dpgi(1)*4.
    dpgi(8) = dpgi(8)*4.
!
    RETURN
  END SUBROUTINE AERTYP
END MODULE AIE_D_B
