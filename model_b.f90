!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.9 (r5096) - 24 Feb 2014 16:53
!
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.9 (r5096) - 24 Feb 2014 16:53
!
MODULE ICE_AER_CLOUD_D_B
  IMPLICIT NONE
  
!  INCLUDE 'PUSHPOPDiff.f'
!  INCLUDE 'adBuffer.f'
!    END ICE PARAMETERIZATION DONIF
!
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
  PRIVATE 
  PUBLIC ice_activate, ice_activate_mod
  PUBLIC ice_activate_mod_b
!==================================================================
! VARIABLES USED IN THE ICE NUCLEATION PARAMETERIZATION 
!
!=================================================================
  REAL*8 :: amw_ice, wmw_ice, rgas_ice, dhs_ice, cpa_ice, rv_ice, &
& denwat_ice, denice_ice, vpresw_ice, vpresi_ice, denair_ice, &
& depcoef_ice, diff_ice, aircond_ice, thaccom_ice, ddry_ice, np_ice, &
& nin_ice, sh_ice, grav_ice, pi_ice, alfa_ice, beta_ice, shom_ice, &
& koft_ice, dliq_ice, normv_ice, g1_ice, g2_ice, gdoin_ice, z_ice, &
& doin_ice, vmin_ice, vmax_ice, miuv_ice, sigmav_ice, smax_ice, norg_ice&
& , sigorg_ice, dorg_ice, dbc_ice, sigbc_ice, zero_par, nbio_ice, &
& dbio_ice
  REAL*8 :: dhs_iceb, denice_iceb, vpresw_iceb, vpresi_iceb, denair_iceb&
& , depcoef_iceb, diff_iceb, aircond_iceb, ddry_iceb, np_iceb, nin_iceb&
& , alfa_iceb, beta_iceb, shom_iceb, koft_iceb, dliq_iceb, normv_iceb, &
& g1_iceb, g2_iceb, gdoin_iceb, z_iceb, vmin_iceb, vmax_iceb, &
& sigmav_iceb, norg_iceb, dorg_iceb, dbc_iceb
  REAL*8 :: lambda_ice, kdust_ice, kbc_ice, shdust_ice, shbc_ice, &
& effdust_ice, effbc_ice, del1dust_ice, si0dust_ice, del1bc_ice, &
& si0bc_ice, nbc_ice, mdust_ice, mbc_ice, nglassy_ice, sc_ice, &
& acorr_dust, acorr_bc, dgh_ice
  REAL*8 :: lambda_iceb, kdust_iceb, kbc_iceb, del1dust_iceb, &
& si0dust_iceb, del1bc_iceb, si0bc_iceb, nbc_iceb
!Barahona(2011) spec parameters
!new2   
  REAL*8 :: to_ice, kb_ice, hp_ice, na_ice, vs_ice, sigiv_ice, sigiw_ice&
& , adust_dep, abc_dep, aimm, waux_ice, lmeff_ice, dtnuc_dep, dtnuc_dhf&
& , dact_imm, vw_ice, rsc_ice, fdrop_dust, fdrop_bc, fcoa_dust, pice
  REAL*8 :: sigiw_iceb, adust_depb, abc_depb, aimmb, waux_iceb, &
& lmeff_iceb, dtnuc_depb, dtnuc_dhfb, dact_immb, vw_iceb, rsc_iceb
  REAL*8 :: sigiw_iced, rsc_iced
  REAL*8 :: sigiw_icedb, rsc_icedb
  REAL*8, DIMENSION(2) :: ndust_ice, sigdust_ice, ddust_ice
  REAL*8, DIMENSION(2) :: ndust_iceb, ddust_iceb
  INTEGER :: typeofspec_ice, nbindust_ice
  LOGICAL :: purehet_ice, purehom_ice
  REAL*8 :: dh1smooth
  REAL*8 :: dh1smoothb
  REAL*8 :: dh1smoothd
  REAL*8 :: dh1smoothdb
  REAL*8 :: ssconv_ice
!=================================================================
! DATA Statements for ice 
! Water molecular weight
  DATA wmw_ice /.018d0/
! Air molecular Weight 
  DATA amw_ice /0.029d0/
! Universal gas constant
  DATA rgas_ice /8.314d0/
! gravity
  DATA grav_ice /9.81d0/
!Air thermal gas capacity
  DATA cpa_ice /1005.1d0/
  DATA pi_ice /3.1415927d0/
! Default deposition coefficient
  DATA depcoef_ice /0.1d0/
!Default thermal accommodation coefficient
  DATA thaccom_ice /0.7d0/
  DATA zero_par /1e-12/
! MAx freezing T (K)
  DATA to_ice /273.15/
! Boltzmann constant (J/K)
  DATA kb_ice /1.3806e-23/
! Planck constant (J s)
  DATA hp_ice /6.626e-34/
! Avogadro"s number 
  DATA na_ice /6.023e23/
!Vibration frequency (1/s)
  DATA vs_ice /1.0e13/
! Ice Surface tension J m-2 PK97 page 147
  DATA sigiv_ice /106.e-3/
!Default interfacial tension J m-2 Barahona 2012 in prep 
  DATA sigiw_ice /22.35e-3/

CONTAINS
!
!=======end of decalarations================================================================
! SUBROUTNE ICE ACTIVATE: sets the variables needed for 
!the activation  subroutines and  return the ice number concentration
! tparcr    = T (K)
! pparcr    = P (pa)
! sigw      = Width of the distribution of updraft velocity (m s-1)
! qc        = Liquid cloud condensate mixing ratio (Kg/Kg)
! nice      = Nucleated ice number concentration 1/cc
! nhetice   = Ice crystal concentration by het freezing (m-3)
! smaxice   = maximum supersaturation with respect to ice
! nlim      = Limiting IN concentration (m-3)
! sc_ice    = Characteristic freezing point of the aerosol population (output)
! dust_size = mean sizes of the dust bins (m) 
! ndust     = dust number concentration (m-3)
! norg      = organics number concentration (m-3)
! dorg      = Geometric mean diameter of the organics (m-3)
! nhom      = sulfate number concentration (m-3)
! dhom      = dry diameter of sulfate   (m)
! nsoot     = soot number concentration (m-3)
! dsoot     = soot geometric mean diameter (m)
!===================================================================================
  SUBROUTINE ICE_ACTIVATE(tparc, pparc, wparc_ls, qc, nice, smaxice, &
&   nhetice, nlim, scice, inimm, ddust, ndust, norg, dorg, nhom, dhom, &
&   nsoot, dsoot, nbio, dbio, sigmadust, sigmabc, sigmaorg, sigmahom, &
&   alpha, spec)
    IMPLICIT NONE
!
!new2 
    REAL*8, INTENT(OUT) :: smaxice, nhetice, nlim, nice, scice, inimm
    REAL*8, INTENT(IN) :: tparc, pparc, wparc_ls, qc, norg, dorg, nhom, &
&   dhom, nsoot, dsoot, sigmadust, sigmabc, sigmaorg, sigmahom, alpha, &
&   nbio, dbio
    INTEGER, INTENT(IN) :: spec
    REAL*8, DIMENSION(2) :: ddust, ndust
    REAL*8 :: frac, antot, air_den, sigwparc, nhet
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC LOG
    INTRINSIC SQRT
    INTRINSIC SIZE
    INTRINSIC SUM
    REAL*8 :: result1
    DOUBLE PRECISION :: result2
    REAL*8 :: arg1
!initialize output    
!default value if no aerosol present  
    scice = 2.0
    nice = zero_par
    smaxice = zero_par
    nhetice = zero_par
    nlim = zero_par
    inimm = zero_par
!Kg/m3
    air_den = pparc*28.8d-3/rgas_ice/tparc
    IF (0.01 .LT. wparc_ls) THEN
      sigwparc = wparc_ls
    ELSE
      sigwparc = 0.01
    END IF
    IF (1.0 .GT. wparc_ls) THEN
      sigwparc = wparc_ls
    ELSE
      sigwparc = 1.0
    END IF
!defacult value !DONIFnew
    waux_ice = sigwparc*0.8
!Deposition coefficient     
    depcoef_ice = alpha
!get aerosol parameters  
!hom freezing   
    ddry_ice = dhom
!sulfate fraction above 0.1 microns assume sigma=2.3 
    arg1 = LOG(0.1e-6/ddry_ice)
    result1 = ERFAPP(arg1)
    result2 = SQRT(2d0)
    frac = 0.5d0*(1d0-result1/LOG(sigmahom)/result2)
    frac = 1.0
    np_ice = frac*nhom
!het freezing
! m2/m3 correction to the area due to non sphericity and aggregation Assumes 10 g/m2 (Murray 2011)
    acorr_dust = 2.7e7
!m2/m3 correction to the area due to non sphericity and aggregation Assumes 50 g/m2 (Murray 2011)
    acorr_bc = 4.5e7
!dust
    nbindust_ice = SIZE(ndust)
!  allocate(ndust_ice(nbindust_ice))
!  allocate(sigdust_ice(nbindust_ice))
!  allocate(ddust_ice(nbindust_ice))
    ddust_ice = ddust
!  where (ddust_ice .lt. 1.e-9)
!   ddust_ice=1e-9
!  end where !new
    ndust_ice = ndust
!Assumed width
    sigdust_ice = LOG(sigmadust)
!Black carbon
!
    nbc_ice = nsoot
    dbc_ice = dsoot
!Assumed width
    sigbc_ice = LOG(sigmabc)
!Organics  
!10% of organics is insoluble        
    norg_ice = norg*0.1
    dorg_ice = dorg
!Assumed width
    sigorg_ice = LOG(sigmaorg)
    smaxice = zero_par
    nhet = zero_par
    nice = zero_par
    nlim = zero_par
    antot = SUM(ndust_ice) + norg_ice + nbc_ice + np_ice
    nbio_ice = nbio
    dbio_ice = dbio
!===========Calculate nucleated crystal number==============
!Heteroegeneous spectrum =============================== 
    typeofspec_ice = spec
!-1 - Monodisperse
! 1- Meyers 
! 2- BKG, Phillips 2007 
! 3- Barahona (2009) Asumme a maximum freezing fraction then scale it 
! 4- PDA08, 
! 5-Phillips2013
! 6- Barahona 2012
!logical True supresses homog nucleation       
    purehet_ice = .false.
! True supresses het nucleation   
    purehom_ice = .false.
    IF (tparc .LT. 273.0) THEN
!only if below 0 C    
      IF (tparc .GT. 235.0) THEN
!only het freezing         
        IF (qc .LE. 1.e-7) THEN
!no liquid cloud, ice crystal concentration is given by competition between deposition and  growth  
          IF (antot .GT. 0.1) CALL ICEPARAM(wparc_ls, tparc, pparc, nhet&
&                                     , nice, smaxice, nlim)
        ELSE
!only if aerosol is present
!set Sw=1 call IN spec only-Mixed phase regime, calculate IN for immersion	   
! Other conditions limit to avoid errors outside the troposphere
          CALL PROP_ICE(tparc, pparc)
!new2 
!20% of dust incorporate into the droplets
          fdrop_dust = 0.2
!10% of  bc incorporate into the droplets
          fdrop_bc = 0.1
!fraction of dust that is coated with solute
          fcoa_dust = 0.5
!find immersion IN to do drop freezing            
          CALL INIMMERSION(inimm, tparc)
!now reduce dust and bc concentration to calculate nucleation outside of the cloud
          ndust_ice = ndust_ice*(1.0-fdrop_dust)
          nbc_ice = nbc_ice*(1.0-fdrop_bc)
!now calculate nucleation outside of the cloud using SW=1.0
!call  Het_freezing(tparc, pparc, nhet, nice, smaxice) !new2
        END IF
      ELSE IF (antot .GT. 0.1) THEN
!competitiion between homogeneous and heterogeneous freezing in cirrus regime	   
!only if aerosol is present
        CALL ICEPARAM(wparc_ls, tparc, pparc, nhet, nice, smaxice, nlim)
      END IF
    END IF
    IF (smaxice .LT. zero_par) THEN
      smaxice = zero_par
    ELSE
      smaxice = smaxice
    END IF
    IF (smaxice .GT. 2.0) THEN
      smaxice = 2.0
    ELSE
      smaxice = smaxice
    END IF
    IF (nhet .LT. zero_par) THEN
      nhetice = zero_par
    ELSE
      nhetice = nhet
    END IF
    IF (nice .LT. zero_par) THEN
      nice = zero_par
    ELSE
      nice = nice
    END IF
    IF (nlim .LT. zero_par) THEN
      nlim = zero_par
    ELSE
      nlim = nlim
    END IF
    IF (nhet .GT. 1e10) THEN
      nhetice = 1e10
    ELSE
      nhetice = nhet
    END IF
    IF (nlim .GT. 1e10) THEN
      nlim = 1e10
    ELSE
      nlim = nlim
    END IF
    IF (sc_ice .LT. 1.0) THEN
      scice = 1.0
    ELSE
      scice = sc_ice
    END IF
    IF (sc_ice .GT. 2.0) THEN
      scice = 2.0
    ELSE
      scice = sc_ice
    END IF
    IF (inimm .LT. zero_par) THEN
      inimm = zero_par
    ELSE
      inimm = inimm
    END IF
    IF (inimm .GT. 1e10) THEN
      inimm = 1e10
    ELSE
      inimm = inimm
    END IF
! deallocate(ndust_ice)
!  deallocate(sigdust_ice)
!  deallocate(ddust_ice)
    RETURN
  END SUBROUTINE ICE_ACTIVATE
!  Differentiation of ice_activate_mod in reverse (adjoint) mode:
!   gradient     of useful results: nice
!   with respect to varying inputs: nsoot nhom dorg alpha norg
!                ddust ndust wparc_ls tparc nice dsoot dhom
!   RW status of diff variables: dtnuc_dhf:(loc) waux_ice:(loc)
!                abc_dep:(loc) g1_ice:(loc) norg_ice:(loc) sigiw_ice:(loc)
!                del1bc_ice:(loc) del1dust_ice:(loc) dtnuc_dep:(loc)
!                aimm:(loc) diff_ice:(loc) ddry_ice:(loc) dhs_ice:(loc)
!                dact_imm:(loc) g2_ice:(loc) vmin_ice:(loc) beta_ice:(loc)
!                vmax_ice:(loc) si0dust_ice:(loc) si0bc_ice:(loc)
!                lambda_ice:(loc) lmeff_ice:(loc) normv_ice:(loc)
!                aircond_ice:(loc) vw_ice:(loc) kdust_ice:(loc)
!                ndust_ice:(loc) dorg_ice:(loc) alfa_ice:(loc)
!                dliq_ice:(loc) dh1smoothd:(loc) sigmav_ice:(loc)
!                adust_dep:(loc) kbc_ice:(loc) rsc_iced:(loc) koft_ice:(loc)
!                denice_ice:(loc) sigiw_iced:(loc) vpresw_ice:(loc)
!                gdoin_ice:(loc) vpresi_ice:(loc) dh1smooth:(loc)
!                dbc_ice:(loc) z_ice:(loc) denair_ice:(loc) np_ice:(loc)
!                nin_ice:(loc) depcoef_ice:(loc) ddust_ice:(loc)
!                rsc_ice:(loc) shom_ice:(loc) nbc_ice:(loc) nsoot:out
!                nhom:out dorg:out alpha:out norg:out ddust:out
!                ndust:out wparc_ls:out tparc:out nice:in-zero
!                dsoot:out dhom:out
  SUBROUTINE ICE_ACTIVATE_MOD_B(tparc, tparcb, pparc, wparc_ls, &
&   wparc_lsb, qc, nice, niceb, smaxice, nhetice, nlim, scice, inimm, &
&   ddust, ddustb, ndust, ndustb, norg, norgb, dorg, dorgb, nhom, nhomb&
&   , dhom, dhomb, nsoot, nsootb, dsoot, dsootb, nbio, dbio, sigmadust, &
&   sigmabc, sigmaorg, sigmahom, alpha, alphab, spec, ssguess)
    IMPLICIT NONE
!
!new2 
    REAL*8 :: smaxice, nhetice, nlim, nice, scice, inimm
    REAL*8 :: niceb
    REAL*8, INTENT(IN) :: tparc, pparc, wparc_ls, qc, norg, dorg, nhom, &
&   dhom, nsoot, dsoot, sigmadust, sigmabc, sigmaorg, sigmahom, alpha, &
&   nbio, dbio, ssguess
    REAL*8 :: tparcb, wparc_lsb, norgb, dorgb, nhomb, dhomb, nsootb, &
&   dsootb, alphab
    INTEGER, INTENT(IN) :: spec
    REAL*8, DIMENSION(2) :: ddust, ndust
    REAL*8, DIMENSION(2) :: ddustb, ndustb
    REAL*8 :: frac, antot, air_den, sigwparc, nhet
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC LOG
    INTRINSIC SQRT
    INTRINSIC SIZE
    INTRINSIC SUM
    REAL*8 :: result1
    DOUBLE PRECISION :: result2
    REAL*8 :: arg1
!initialize output    
!default value if no aerosol present      
!Kg/m3
    INTEGER :: branch
!defacult value !DONIFnew
    ssconv_ice = ssguess
!Deposition coefficient     
    depcoef_ice = alpha
!get aerosol parameters  
!hom freezing   
    ddry_ice = dhom
!sulfate fraction above 0.1 microns assume sigma=2.3 
    frac = 1.0
    np_ice = frac*nhom
!het freezing
! m2/m3 correction to the area due to non sphericity and aggregation Assumes 10 g/m2 (Murray 2011)
    acorr_dust = 2.7e7
!m2/m3 correction to the area due to non sphericity and aggregation Assumes 50 g/m2 (Murray 2011)
    acorr_bc = 4.5e7
!dust
    nbindust_ice = SIZE(ndust)
!  allocate(ndust_ice(nbindust_ice))
!  allocate(sigdust_ice(nbindust_ice))
!  allocate(ddust_ice(nbindust_ice))
    ddust_ice = ddust
!  where (ddust_ice .lt. 1.e-9)
!   ddust_ice=1e-9
!  end where !new
    ndust_ice = ndust
!Assumed width
    sigdust_ice = LOG(sigmadust)
!Black carbon
!
    nbc_ice = nsoot
    dbc_ice = dsoot
!Assumed width
    sigbc_ice = LOG(sigmabc)
!Organics  
!10% of organics is insoluble        
    norg_ice = norg*0.1
    dorg_ice = dorg
!Assumed width
    sigorg_ice = LOG(sigmaorg)
    nice = zero_par
    nlim = zero_par
    antot = SUM(ndust_ice) + norg_ice + nbc_ice + np_ice
    nbio_ice = nbio
    dbio_ice = dbio
!===========Calculate nucleated crystal number==============
!Heteroegeneous spectrum =============================== 
    typeofspec_ice = spec
!-1 - Monodisperse
! 1- Meyers 
! 2- BKG, Phillips 2007 
! 3- Barahona (2009) Asumme a maximum freezing fraction then scale it 
! 4- PDA08, 
! 5-Phillips2013
! 6- Barahona 2012
!logical True supresses homog nucleation       
    purehet_ice = .false.
! True supresses het nucleation   
    purehom_ice = .false.
    IF (tparc .LT. 273.0) THEN
!only if below 0 C    
      IF (tparc .GT. 235.0) THEN
!only het freezing         
        IF (qc .LE. 1.e-7) THEN
!no liquid cloud, ice crystal concentration is given by competition between deposition and  growth  
          IF (antot .GT. 0.1) THEN
            CALL PUSHREAL8(dbc_ice)
            CALL PUSHREAL8(dliq_ice)
            CALL ICEPARAM_MOD(wparc_ls, tparc, pparc, nhet, nice, &
&                       smaxice, nlim)
            CALL PUSHCONTROL3B(0)
          ELSE
            CALL PUSHCONTROL3B(1)
          END IF
        ELSE
          CALL PUSHCONTROL3B(2)
        END IF
      ELSE IF (antot .GT. 0.1) THEN
!competitiion between homogeneous and heterogeneous freezing in cirrus regime	   
!only if aerosol is present
        CALL PUSHREAL8(dbc_ice)
        CALL PUSHREAL8(dliq_ice)
        CALL ICEPARAM_MOD(wparc_ls, tparc, pparc, nhet, nice, smaxice, &
&                   nlim)
        CALL PUSHCONTROL3B(3)
      ELSE
        CALL PUSHCONTROL3B(4)
      END IF
    ELSE
      CALL PUSHCONTROL3B(5)
    END IF
    IF (nice .LT. zero_par) niceb = 0.0_8
    CALL POPCONTROL3B(branch)
    IF (branch .LT. 3) THEN
      IF (branch .EQ. 0) THEN
        CALL POPREAL8(dliq_ice)
        CALL POPREAL8(dbc_ice)
        CALL ICEPARAM_MOD_B(wparc_ls, wparc_lsb, tparc, tparcb, pparc, &
&                     nhet, nice, niceb, smaxice, nlim)
      ELSE IF (branch .EQ. 1) THEN
        norg_iceb = 0.0_8
        ddry_iceb = 0.0_8
        ndust_iceb = 0.0_8
        dorg_iceb = 0.0_8
        dbc_iceb = 0.0_8
        np_iceb = 0.0_8
        depcoef_iceb = 0.0_8
        ddust_iceb = 0.0_8
        nbc_iceb = 0.0_8
        wparc_lsb = 0.0_8
        tparcb = 0.0_8
      ELSE
        norg_iceb = 0.0_8
        ddry_iceb = 0.0_8
        ndust_iceb = 0.0_8
        dorg_iceb = 0.0_8
        dbc_iceb = 0.0_8
        np_iceb = 0.0_8
        depcoef_iceb = 0.0_8
        ddust_iceb = 0.0_8
        nbc_iceb = 0.0_8
        wparc_lsb = 0.0_8
        tparcb = 0.0_8
      END IF
    ELSE IF (branch .EQ. 3) THEN
      CALL POPREAL8(dliq_ice)
      CALL POPREAL8(dbc_ice)
      CALL ICEPARAM_MOD_B(wparc_ls, wparc_lsb, tparc, tparcb, pparc, &
&                   nhet, nice, niceb, smaxice, nlim)
    ELSE IF (branch .EQ. 4) THEN
      norg_iceb = 0.0_8
      ddry_iceb = 0.0_8
      ndust_iceb = 0.0_8
      dorg_iceb = 0.0_8
      dbc_iceb = 0.0_8
      np_iceb = 0.0_8
      depcoef_iceb = 0.0_8
      ddust_iceb = 0.0_8
      nbc_iceb = 0.0_8
      wparc_lsb = 0.0_8
      tparcb = 0.0_8
    ELSE
      norg_iceb = 0.0_8
      ddry_iceb = 0.0_8
      ndust_iceb = 0.0_8
      dorg_iceb = 0.0_8
      dbc_iceb = 0.0_8
      np_iceb = 0.0_8
      depcoef_iceb = 0.0_8
      ddust_iceb = 0.0_8
      nbc_iceb = 0.0_8
      wparc_lsb = 0.0_8
      tparcb = 0.0_8
    END IF
    dorgb = dorg_iceb
    norgb = 0.1*norg_iceb
    dsootb = dbc_iceb
    nsootb = nbc_iceb
    ndustb = 0.0_8
    ndustb = ndust_iceb
    ddustb = 0.0_8
    ddustb = ddust_iceb
    nhomb = frac*np_iceb
    dhomb = ddry_iceb
    alphab = depcoef_iceb
    niceb = 0.0_8
  END SUBROUTINE ICE_ACTIVATE_MOD_B
  SUBROUTINE ICE_ACTIVATE_MOD(tparc, pparc, wparc_ls, qc, nice, smaxice&
&   , nhetice, nlim, scice, inimm, ddust, ndust, norg, dorg, nhom, dhom&
&   , nsoot, dsoot, nbio, dbio, sigmadust, sigmabc, sigmaorg, sigmahom, &
&   alpha, spec)
    IMPLICIT NONE
!
!new2 
    REAL*8, INTENT(OUT) :: smaxice, nhetice, nlim, nice, scice, inimm
    REAL*8, INTENT(IN) :: tparc, pparc, wparc_ls, qc, norg, dorg, nhom, &
&   dhom, nsoot, dsoot, sigmadust, sigmabc, sigmaorg, sigmahom, alpha, &
&   nbio, dbio
    INTEGER, INTENT(IN) :: spec
    REAL*8, DIMENSION(2) :: ddust, ndust
    REAL*8 :: frac, antot, air_den, sigwparc, nhet
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC LOG
    INTRINSIC SQRT
    INTRINSIC SIZE
    INTRINSIC SUM
    REAL*8 :: result1
    DOUBLE PRECISION :: result2
    REAL*8 :: arg1
!initialize output    
!default value if no aerosol present      
!Kg/m3
    scice = 2.0
    nice = zero_par
    smaxice = zero_par
    nhetice = zero_par
    nlim = zero_par
    inimm = zero_par
!Kg/m3
    air_den = pparc*28.8d-3/rgas_ice/tparc
    IF (0.01 .LT. wparc_ls) THEN
      sigwparc = wparc_ls
    ELSE
      sigwparc = 0.01
    END IF
    IF (1.0 .GT. wparc_ls) THEN
      sigwparc = wparc_ls
    ELSE
      sigwparc = 1.0
    END IF
!defacult value !DONIFnew
!Deposition coefficient     
    waux_ice = sigwparc*0.8
!Deposition coefficient     
    depcoef_ice = alpha
!get aerosol parameters  
!hom freezing   
    ddry_ice = dhom
!sulfate fraction above 0.1 microns assume sigma=2.3 
    arg1 = LOG(0.1e-6/ddry_ice)
    result1 = ERFAPP(arg1)
    result2 = SQRT(2d0)
    frac = 0.5d0*(1d0-result1/LOG(sigmahom)/result2)
    frac = 1.0
    np_ice = frac*nhom
!het freezing
! m2/m3 correction to the area due to non sphericity and aggregation Assumes 10 g/m2 (Murray 2011)
    acorr_dust = 2.7e7
!m2/m3 correction to the area due to non sphericity and aggregation Assumes 50 g/m2 (Murray 2011)
    acorr_bc = 4.5e7
!dust
    nbindust_ice = SIZE(ndust)
!  allocate(ndust_ice(nbindust_ice))
!  allocate(sigdust_ice(nbindust_ice))
!  allocate(ddust_ice(nbindust_ice))
    ddust_ice = ddust
!  where (ddust_ice .lt. 1.e-9)
!   ddust_ice=1e-9
!  end where !new
    ndust_ice = ndust
!Assumed width
    sigdust_ice = LOG(sigmadust)
!Black carbon
!
    nbc_ice = nsoot
    dbc_ice = dsoot
!Assumed width
    sigbc_ice = LOG(sigmabc)
!Organics  
!10% of organics is insoluble        
    norg_ice = norg*0.1
    dorg_ice = dorg
!Assumed width
    sigorg_ice = LOG(sigmaorg)
    smaxice = zero_par
    nhet = zero_par
    nice = zero_par
    nlim = zero_par
    antot = SUM(ndust_ice) + norg_ice + nbc_ice + np_ice
    nbio_ice = nbio
    dbio_ice = dbio
!===========Calculate nucleated crystal number==============
!Heteroegeneous spectrum =============================== 
    typeofspec_ice = spec
!-1 - Monodisperse
! 1- Meyers 
! 2- BKG, Phillips 2007 
! 3- Barahona (2009) Asumme a maximum freezing fraction then scale it 
! 4- PDA08, 
! 5-Phillips2013
! 6- Barahona 2012
!logical True supresses homog nucleation       
    purehet_ice = .false.
! True supresses het nucleation   
    purehom_ice = .false.
    IF (tparc .LT. 273.0) THEN
!only if below 0 C    
      IF (tparc .GT. 235.0) THEN
!only het freezing         
        IF (qc .LE. 1.e-7) THEN
!no liquid cloud, ice crystal concentration is given by competition between deposition and  growth  
          IF (antot .GT. 0.1) CALL ICEPARAM_MOD(wparc_ls, tparc, pparc, &
&                                         nhet, nice, smaxice, nlim)
        ELSE
!only if aerosol is present
!set Sw=1 call IN spec only-Mixed phase regime, calculate IN for immersion	   
! Other conditions limit to avoid errors outside the troposphere
!new2 
!20% of dust incorporate into the droplets
!10% of  bc incorporate into the droplets
!fraction of dust that is coated with solute
!find immersion IN to do drop freezing            
!now reduce dust and bc concentration to calculate nucleation outside of the cloud
!now calculate nucleation outside of the cloud using SW=1.0
!call  Het_freezing(tparc, pparc, nhet, nice, smaxice) !new2
          CALL PROP_ICE(tparc, pparc)
!new2 
!20% of dust incorporate into the droplets
          fdrop_dust = 0.2
!10% of  bc incorporate into the droplets
          fdrop_bc = 0.1
!fraction of dust that is coated with solute
          fcoa_dust = 0.5
!find immersion IN to do drop freezing            
          CALL INIMMERSION(inimm, tparc)
!now reduce dust and bc concentration to calculate nucleation outside of the cloud
          ndust_ice = ndust_ice*(1.0-fdrop_dust)
          nbc_ice = nbc_ice*(1.0-fdrop_bc)
!now calculate nucleation outside of the cloud using SW=1.0
!call  Het_freezing(tparc, pparc, nhet, nice, smaxice) !new2
        END IF
      ELSE IF (antot .GT. 0.1) THEN
!competitiion between homogeneous and heterogeneous freezing in cirrus regime	   
!only if aerosol is present
        CALL ICEPARAM_MOD(wparc_ls, tparc, pparc, nhet, nice, smaxice, &
&                   nlim)
      END IF
    END IF
    IF (smaxice .LT. zero_par) THEN
      smaxice = zero_par
    ELSE
      smaxice = smaxice
    END IF
    IF (smaxice .GT. 2.0) THEN
      smaxice = 2.0
    ELSE
      smaxice = smaxice
    END IF
    IF (nhet .LT. zero_par) THEN
      nhetice = zero_par
    ELSE
      nhetice = nhet
    END IF
    IF (nice .LT. zero_par) THEN
      nice = zero_par
    ELSE
      nice = nice
    END IF
    IF (nlim .LT. zero_par) THEN
      nlim = zero_par
    ELSE
      nlim = nlim
    END IF
    IF (nhet .GT. 1e10) THEN
      nhetice = 1e10
    ELSE
      nhetice = nhet
    END IF
    IF (nlim .GT. 1e10) THEN
      nlim = 1e10
    ELSE
      nlim = nlim
    END IF
    IF (sc_ice .LT. 1.0) THEN
      scice = 1.0
    ELSE
      scice = sc_ice
    END IF
    IF (sc_ice .GT. 2.0) THEN
      scice = 2.0
    ELSE
      scice = sc_ice
    END IF
    IF (inimm .LT. zero_par) THEN
      inimm = zero_par
    ELSE
      inimm = inimm
    END IF
    IF (inimm .GT. 1e10) THEN
      inimm = 1e10
    ELSE
      inimm = inimm
    END IF
! deallocate(ndust_ice)
!  deallocate(sigdust_ice)
!  deallocate(ddust_ice)
    RETURN
  END SUBROUTINE ICE_ACTIVATE_MOD
!
!*************************************************************************
!
! ICE FREEZING PARAMETERIZATION FILES START HERE
!
! ************************************************************************
!
!
!======================================================================
!
!       Code Developer
!       Donifan Barahona, GA TECH
!       donifan@gatech.edu
!    -------------------------------
!     DESCRIPTION
!
!***********************************************************
!** Parameterization  of ICE crystal number concentration 
!** for large scale models. 
!** Donifan Barahona, Athanasios Nenes
!   JGR, 111, D11211,  2008
!   ACP, 9, 369-381,   2009 
!   ACP  9, 5933-5948, 2009
!   Homogeneoeus and heterogeneous nucleation considered   
!*** SI units unless otherwise specified. 
! 
!
! *** WRITTEN BY DONIFAN BARAHONA
!
!=======================================================================
  SUBROUTINE ICEPARAM(updraft, t, p, nhet, nice, smax, nlim)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: t, p, updraft
    REAL*8, INTENT(OUT) :: nice, nhet, smax, nlim
    REAL*8 :: wpar_ice, t_ice, p_ice, i
    LOGICAL :: use_av_v
    INTRINSIC MAX
    INTRINSIC MIN
    IF (p .LT. 1.0) THEN
      p_ice = 1.0
    ELSE
      p_ice = p
    END IF
    IF (t .LT. 190.0) THEN
      t_ice = 190.0
    ELSE
      t_ice = t
    END IF
!Updraft Velocity Distribution =================================
!set to false to integrate over a pdf of updraft
    use_av_v = .false.
    CALL PROP_ICE(t_ice, p_ice)
    IF (use_av_v) THEN
      IF (0.01 .LT. updraft*0.8) THEN
        wpar_ice = updraft*0.8
      ELSE
        wpar_ice = 0.01
      END IF
!new
      waux_ice = wpar_ice
      CALL NICE_PARAM(wpar_ice, t_ice, p_ice, nice, smax, nhet, nlim)
    ELSE
      vmin_ice = 0.01d0
      vmax_ice = 0.5d0
      sigmav_ice = updraft
      miuv_ice = 0.001d0
      IF (miuv_ice + 4d0*sigmav_ice .GT. 3.0) THEN
        vmax_ice = 3.0
      ELSE
        vmax_ice = miuv_ice + 4d0*sigmav_ice
      END IF
      IF (miuv_ice - 4d0*sigmav_ice .LT. 0.01) THEN
        vmin_ice = 0.01
      ELSE
        vmin_ice = miuv_ice - 4d0*sigmav_ice
      END IF
      CALL NICE_VDIST(t_ice, p_ice, nice, smax, nhet, nlim)
    END IF
    RETURN
  END SUBROUTINE ICEPARAM
!  Differentiation of iceparam_mod in reverse (adjoint) mode:
!   gradient     of useful results: nice
!   with respect to varying inputs: norg_ice ddry_ice ndust_ice
!                dorg_ice dbc_ice np_ice depcoef_ice ddust_ice
!                nbc_ice t updraft
  SUBROUTINE ICEPARAM_MOD_B(updraft, updraftb, t, tb, p, nhet, nice, &
&   niceb, smax, nlim)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: t, p, updraft
    REAL*8 :: tb, updraftb
    REAL*8 :: nice, nhet, smax, nlim
    REAL*8 :: niceb
    REAL*8 :: wpar_ice, t_ice, p_ice, i
    REAL*8 :: wpar_iceb, t_iceb
    LOGICAL :: use_av_v
    INTRINSIC MAX
    INTRINSIC MIN
    INTEGER :: branch
    IF (p .LT. 1.0) THEN
      p_ice = 1.0
    ELSE
      p_ice = p
    END IF
    IF (t .LT. 190.0) THEN
      t_ice = 190.0
      CALL PUSHCONTROL1B(0)
    ELSE
      t_ice = t
      CALL PUSHCONTROL1B(1)
    END IF
!Updraft Velocity Distribution =================================
!set to false to integrate over a pdf of updraft
    use_av_v = .false.
    CALL PUSHREAL8(p_ice)
    CALL PUSHREAL8(t_ice)
    CALL PROP_ICE(t_ice, p_ice)
    IF (use_av_v) THEN
      IF (0.01 .LT. updraft*0.8) THEN
        wpar_ice = updraft*0.8
        CALL PUSHCONTROL1B(0)
      ELSE
        wpar_ice = 0.01
        CALL PUSHCONTROL1B(1)
      END IF
!new
      waux_ice = wpar_ice
      wpar_iceb = 0.0_8
      t_iceb = 0.0_8
      nbc_iceb = 0.0_8
      shom_iceb = 0.0_8
      ddust_iceb = 0.0_8
      nin_iceb = 0.0_8
      np_iceb = 0.0_8
      denair_iceb = 0.0_8
      z_iceb = 0.0_8
      dbc_iceb = 0.0_8
      vpresi_iceb = 0.0_8
      gdoin_iceb = 0.0_8
      vpresw_iceb = 0.0_8
      denice_iceb = 0.0_8
      koft_iceb = 0.0_8
      kbc_iceb = 0.0_8
      adust_depb = 0.0_8
      dliq_iceb = 0.0_8
      alfa_iceb = 0.0_8
      dorg_iceb = 0.0_8
      ndust_iceb = 0.0_8
      kdust_iceb = 0.0_8
      vw_iceb = 0.0_8
      lmeff_iceb = 0.0_8
      lambda_iceb = 0.0_8
      si0bc_iceb = 0.0_8
      si0dust_iceb = 0.0_8
      beta_iceb = 0.0_8
      g2_iceb = 0.0_8
      dact_immb = 0.0_8
      ddry_iceb = 0.0_8
      aimmb = 0.0_8
      dtnuc_depb = 0.0_8
      del1dust_iceb = 0.0_8
      del1bc_iceb = 0.0_8
      norg_iceb = 0.0_8
      g1_iceb = 0.0_8
      abc_depb = 0.0_8
      dtnuc_dhfb = 0.0_8
      CALL NICE_PARAM_MOD_B(wpar_ice, wpar_iceb, t_ice, t_iceb, p_ice, &
&                     nice, niceb, smax, nhet, nlim)
      wpar_iceb = wpar_iceb + waux_iceb
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        updraftb = 0.8*wpar_iceb
      ELSE
        updraftb = 0.0_8
      END IF
    ELSE
      sigmav_ice = updraft
      miuv_ice = 0.001d0
      IF (miuv_ice + 4d0*sigmav_ice .GT. 3.0) THEN
        CALL PUSHCONTROL1B(0)
        vmax_ice = 3.0
      ELSE
        vmax_ice = miuv_ice + 4d0*sigmav_ice
        CALL PUSHCONTROL1B(1)
      END IF
      IF (miuv_ice - 4d0*sigmav_ice .LT. 0.01) THEN
        CALL PUSHCONTROL1B(0)
        vmin_ice = 0.01
      ELSE
        vmin_ice = miuv_ice - 4d0*sigmav_ice
        CALL PUSHCONTROL1B(1)
      END IF
      CALL NICE_VDIST_MOD_B(t_ice, t_iceb, p_ice, nice, niceb, smax, &
&                     nhet, nlim)
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) sigmav_iceb = sigmav_iceb - 4d0*vmin_iceb
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) sigmav_iceb = sigmav_iceb + 4d0*vmax_iceb
      updraftb = sigmav_iceb
    END IF
    CALL POPREAL8(t_ice)
    CALL POPREAL8(p_ice)
    CALL PROP_ICE_B(t_ice, t_iceb, p_ice)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      tb = 0.0_8
    ELSE
      tb = t_iceb
    END IF
  END SUBROUTINE ICEPARAM_MOD_B
  SUBROUTINE ICEPARAM_MOD(updraft, t, p, nhet, nice, smax, nlim)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: t, p, updraft
    REAL*8, INTENT(OUT) :: nice, nhet, smax, nlim
    REAL*8 :: wpar_ice, t_ice, p_ice, i
    LOGICAL :: use_av_v
    INTRINSIC MAX
    INTRINSIC MIN
    IF (p .LT. 1.0) THEN
      p_ice = 1.0
    ELSE
      p_ice = p
    END IF
    IF (t .LT. 190.0) THEN
      t_ice = 190.0
    ELSE
      t_ice = t
    END IF
!Updraft Velocity Distribution =================================
!set to false to integrate over a pdf of updraft
    use_av_v = .false.
    CALL PROP_ICE(t_ice, p_ice)
    IF (use_av_v) THEN
      IF (0.01 .LT. updraft*0.8) THEN
        wpar_ice = updraft*0.8
      ELSE
        wpar_ice = 0.01
      END IF
!new
      waux_ice = wpar_ice
      CALL NICE_PARAM_MOD(wpar_ice, t_ice, p_ice, nice, smax, nhet, nlim&
&                  )
    ELSE
      vmin_ice = 0.01d0
      vmax_ice = 0.5d0
      sigmav_ice = updraft
      miuv_ice = 0.001d0
      IF (miuv_ice + 4d0*sigmav_ice .GT. 3.0) THEN
        vmax_ice = 3.0
      ELSE
        vmax_ice = miuv_ice + 4d0*sigmav_ice
      END IF
      IF (miuv_ice - 4d0*sigmav_ice .LT. 0.01) THEN
        vmin_ice = 0.01
      ELSE
        vmin_ice = miuv_ice - 4d0*sigmav_ice
      END IF
      CALL NICE_VDIST_MOD(t_ice, p_ice, nice, smax, nhet, nlim)
    END IF
    RETURN
  END SUBROUTINE ICEPARAM_MOD
!*************************************************************
!    Subroutine nice_Vdist. Calculates the ice crystal number concentration
!    at the maximum supersaturation using a PDF of updraft using a 
!    sixth order Gauss-Legendre quadrature  
!     Inputs:  T, and P all SI units)
!    Output NC (m-3)
!    Barahona and Nenes, JGR, D11211 (2008) and ACPD, 15665-15698, (2008) 
!   Written by Donifan Barahona
!************************************************************ 
  SUBROUTINE NICE_VDIST(t_ice, p_ice, nice, smax, nhet, nlim)
    IMPLICIT NONE
    REAL*8 :: quadx(6), wpar, sum1, quadw(6), dp, sum2, sum3, sum4, x1, &
&   x2
    REAL*8, INTENT(IN) :: t_ice, p_ice
    REAL*8, INTENT(OUT) :: nice, smax, nhet, nlim
    INTEGER :: index
    INTRINSIC SQRT
    DOUBLE PRECISION :: result1
    REAL*8 :: result10
    REAL*8 :: result2
    DATA quadx /0.23861918d0, -0.23861918d0, 0.66120939d0, -0.66120939d0&
&        , 0.93246951d0, -0.93246951d0/
    DATA quadw /0.46791393d0, 0.46791393d0, 0.36076157d0, 0.36076157d0, &
&        0.17132449d0, 0.17132449d0/
!calculate the integral in the denominator
    result1 = SQRT(2d0)
    x1 = (vmin_ice-miuv_ice)/(result1*sigmav_ice)
    result1 = SQRT(2d0)
    x2 = (vmax_ice-miuv_ice)/(result1*sigmav_ice)
!  !cummulative width of the distribution of velocities 
    result10 = ERFAPP(x2)
    result2 = ERFAPP(x1)
    normv_ice = (result10-result2)*0.5d0
    sum1 = 0d0
    sum2 = 0d0
    sum3 = 0d0
    sum4 = 0d0
!use a Gauss-Legendre Quadrature
    DO index=1,6
      wpar = 0.5d0*((vmax_ice-vmin_ice)*quadx(index)+(vmax_ice+vmin_ice)&
&       )
!new	     
      waux_ice = wpar
      CALL NICE_PARAM(wpar, t_ice, p_ice, nice, smax, nhet, nlim)
      CALL GAUSSPDF(wpar, dp)
      sum1 = sum1 + nice*dp*quadw(index)
      sum2 = sum2 + smax*dp*quadw(index)
      sum3 = sum3 + nhet*dp*quadw(index)
      sum4 = sum4 + nlim*dp*quadw(index)
    END DO
    nice = sum1*(vmax_ice-vmin_ice)*0.5d0
    smax = sum2*(vmax_ice-vmin_ice)*0.5d0
    nhet = sum3*(vmax_ice-vmin_ice)*0.5d0
    nlim = sum4*(vmax_ice-vmin_ice)*0.5d0
    RETURN
  END SUBROUTINE NICE_VDIST
!  Differentiation of nice_vdist_mod in reverse (adjoint) mode:
!   gradient     of useful results: nice
!   with respect to varying inputs: dtnuc_dhf abc_dep g1_ice norg_ice
!                del1bc_ice del1dust_ice dtnuc_dep aimm ddry_ice
!                dact_imm g2_ice vmin_ice beta_ice vmax_ice si0dust_ice
!                si0bc_ice lambda_ice lmeff_ice vw_ice kdust_ice
!                ndust_ice dorg_ice alfa_ice dliq_ice sigmav_ice
!                adust_dep kbc_ice koft_ice denice_ice vpresw_ice
!                gdoin_ice vpresi_ice dbc_ice z_ice denair_ice
!                np_ice nin_ice ddust_ice shom_ice nbc_ice t_ice
  SUBROUTINE NICE_VDIST_MOD_B(t_ice, t_iceb, p_ice, nice, niceb, smax, &
&   nhet, nlim)
    IMPLICIT NONE
    REAL*8 :: quadx(6), wpar, sum1, quadw(6), dp, sum2, sum3, sum4, x1, &
&   x2
    REAL*8 :: wparb, sum1b, dpb, x1b, x2b
    REAL*8, INTENT(IN) :: t_ice, p_ice
    REAL*8 :: t_iceb
    REAL*8 :: nice, smax, nhet, nlim
    REAL*8 :: niceb
    INTEGER :: index
    INTRINSIC SQRT
    DOUBLE PRECISION :: result1
    REAL*8 :: result10
    REAL*8 :: result10b
    REAL*8 :: result2
    REAL*8 :: result2b
    REAL*8 :: tempb2
    REAL*8 :: tempb1
    REAL*8 :: tempb0
    REAL*8 :: tempb
    DATA quadx /0.23861918d0, -0.23861918d0, 0.66120939d0, -0.66120939d0&
&        , 0.93246951d0, -0.93246951d0/
    DATA quadw /0.46791393d0, 0.46791393d0, 0.36076157d0, 0.36076157d0, &
&        0.17132449d0, 0.17132449d0/
!calculate the integral in the denominator
    result1 = SQRT(2d0)
    x1 = (vmin_ice-miuv_ice)/(result1*sigmav_ice)
    CALL PUSHREAL8(result1)
    result1 = SQRT(2d0)
    x2 = (vmax_ice-miuv_ice)/(result1*sigmav_ice)
!  !cummulative width of the distribution of velocities 
    result10 = ERFAPP(x2)
    result2 = ERFAPP(x1)
    normv_ice = (result10-result2)*0.5d0
    sum1 = 0d0
!use a Gauss-Legendre Quadrature
    DO index=1,6
      wpar = 0.5d0*((vmax_ice-vmin_ice)*quadx(index)+(vmax_ice+vmin_ice)&
&       )
!new	     
      waux_ice = wpar
      CALL PUSHREAL8(dbc_ice)
      CALL PUSHREAL8(lambda_ice)
      CALL PUSHREAL8(nice)
      CALL NICE_PARAM_MOD(wpar, t_ice, p_ice, nice, smax, nhet, nlim)
      CALL PUSHREAL8(dp)
      CALL GAUSSPDF(wpar, dp)
      sum1 = sum1 + nice*dp*quadw(index)
    END DO
    tempb2 = 0.5d0*sum1*niceb
    sum1b = 0.5d0*(vmax_ice-vmin_ice)*niceb
    vmax_iceb = tempb2
    vmin_iceb = -tempb2
    dtnuc_dhfb = 0.0_8
    abc_depb = 0.0_8
    g1_iceb = 0.0_8
    norg_iceb = 0.0_8
    del1bc_iceb = 0.0_8
    del1dust_iceb = 0.0_8
    dtnuc_depb = 0.0_8
    aimmb = 0.0_8
    ddry_iceb = 0.0_8
    dact_immb = 0.0_8
    g2_iceb = 0.0_8
    beta_iceb = 0.0_8
    si0dust_iceb = 0.0_8
    si0bc_iceb = 0.0_8
    lambda_iceb = 0.0_8
    lmeff_iceb = 0.0_8
    normv_iceb = 0.0_8
    vw_iceb = 0.0_8
    kdust_iceb = 0.0_8
    ndust_iceb = 0.0_8
    dorg_iceb = 0.0_8
    alfa_iceb = 0.0_8
    dliq_iceb = 0.0_8
    sigmav_iceb = 0.0_8
    adust_depb = 0.0_8
    kbc_iceb = 0.0_8
    koft_iceb = 0.0_8
    denice_iceb = 0.0_8
    vpresw_iceb = 0.0_8
    gdoin_iceb = 0.0_8
    vpresi_iceb = 0.0_8
    dbc_iceb = 0.0_8
    z_iceb = 0.0_8
    denair_iceb = 0.0_8
    np_iceb = 0.0_8
    nin_iceb = 0.0_8
    ddust_iceb = 0.0_8
    shom_iceb = 0.0_8
    nbc_iceb = 0.0_8
    t_iceb = 0.0_8
    DO index=6,1,-1
      niceb = quadw(index)*dp*sum1b
      dpb = quadw(index)*nice*sum1b
      wpar = 0.5d0*((vmax_ice-vmin_ice)*quadx(index)+(vmax_ice+vmin_ice)&
&       )
      CALL POPREAL8(dp)
      CALL GAUSSPDF_B(wpar, wparb, dp, dpb)
      waux_ice = wpar
      CALL POPREAL8(nice)
      CALL POPREAL8(lambda_ice)
      CALL POPREAL8(dbc_ice)
      CALL NICE_PARAM_MOD_B(wpar, wparb, t_ice, t_iceb, p_ice, nice, &
&                     niceb, smax, nhet, nlim)
      wparb = wparb + waux_iceb
      tempb1 = 0.5d0*wparb
      vmax_iceb = vmax_iceb + (quadx(index)+1.0_8)*tempb1
      vmin_iceb = vmin_iceb + (1.0_8-quadx(index))*tempb1
    END DO
    result10b = 0.5d0*normv_iceb
    result2b = -(0.5d0*normv_iceb)
    x1b = 0.0_8
    CALL ERFAPP_B(x1, x1b, result2b)
    x2b = 0.0_8
    CALL ERFAPP_B(x2, x2b, result10b)
    tempb = x2b/(result1*sigmav_ice)
    vmax_iceb = vmax_iceb + tempb
    sigmav_iceb = sigmav_iceb - (vmax_ice-miuv_ice)*tempb/sigmav_ice
    CALL POPREAL8(result1)
    tempb0 = x1b/(result1*sigmav_ice)
    vmin_iceb = vmin_iceb + tempb0
    sigmav_iceb = sigmav_iceb - (vmin_ice-miuv_ice)*tempb0/sigmav_ice
  END SUBROUTINE NICE_VDIST_MOD_B
  SUBROUTINE NICE_VDIST_MOD(t_ice, p_ice, nice, smax, nhet, nlim)
    IMPLICIT NONE
    REAL*8 :: quadx(6), wpar, sum1, quadw(6), dp, sum2, sum3, sum4, x1, &
&   x2
    REAL*8, INTENT(IN) :: t_ice, p_ice
    REAL*8, INTENT(OUT) :: nice, smax, nhet, nlim
    INTEGER :: index
    INTRINSIC SQRT
    DOUBLE PRECISION :: result1
    REAL*8 :: result10
    REAL*8 :: result2
    DATA quadx /0.23861918d0, -0.23861918d0, 0.66120939d0, -0.66120939d0&
&        , 0.93246951d0, -0.93246951d0/
    DATA quadw /0.46791393d0, 0.46791393d0, 0.36076157d0, 0.36076157d0, &
&        0.17132449d0, 0.17132449d0/
!calculate the integral in the denominator
    result1 = SQRT(2d0)
    x1 = (vmin_ice-miuv_ice)/(result1*sigmav_ice)
    result1 = SQRT(2d0)
    x2 = (vmax_ice-miuv_ice)/(result1*sigmav_ice)
!  !cummulative width of the distribution of velocities 
    result10 = ERFAPP(x2)
    result2 = ERFAPP(x1)
    normv_ice = (result10-result2)*0.5d0
    sum1 = 0d0
    sum2 = 0d0
    sum3 = 0d0
    sum4 = 0d0
!use a Gauss-Legendre Quadrature
    DO index=1,6
      wpar = 0.5d0*((vmax_ice-vmin_ice)*quadx(index)+(vmax_ice+vmin_ice)&
&       )
!new	     
      waux_ice = wpar
      CALL NICE_PARAM_MOD(wpar, t_ice, p_ice, nice, smax, nhet, nlim)
      CALL GAUSSPDF(wpar, dp)
      sum1 = sum1 + nice*dp*quadw(index)
      sum2 = sum2 + smax*dp*quadw(index)
      sum3 = sum3 + nhet*dp*quadw(index)
      sum4 = sum4 + nlim*dp*quadw(index)
    END DO
    nice = sum1*(vmax_ice-vmin_ice)*0.5d0
    smax = sum2*(vmax_ice-vmin_ice)*0.5d0
    nhet = sum3*(vmax_ice-vmin_ice)*0.5d0
    nlim = sum4*(vmax_ice-vmin_ice)*0.5d0
    RETURN
  END SUBROUTINE NICE_VDIST_MOD
  SUBROUTINE NICE_PARAM(wpar_ice, t_ice, p_ice, nice, smax, nhet, nlim_)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: t_ice, p_ice, wpar_ice
    REAL*8, INTENT(OUT) :: nice, smax, nhet, nlim_
    REAL*8 :: aux1, aux2, g, dpmax, miu, monvol, fds, nlim, dlim, dstar&
&   , ds, nstar, nhom, fc, phido, auxnc, sizecorr, dsh, nhet_, f1, f2, &
&   saux, sup, slow, shalf, fhalf, dpmin, gam
    INTEGER :: index
    INTRINSIC SQRT
    INTRINSIC MAX
    INTRINSIC DLOG
    INTRINSIC EXP
    INTRINSIC MIN
    INTRINSIC SIGN
    INTRINSIC ABS
    REAL*8 :: pwr1
    REAL*8 :: pwr2
    REAL*8 :: arg1
    REAL*8 :: result1
    DOUBLE PRECISION :: result10
    REAL*8 :: abs0
    IF (np_ice .GT. 1.0) THEN
      monvol = np_ice*1.0d-6*ddry_ice*ddry_ice*ddry_ice
      aux1 = 1.6397d-14*t_ice - 3.1769d-12
      pwr1 = monvol**(-0.373d0)
      pwr2 = wpar_ice**(-0.05)
      dpmax = aux1*pwr1*pwr2
      IF (dpmax .GT. 1.0d-4) dpmax = 1.0d-4
    ELSE
      dpmax = 1.0d-4
    END IF
    pice = p_ice
!MInimum size for DPmax (added on 09/11/09)
    arg1 = alfa_ice*wpar_ice*g1_ice
    result1 = SQRT(arg1)
    dpmin = dliq_ice + 0.02/result1
    IF (dpmax .LT. dpmin) THEN
      dpmax = dpmin
    ELSE
      dpmax = dpmax
    END IF
    aux1 = dpmax - dliq_ice
    arg1 = (g2_ice+g1_ice*dpmax)/(g2_ice+g1_ice*dliq_ice)
    aux2 = DLOG(arg1)
    g = 1.3346d0*(g1_ice*aux1-g2_ice*aux2)/(aux1*g1_ice*g1_ice)
    result1 = SQRT(wpar_ice)
    lambda_ice = lambda_ice/result1
    result10 = SQRT(2d0)
    nstar = (g1_ice*alfa_ice*wpar_ice)**1.5d0/beta_ice/z_ice/result10
    gam = g2_ice/g1_ice
!*********IS HOMOGENEOUS FREEZING HAPPENING?********************
!CORRECTION TO Nc FROM HET FREEZING
    fds = 1d0
    nhom = 0d0
    IF (t_ice .GE. 235d0) THEN
!no homogeneous above 235 K
      nhom = 0d0
    ELSE IF (purehet_ice) THEN
      nhom = 0d0
    ELSE
!calculate limiting NIN for combined hom_het    
      IF (typeofspec_ice .GE. 0d0) THEN
!polydisperse expressions
        CALL INSPEC_ICE(shom_ice, t_ice, nhet_, dsh)
        sizecorr = EXP(-(2d0/lambda_ice/shom_ice))
        dstar = (4d0*dsh*dsh/3d0+2d0*dsh*(shom_ice-dsh))/(shom_ice-dsh+&
&         1d0)
        result1 = SQRT(dstar)
        nlim = nstar*(shom_ice+1d0)/shom_ice/result1/sizecorr
      ELSE
!monodisperse approximation
        dsh = shom_ice - sh_ice
        dstar = (4d0*dsh*dsh/3d0+2d0*dsh*(shom_ice-dsh))/(shom_ice-dsh+&
&         1d0)
        arg1 = gam*gam + 2d0*dstar/g1_ice/alfa_ice/wpar_ice
        result1 = SQRT(arg1)
        dlim = -gam + result1
        nlim = alfa_ice*wpar_ice*(shom_ice+1d0)/z_ice/beta_ice/shom_ice
        nlim = nlim*(g1_ice*dlim+g2_ice)/dlim/dlim
        nhet_ = nin_ice
      END IF
      IF (nlim .GT. 1d10) THEN
        nlim_ = 1d10
      ELSE
        nlim_ = nlim
      END IF
      IF (nlim .LT. 1d-6) THEN
        nlim_ = 1d-6
      ELSE
        nlim_ = nlim
      END IF
      fds = 1d0 - (nhet_/nlim)**1.5d0
      IF (fds .NE. fds) fds = 1d0
      IF (purehom_ice) THEN
        nhet_ = 0d0
        fds = 1.0d0
      END IF
      IF (fds .LE. 0d0) THEN
!Homogeneous nucleation completely inhibited by IN
        nhom = 0d0
      ELSE
!********FRACTION OF FROZEN DROPLETS********************
        miu = fds*alfa_ice*(shom_ice+1d0)*wpar_ice*koft_ice/shom_ice
        phido = (pi_ice*g/miu/2d0)**0.5d0*(g/miu)
        auxnc = 2d0*denair_ice/beta_ice/koft_ice/denice_ice/pi_ice/&
&         np_ice
        fc = auxnc/phido
!calculating hom Nc
        IF (np_ice .GT. 0d0) THEN
          IF (fc .LE. 0.6d0) THEN
            nhom = np_ice*EXP(-fc)*(1.0d0-EXP(-fc))
          ELSE
!correction needed for convective clouds (very high updraft) (Barahona et al. JGR, 2011)
            arg1 = (9d0-2*fc)/7d0
            nhom = np_ice/(1d0+EXP(arg1))
          END IF
        ELSE
          nhom = 0d0
        END IF
        smax = shom_ice
        nhet = nhet_
        GOTO 686
      END IF
    END IF
!finish	
!********PURE HETEROEGENEOUS FREEZING********************
!find interval for bisection
    smax = 0d0
    nhet = 0d0
    saux = 0.01d0
    IF (typeofspec_ice .LT. 0d0) saux = sh_ice + 0.00000000001d0
!minimun smax in monodisperse case
    CALL FINDSMAX(t_ice, wpar_ice, saux, f1)
    DO index=1,120
      IF (saux + 1d0 .GE. vpresw_ice/vpresi_ice) THEN
!limit to below water saturation new2
        shalf = vpresw_ice/vpresi_ice - 1.0
        GOTO 678
      ELSE
        saux = saux + 0.1d0
        CALL FINDSMAX(t_ice, wpar_ice, saux, f2)
        IF (f2*f1 .LT. 0d0) THEN
          GOTO 677
        ELSE
          f2 = f1
        END IF
      END IF
    END DO
    IF (f2*f1 .GT. 0d0) THEN
      nhet = 0d0
!No NIN present in pure heterogeneous mode smax>200%
      smax = saux
      GOTO 686
    END IF
!Perform bisection
 677 sup = saux
    slow = saux - 0.1d0
    DO index=1,100
      shalf = 0.5d0*(sup+slow)
      CALL FINDSMAX(t_ice, wpar_ice, shalf, fhalf)
      IF (SIGN(1.d0, f1)*SIGN(1.d0, fhalf) .LE. 0d0) THEN
        f2 = fhalf
        sup = shalf
      ELSE
        f1 = fhalf
        slow = shalf
      END IF
      IF (slow - sup .GE. 0.) THEN
        abs0 = slow - sup
      ELSE
        abs0 = -(slow-sup)
      END IF
      IF (abs0 .LE. 1d-10) GOTO 678
    END DO
 678 smax = shalf
    IF (typeofspec_ice .GE. 0d0) THEN
      CALL INSPEC_ICE(smax, t_ice, nhet, dsh)
    ELSE
!monodisperse approximation
      nhet = nin_ice
    END IF
 686 IF (nhet .NE. nhet) nhet = 0d0
!avoiding errors
    IF (nhom .NE. nhom) nhom = 0d0
!avoiding errors
    nice = nhom + nhet
    IF (smax + 1.0 - dsh .LT. 1.0) THEN
      sc_ice = 1.0
    ELSE
      sc_ice = smax + 1.0 - dsh
    END IF
    IF (shom_ice + 1.0 .GT. sc_ice) THEN
      sc_ice = sc_ice
    ELSE
      sc_ice = shom_ice + 1.0
    END IF
    RETURN
  END SUBROUTINE NICE_PARAM
!  Differentiation of nice_param_mod in reverse (adjoint) mode:
!   gradient     of useful results: dtnuc_dhf abc_dep g1_ice norg_ice
!                del1bc_ice del1dust_ice dtnuc_dep aimm ddry_ice
!                dact_imm g2_ice beta_ice si0dust_ice si0bc_ice
!                lambda_ice lmeff_ice vw_ice kdust_ice ndust_ice
!                dorg_ice alfa_ice dliq_ice adust_dep kbc_ice koft_ice
!                denice_ice vpresw_ice gdoin_ice vpresi_ice dbc_ice
!                z_ice denair_ice np_ice nin_ice ddust_ice shom_ice
!                nbc_ice t_ice nice wpar_ice
!   with respect to varying inputs: dtnuc_dhf waux_ice abc_dep
!                g1_ice norg_ice del1bc_ice del1dust_ice dtnuc_dep
!                aimm ddry_ice dact_imm g2_ice beta_ice si0dust_ice
!                si0bc_ice lambda_ice lmeff_ice vw_ice kdust_ice
!                ndust_ice dorg_ice alfa_ice dliq_ice adust_dep
!                kbc_ice koft_ice denice_ice vpresw_ice gdoin_ice
!                vpresi_ice dbc_ice z_ice denair_ice np_ice nin_ice
!                ddust_ice shom_ice nbc_ice t_ice wpar_ice
  SUBROUTINE NICE_PARAM_MOD_B(wpar_ice, wpar_iceb, t_ice, t_iceb, p_ice&
&   , nice, niceb, smax, nhet, nlim_)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: t_ice, p_ice, wpar_ice
    REAL*8 :: t_iceb, wpar_iceb
    REAL*8 :: nice, smax, nhet, nlim_
    REAL*8 :: niceb
    REAL*8 :: aux1, aux2, g, dpmax, miu, monvol, fds, nlim, dlim, dstar&
&   , ds, nstar, nhom, fc, phido, auxnc, sizecorr, dsh, nhet_, f1, f2, &
&   saux, sup, slow, shalf, fhalf, dpmin, gam
    REAL*8 :: aux1b, aux2b, gb, dpmaxb, miub, monvolb, fdsb, nlimb, &
&   dlimb, dstarb, nstarb, nhomb, fcb, phidob, auxncb, sizecorrb, dshb, &
&   nhet_b, shalfb, dpminb, gamb
    INTEGER :: index
    INTRINSIC SQRT
    INTRINSIC MAX
    INTRINSIC DLOG
    INTRINSIC EXP
    INTRINSIC MIN
    INTRINSIC SIGN
    INTRINSIC ABS
    REAL*8 :: pwr1
    REAL*8 :: pwr1b
    REAL*8 :: pwr2
    REAL*8 :: pwr2b
    REAL*8 :: arg1
    REAL*8 :: arg1b
    REAL*8 :: result1
    REAL*8 :: result1b
    DOUBLE PRECISION :: result10
    REAL*8 :: abs0
    REAL*8 :: nearzero, nearzero2, nearzerod
    REAL*8 :: nearzerob, nearzerodb
    INTEGER :: branch
    REAL*8 :: temp3
    REAL*8 :: temp2
    REAL*8 :: temp1
    REAL*8 :: temp0
    REAL*8 :: tempb9
    REAL*8 :: tempb8
    REAL*8 :: tempb7
    REAL*8 :: tempb6
    REAL*8 :: tempb5
    REAL*8 :: tempb4
    REAL*8 :: tempb19
    REAL*8 :: tempb3
    REAL*8 :: tempb18
    REAL*8 :: tempb2
    REAL*8 :: tempb17
    REAL*8 :: tempb1
    REAL*8 :: tempb16
    REAL*8 :: tempb0
    REAL*8 :: tempb15
    REAL*8 :: tempb14
    REAL*8 :: tempb13
    REAL*8 :: tempb12
    REAL*8 :: tempb11
    REAL*8 :: tempb10
    REAL*8 :: smaxb
    REAL*8 :: temp17
    REAL*8 :: temp16
    REAL*8 :: temp15
    REAL*8 :: temp14
    REAL*8 :: temp13
    REAL*8 :: temp12
    REAL*8 :: temp11
    REAL*8 :: temp10
    REAL*8 :: tempb
    REAL*8 :: nhetb
    REAL*8 :: tempb28
    REAL*8 :: tempb27
    REAL*8 :: tempb26
    REAL*8 :: tempb25
    REAL*8 :: temp
    REAL*8 :: tempb24
    REAL*8 :: tempb23
    REAL*8 :: tempb22
    REAL*8 :: temp9
    REAL*8 :: tempb21
    REAL*8 :: temp8
    REAL*8 :: tempb20
    REAL*8 :: temp7
    REAL*8 :: temp6
    REAL*8 :: temp5
    REAL*8 :: temp4
    IF (np_ice .GT. 1.0) THEN
      monvol = np_ice*1.0d-6*ddry_ice*ddry_ice*ddry_ice
      aux1 = 1.6397d-14*t_ice - 3.1769d-12
      pwr1 = monvol**(-0.373d0)
      pwr2 = wpar_ice**(-0.05)
      dpmax = aux1*pwr1*pwr2
      IF (dpmax .GT. 1.0d-4) THEN
        dpmax = 1.0d-4
        CALL PUSHCONTROL2B(0)
      ELSE
        CALL PUSHCONTROL2B(1)
      END IF
    ELSE
      CALL PUSHCONTROL2B(2)
      dpmax = 1.0d-4
    END IF
    pice = p_ice
!MInimum size for DPmax (added on 09/11/09)
    arg1 = alfa_ice*wpar_ice*g1_ice
    result1 = SQRT(arg1)
    dpmin = dliq_ice + 0.02/result1
    IF (dpmax .LT. dpmin) THEN
      dpmax = dpmin
      CALL PUSHCONTROL1B(0)
    ELSE
      dpmax = dpmax
      CALL PUSHCONTROL1B(1)
    END IF
    CALL PUSHREAL8(aux1)
    aux1 = dpmax - dliq_ice
    arg1 = (g2_ice+g1_ice*dpmax)/(g2_ice+g1_ice*dliq_ice)
    aux2 = DLOG(arg1)
    g = 1.3346d0*(g1_ice*aux1-g2_ice*aux2)/(aux1*g1_ice*g1_ice)
    CALL PUSHREAL8(result1)
    result1 = SQRT(wpar_ice)
    CALL PUSHREAL8(lambda_ice)
    lambda_ice = lambda_ice/result1
    result10 = SQRT(2d0)
    nstar = (g1_ice*alfa_ice*wpar_ice)**1.5d0/beta_ice/z_ice/result10
    gam = g2_ice/g1_ice
!*********IS HOMOGENEOUS FREEZING HAPPENING?********************
!CORRECTION TO Nc FROM HET FREEZING
    IF (t_ice .GE. 235d0) THEN
!no homogeneous above 235 K
      nhom = 0d0
      CALL PUSHCONTROL2B(0)
    ELSE IF (purehet_ice) THEN
      nhom = 0d0
      CALL PUSHCONTROL2B(1)
    ELSE
!calculate limiting NIN for combined hom_het    
      IF (typeofspec_ice .GE. 0d0) THEN
!polydisperse expressions
        CALL PUSHREAL8(dbc_ice)
        CALL INSPEC_ICE(shom_ice, t_ice, nhet_, dsh)
        sizecorr = EXP(-(2d0/lambda_ice/shom_ice))
        dstar = (4d0*dsh*dsh/3d0+2d0*dsh*(shom_ice-dsh))/(shom_ice-dsh+&
&         1d0)
        CALL PUSHREAL8(result1)
        result1 = SQRT(dstar)
        nlim = nstar*(shom_ice+1d0)/shom_ice/result1/sizecorr
        CALL PUSHCONTROL1B(0)
      ELSE
!monodisperse approximation
        dsh = shom_ice - sh_ice
        dstar = (4d0*dsh*dsh/3d0+2d0*dsh*(shom_ice-dsh))/(shom_ice-dsh+&
&         1d0)
        arg1 = gam*gam + 2d0*dstar/g1_ice/alfa_ice/wpar_ice
        CALL PUSHREAL8(result1)
        result1 = SQRT(arg1)
        dlim = -gam + result1
        nlim = alfa_ice*wpar_ice*(shom_ice+1d0)/z_ice/beta_ice/shom_ice
        CALL PUSHREAL8(nlim)
        nlim = nlim*(g1_ice*dlim+g2_ice)/dlim/dlim
        nhet_ = nin_ice
        CALL PUSHCONTROL1B(1)
      END IF
      fds = 1d0 - (nhet_/nlim)**1.5d0
      IF (fds .NE. fds) THEN
        fds = 1d0
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      IF (purehom_ice) THEN
        CALL PUSHREAL8(nhet_)
        nhet_ = 0d0
        fds = 1.0d0
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      IF (fds .LE. 0d0) THEN
!Homogeneous nucleation completely inhibited by IN
        nhom = 0d0
        CALL PUSHCONTROL2B(2)
      ELSE
!********FRACTION OF FROZEN DROPLETS********************
        miu = fds*alfa_ice*(shom_ice+1d0)*wpar_ice*koft_ice/shom_ice
        phido = (pi_ice*g/miu/2d0)**0.5d0*(g/miu)
        auxnc = 2d0*denair_ice/beta_ice/koft_ice/denice_ice/pi_ice/&
&         np_ice
        fc = auxnc/phido
!calculating hom Nc
        IF (np_ice .GT. 0d0) THEN
          IF (fc .LE. 0.6d0) THEN
            nhom = np_ice*EXP(-fc)*(1.0d0-EXP(-fc))
            CALL PUSHCONTROL2B(0)
          ELSE
!correction needed for convective clouds (very high updraft) (Barahona et al. JGR, 2011)
            arg1 = (9d0-2*fc)/7d0
            nhom = np_ice/(1d0+EXP(arg1))
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          nhom = 0d0
          CALL PUSHCONTROL2B(2)
        END IF
        nhet = nhet_
        CALL PUSHCONTROL2B(0)
        GOTO 686
      END IF
    END IF
!finish	
!********PURE HETEROEGENEOUS FREEZING********************
!find interval for bisection
!    smax = 0d0
!    nhet = 0d0
!    saux = 0.01d0
!    IF (typeofspec_ice .LT. 0d0) saux = sh_ice + 0.00000000001d0
!!minimun smax in monodisperse case
!    CALL FINDSMAX(t_ice, wpar_ice, saux, f1)
!    DO index=1,120
!      IF (saux + 1d0 .GE. vpresw_ice/vpresi_ice) THEN
!!limit to below water saturation new2
!        shalf = vpresw_ice/vpresi_ice - 1.0
!        GOTO 678
!      ELSE
!        saux = saux + 0.1d0
!        CALL FINDSMAX(t_ice, wpar_ice, saux, f2)
!        IF (f2*f1 .LT. 0d0) THEN
!          GOTO 677
!        ELSE
!          f2 = f1
!        END IF
!      END IF
!    END DO
!    IF (f2*f1 .GT. 0d0) THEN
!      nhet = 0d0
!!No NIN present in pure heterogeneous mode smax>200%
!      smax = saux
!      GOTO 686
!    END IF
!!Perform bisection
! 677 sup = saux
!    slow = saux - 0.1d0
!    DO index=1,100
!      shalf = 0.5d0*(sup+slow)
!      CALL FINDSMAX(t_ice, wpar_ice, shalf, fhalf)
!      IF (SIGN(1.d0, f1)*SIGN(1.d0, fhalf) .LE. 0d0) THEN
!        f2 = fhalf
!        sup = shalf
!      ELSE
!        f1 = fhalf
!        slow = shalf
!      END IF
!      IF (slow - sup .GE. 0.) THEN
!        abs0 = slow - sup
!      ELSE
!        abs0 = -(slow-sup)
!      END IF
!      IF (abs0 .LE. 1d-10) GOTO 678
!    END DO
    CALL PUSHREAL8(dbc_ice)
    CALL FINDSMAX(t_ice, wpar_ice, ssconv_ice, nearzero)
    CALL PUSHREAL8(dbc_ice)
    CALL FINDSMAX_D(t_ice, wpar_ice, ssconv_ice, 1d0, nearzero2, &
&             nearzerod)
    shalf = ssconv_ice - nearzero/nearzerod
    smax = shalf
    IF (typeofspec_ice .GE. 0d0) THEN
      CALL PUSHREAL8(dbc_ice)
      CALL PUSHREAL8(dsh)
      CALL INSPEC_ICE(smax, t_ice, nhet, dsh)
      CALL PUSHCONTROL2B(1)
    ELSE
!monodisperse approximation
      nhet = nin_ice
      CALL PUSHCONTROL2B(2)
    END IF
 686 IF (nhet .NE. nhet) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
!avoiding errors
    IF (nhom .NE. nhom) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    nhomb = niceb
    nhetb = niceb
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) nhomb = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) nhetb = 0.0_8
    CALL POPCONTROL2B(branch)
    IF (branch .EQ. 0) THEN
      nhet_b = nhetb
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        tempb28 = (1.0d0-EXP(-fc))*nhomb
        temp16 = EXP(-fc)
        np_iceb = np_iceb + temp16*tempb28
        fcb = EXP(-fc)*np_ice*temp16*nhomb - EXP(-fc)*np_ice*tempb28
      ELSE IF (branch .EQ. 1) THEN
        temp17 = EXP(arg1) + 1d0
        np_iceb = np_iceb + nhomb/temp17
        arg1b = -(np_ice*EXP(arg1)*nhomb/temp17**2)
        fcb = -(2*arg1b/7d0)
      ELSE
        fcb = 0.0_8
      END IF
      auxncb = fcb/phido
      phidob = -(auxnc*fcb/phido**2)
      temp15 = koft_ice*denice_ice
      temp14 = pi_ice*beta_ice*np_ice
      temp13 = temp14*temp15
      tempb21 = 2d0*auxncb/temp13
      tempb22 = -(denair_ice*tempb21/temp13)
      denair_iceb = denair_iceb + tempb21
      beta_iceb = beta_iceb + np_ice*temp15*pi_ice*tempb22
      np_iceb = np_iceb + temp15*pi_ice*beta_ice*tempb22
      denice_iceb = denice_iceb + temp14*koft_ice*tempb22
      temp12 = 2d0*miu
      temp11 = g/temp12
      tempb24 = pi_ice*0.5d0*(pi_ice*temp11)**(-0.5D0)*g*phidob/(miu*&
&       temp12)
      tempb25 = (pi_ice*temp11)**0.5d0*phidob/miu
      gb = tempb25 + tempb24
      miub = -(g*tempb25/miu) - temp11*2d0*tempb24
      temp10 = wpar_ice*koft_ice
      tempb26 = fds*alfa_ice*temp10*miub/shom_ice
      temp9 = (shom_ice+1d0)/shom_ice
      tempb27 = temp9*miub
      tempb23 = fds*alfa_ice*tempb27
      koft_iceb = koft_iceb + wpar_ice*tempb23 + temp14*denice_ice*&
&       tempb22
      shom_iceb = shom_iceb + (1.0_8-temp9)*tempb26
      fdsb = temp10*alfa_ice*tempb27
      alfa_iceb = alfa_iceb + temp10*fds*tempb27
      wpar_iceb = wpar_iceb + koft_ice*tempb23
      waux_iceb = 0.0_8
    ELSE
      IF (branch .EQ. 1) THEN
        CALL POPREAL8(dsh)
        CALL POPREAL8(dbc_ice)
        smaxb = 0.0_8
        dshb = 0.0_8
        waux_iceb = 0.0_8
        CALL INSPEC_ICE_B(smax, smaxb, t_ice, t_iceb, nhet, nhetb, dsh, &
&                   dshb)
      ELSE
        nin_iceb = nin_iceb + nhetb
        waux_iceb = 0.0_8
        smaxb = 0.0_8
      END IF
      shalfb = smaxb
      nearzerob = -(shalfb/nearzerod)
      nearzerodb = nearzero*shalfb/nearzerod**2
      CALL POPREAL8(dbc_ice)
      CALL FINDSMAX_D_B(t_ice, t_iceb, wpar_ice, wpar_iceb, ssconv_ice, &
&                 1d0, nearzero2, nearzerod, nearzerodb)
      CALL POPREAL8(dbc_ice)
      CALL FINDSMAX_B(t_ice, t_iceb, wpar_ice, wpar_iceb, ssconv_ice, &
&               nearzero, nearzerob)
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        gb = 0.0_8
        nstarb = 0.0_8
        gamb = 0.0_8
        GOTO 100
      ELSE IF (branch .EQ. 1) THEN
        gb = 0.0_8
        nstarb = 0.0_8
        gamb = 0.0_8
        GOTO 100
      ELSE
        gb = 0.0_8
        nhet_b = 0.0_8
        fdsb = 0.0_8
      END IF
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(nhet_)
      nhet_b = 0.0_8
      fdsb = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) fdsb = 0.0_8
    tempb20 = -(1.5d0*(nhet_/nlim)**0.5D0*fdsb/nlim)
    nhet_b = nhet_b + tempb20
    nlimb = -(nhet_*tempb20/nlim)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      temp4 = shom_ice*result1*sizecorr
      tempb5 = nlimb/temp4
      tempb6 = -(nstar*(shom_ice+1d0)*tempb5/temp4)
      nstarb = (shom_ice+1d0)*tempb5
      result1b = sizecorr*shom_ice*tempb6
      sizecorrb = shom_ice*result1*tempb6
      IF (dstar .EQ. 0.0) THEN
        dstarb = 0.0
      ELSE
        dstarb = result1b/(2.0*SQRT(dstar))
      END IF
      tempb10 = dstarb/(shom_ice-dsh+1d0)
      tempb7 = 2d0*dsh*tempb10
      tempb8 = -((4d0*(dsh**2/3d0)+2d0*(dsh*(shom_ice-dsh)))*tempb10/(&
&       shom_ice-dsh+1d0))
      dshb = (2d0*(shom_ice-dsh)+4d0*2*dsh/3d0)*tempb10 - tempb7 - &
&       tempb8
      temp2 = lambda_ice*shom_ice
      temp3 = 2d0/temp2
      tempb9 = EXP(-temp3)*temp3*sizecorrb/temp2
      shom_iceb = shom_iceb + tempb7 + tempb8 + lambda_ice*tempb9 + &
&       sizecorr*result1*tempb6 + nstar*tempb5
      CALL POPREAL8(result1)
      lambda_iceb = lambda_iceb + shom_ice*tempb9
      CALL POPREAL8(dbc_ice)
      CALL INSPEC_ICE_B(shom_ice, shom_iceb, t_ice, t_iceb, nhet_, &
&                 nhet_b, dsh, dshb)
      gamb = 0.0_8
    ELSE
      nin_iceb = nin_iceb + nhet_b
      CALL POPREAL8(nlim)
      temp8 = dlim**2
      temp7 = nlim/temp8
      tempb11 = temp7*nlimb
      tempb12 = (g1_ice*dlim+g2_ice)*nlimb/temp8
      dlimb = g1_ice*tempb11 - temp7*2*dlim*tempb12
      g2_iceb = g2_iceb + tempb11
      nlimb = tempb12
      temp6 = z_ice*beta_ice*shom_ice
      tempb14 = nlimb/temp6
      tempb15 = -(alfa_ice*wpar_ice*(shom_ice+1d0)*tempb14/temp6)
      z_iceb = z_iceb + shom_ice*beta_ice*tempb15
      beta_iceb = beta_iceb + shom_ice*z_ice*tempb15
      result1b = dlimb
      arg1 = gam*gam + 2d0*dstar/g1_ice/alfa_ice/wpar_ice
      CALL POPREAL8(result1)
      IF (arg1 .EQ. 0.0) THEN
        arg1b = 0.0
      ELSE
        arg1b = result1b/(2.0*SQRT(arg1))
      END IF
      gamb = 2*gam*arg1b - dlimb
      temp5 = g1_ice*alfa_ice*wpar_ice
      tempb18 = 2d0*arg1b/temp5
      tempb13 = -(dstar*tempb18/temp5)
      g1_iceb = g1_iceb + wpar_ice*alfa_ice*tempb13 + dlim*tempb11
      alfa_iceb = alfa_iceb + wpar_ice*g1_ice*tempb13 + (shom_ice+1d0)*&
&       wpar_ice*tempb14
      wpar_iceb = wpar_iceb + g1_ice*alfa_ice*tempb13 + (shom_ice+1d0)*&
&       alfa_ice*tempb14
      dstarb = tempb18
      tempb19 = dstarb/(shom_ice-dsh+1d0)
      tempb16 = 2d0*dsh*tempb19
      tempb17 = -((4d0*(dsh**2/3d0)+2d0*(dsh*(shom_ice-dsh)))*tempb19/(&
&       shom_ice-dsh+1d0))
      dshb = (2d0*(shom_ice-dsh)+4d0*2*dsh/3d0)*tempb19 - tempb16 - &
&       tempb17
      shom_iceb = shom_iceb + tempb16 + tempb17 + dshb + z_ice*beta_ice*&
&       tempb15 + alfa_ice*wpar_ice*tempb14
      nstarb = 0.0_8
    END IF
 100 temp = aux1*g1_ice**2
    tempb = 1.3346d0*gb/temp
    tempb3 = -((g1_ice*aux1-g2_ice*aux2)*tempb/temp)
    aux2b = -(g2_ice*tempb)
    arg1 = (g2_ice+g1_ice*dpmax)/(g2_ice+g1_ice*dliq_ice)
    arg1b = aux2b/arg1
    tempb1 = arg1b/(g2_ice+g1_ice*dliq_ice)
    tempb0 = -((g2_ice+g1_ice*dpmax)*tempb1/(g2_ice+g1_ice*dliq_ice))
    CALL POPREAL8(lambda_ice)
    result1b = -(lambda_ice*lambda_iceb/result1**2)
    temp1 = result10*beta_ice*z_ice
    temp0 = g1_ice*alfa_ice*wpar_ice
    tempb2 = 1.5d0*temp0**0.5D0*nstarb/temp1
    g2_iceb = g2_iceb + tempb0 - aux2*tempb + tempb1 + gamb/g1_ice
    g1_iceb = g1_iceb + wpar_ice*alfa_ice*tempb2 + dpmax*tempb1 + &
&     dliq_ice*tempb0 + aux1*2*g1_ice*tempb3 + aux1*tempb - g2_ice*gamb/&
&     g1_ice**2
    tempb4 = -(temp0**1.5d0*nstarb/temp1**2)
    alfa_iceb = alfa_iceb + wpar_ice*g1_ice*tempb2
    IF (wpar_ice .EQ. 0.0) THEN
      wpar_iceb = wpar_iceb + g1_ice*alfa_ice*tempb2
    ELSE
      wpar_iceb = wpar_iceb + result1b/(2.0*SQRT(wpar_ice)) + g1_ice*&
&       alfa_ice*tempb2
    END IF
    beta_iceb = beta_iceb + z_ice*result10*tempb4
    z_iceb = z_iceb + result10*beta_ice*tempb4
    lambda_iceb = lambda_iceb/result1
    CALL POPREAL8(result1)
    aux1b = g1_ice**2*tempb3 + g1_ice*tempb
    dpmaxb = aux1b + g1_ice*tempb1
    dliq_iceb = dliq_iceb + g1_ice*tempb0 - aux1b
    CALL POPREAL8(aux1)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      dpminb = dpmaxb
      dpmaxb = 0.0_8
    ELSE
      dpminb = 0.0_8
    END IF
    dliq_iceb = dliq_iceb + dpminb
    result1b = -(0.02*dpminb/result1**2)
    arg1 = alfa_ice*wpar_ice*g1_ice
    IF (arg1 .EQ. 0.0) THEN
      arg1b = 0.0
    ELSE
      arg1b = result1b/(2.0*SQRT(arg1))
    END IF
    alfa_iceb = alfa_iceb + g1_ice*wpar_ice*arg1b
    wpar_iceb = wpar_iceb + g1_ice*alfa_ice*arg1b
    g1_iceb = g1_iceb + alfa_ice*wpar_ice*arg1b
    CALL POPCONTROL2B(branch)
    IF (branch .EQ. 0) THEN
      aux1 = 1.6397d-14*t_ice - 3.1769d-12
      dpmaxb = 0.0_8
    ELSE IF (branch .NE. 1) THEN
      GOTO 110
    END IF
    aux1b = pwr2*pwr1*dpmaxb
    pwr1b = pwr2*aux1*dpmaxb
    pwr2b = aux1*pwr1*dpmaxb
    wpar_iceb = wpar_iceb - 0.05*wpar_ice**(-1.05)*pwr2b
    monvolb = -(0.373d0*monvol**(-1.373D0)*pwr1b)
    t_iceb = t_iceb + 1.6397d-14*aux1b
    np_iceb = np_iceb + 1.0d-6*ddry_ice**3*monvolb
    ddry_iceb = ddry_iceb + np_ice*1.0d-6*3*ddry_ice**2*monvolb
 110 CONTINUE
  END SUBROUTINE NICE_PARAM_MOD_B
  SUBROUTINE NICE_PARAM_MOD(wpar_ice, t_ice, p_ice, nice, smax, nhet, &
&   nlim_)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: t_ice, p_ice, wpar_ice
    REAL*8, INTENT(OUT) :: nice, smax, nhet, nlim_
    REAL*8 :: aux1, aux2, g, dpmax, miu, monvol, fds, nlim, dlim, dstar&
&   , ds, nstar, nhom, fc, phido, auxnc, sizecorr, dsh, nhet_, f1, f2, &
&   saux, sup, slow, shalf, fhalf, dpmin, gam
    INTEGER :: index
    INTRINSIC SQRT
    INTRINSIC MAX
    INTRINSIC DLOG
    INTRINSIC EXP
    INTRINSIC MIN
    INTRINSIC SIGN
    INTRINSIC ABS
    REAL*8 :: pwr1
    REAL*8 :: pwr2
    REAL*8 :: arg1
    REAL*8 :: result1
    DOUBLE PRECISION :: result10
    REAL*8 :: abs0
    REAL*8 :: nearzero, nearzero2, nearzerod
    IF (np_ice .GT. 1.0) THEN
      monvol = np_ice*1.0d-6*ddry_ice*ddry_ice*ddry_ice
      aux1 = 1.6397d-14*t_ice - 3.1769d-12
      pwr1 = monvol**(-0.373d0)
      pwr2 = wpar_ice**(-0.05)
      dpmax = aux1*pwr1*pwr2
      IF (dpmax .GT. 1.0d-4) dpmax = 1.0d-4
    ELSE
      dpmax = 1.0d-4
    END IF
    pice = p_ice
!MInimum size for DPmax (added on 09/11/09)
    arg1 = alfa_ice*wpar_ice*g1_ice
    result1 = SQRT(arg1)
    dpmin = dliq_ice + 0.02/result1
    IF (dpmax .LT. dpmin) THEN
      dpmax = dpmin
    ELSE
      dpmax = dpmax
    END IF
    aux1 = dpmax - dliq_ice
    arg1 = (g2_ice+g1_ice*dpmax)/(g2_ice+g1_ice*dliq_ice)
    aux2 = DLOG(arg1)
    g = 1.3346d0*(g1_ice*aux1-g2_ice*aux2)/(aux1*g1_ice*g1_ice)
    result1 = SQRT(wpar_ice)
    lambda_ice = lambda_ice/result1
    result10 = SQRT(2d0)
    nstar = (g1_ice*alfa_ice*wpar_ice)**1.5d0/beta_ice/z_ice/result10
    gam = g2_ice/g1_ice
!*********IS HOMOGENEOUS FREEZING HAPPENING?********************
!CORRECTION TO Nc FROM HET FREEZING
    fds = 1d0
    nhom = 0d0
    IF (t_ice .GE. 235d0) THEN
!no homogeneous above 235 K
      nhom = 0d0
    ELSE IF (purehet_ice) THEN
      nhom = 0d0
    ELSE
!calculate limiting NIN for combined hom_het    
      IF (typeofspec_ice .GE. 0d0) THEN
!polydisperse expressions
        CALL INSPEC_ICE(shom_ice, t_ice, nhet_, dsh)
        sizecorr = EXP(-(2d0/lambda_ice/shom_ice))
        dstar = (4d0*dsh*dsh/3d0+2d0*dsh*(shom_ice-dsh))/(shom_ice-dsh+&
&         1d0)
        result1 = SQRT(dstar)
        nlim = nstar*(shom_ice+1d0)/shom_ice/result1/sizecorr
      ELSE
!monodisperse approximation
        dsh = shom_ice - sh_ice
        dstar = (4d0*dsh*dsh/3d0+2d0*dsh*(shom_ice-dsh))/(shom_ice-dsh+&
&         1d0)
        arg1 = gam*gam + 2d0*dstar/g1_ice/alfa_ice/wpar_ice
        result1 = SQRT(arg1)
        dlim = -gam + result1
        nlim = alfa_ice*wpar_ice*(shom_ice+1d0)/z_ice/beta_ice/shom_ice
        nlim = nlim*(g1_ice*dlim+g2_ice)/dlim/dlim
        nhet_ = nin_ice
      END IF
      IF (nlim .GT. 1d10) THEN
        nlim_ = 1d10
      ELSE
        nlim_ = nlim
      END IF
      IF (nlim .LT. 1d-6) THEN
        nlim_ = 1d-6
      ELSE
        nlim_ = nlim
      END IF
      fds = 1d0 - (nhet_/nlim)**1.5d0
      IF (fds .NE. fds) fds = 1d0
      IF (purehom_ice) THEN
        nhet_ = 0d0
        fds = 1.0d0
      END IF
      IF (fds .LE. 0d0) THEN
!Homogeneous nucleation completely inhibited by IN
        nhom = 0d0
      ELSE
!********FRACTION OF FROZEN DROPLETS********************
        miu = fds*alfa_ice*(shom_ice+1d0)*wpar_ice*koft_ice/shom_ice
        phido = (pi_ice*g/miu/2d0)**0.5d0*(g/miu)
        auxnc = 2d0*denair_ice/beta_ice/koft_ice/denice_ice/pi_ice/&
&         np_ice
        fc = auxnc/phido
!calculating hom Nc
        IF (np_ice .GT. 0d0) THEN
          IF (fc .LE. 0.6d0) THEN
            nhom = np_ice*EXP(-fc)*(1.0d0-EXP(-fc))
          ELSE
!correction needed for convective clouds (very high updraft) (Barahona et al. JGR, 2011)
            arg1 = (9d0-2*fc)/7d0
            nhom = np_ice/(1d0+EXP(arg1))
          END IF
        ELSE
          nhom = 0d0
        END IF
        smax = shom_ice
        nhet = nhet_
        GOTO 686
      END IF
    END IF
!finish	
!********PURE HETEROEGENEOUS FREEZING********************
!find interval for bisection
!    smax = 0d0
!    nhet = 0d0
!    saux = 0.01d0
!    IF (typeofspec_ice .LT. 0d0) saux = sh_ice + 0.00000000001d0
!!minimun smax in monodisperse case
!    CALL FINDSMAX(t_ice, wpar_ice, saux, f1)
!    DO index=1,120
!      IF (saux + 1d0 .GE. vpresw_ice/vpresi_ice) THEN
!!limit to below water saturation new2
!        shalf = vpresw_ice/vpresi_ice - 1.0
!        GOTO 678
!      ELSE
!        saux = saux + 0.1d0
!        CALL FINDSMAX(t_ice, wpar_ice, saux, f2)
!        IF (f2*f1 .LT. 0d0) THEN
!          GOTO 677
!        ELSE
!          f2 = f1
!        END IF
!      END IF
!    END DO
!    IF (f2*f1 .GT. 0d0) THEN
!      nhet = 0d0
!!No NIN present in pure heterogeneous mode smax>200%
!      smax = saux
!      GOTO 686
!    END IF
!!Perform bisection
! 677 sup = saux
!    slow = saux - 0.1d0
!    DO index=1,100
!      shalf = 0.5d0*(sup+slow)
!      CALL FINDSMAX(t_ice, wpar_ice, shalf, fhalf)
!      IF (SIGN(1.d0, f1)*SIGN(1.d0, fhalf) .LE. 0d0) THEN
!        f2 = fhalf
!        sup = shalf
!      ELSE
!        f1 = fhalf
!        slow = shalf
!      END IF
!      IF (slow - sup .GE. 0.) THEN
!        abs0 = slow - sup
!      ELSE
!        abs0 = -(slow-sup)
!      END IF
!      IF (abs0 .LE. 1d-10) GOTO 678
!    END DO
    CALL FINDSMAX(t_ice, wpar_ice, ssconv_ice, nearzero)
    CALL FINDSMAX_D(t_ice, wpar_ice, ssconv_ice, 1d0, nearzero2, &
&             nearzerod)
    shalf = ssconv_ice - nearzero/nearzerod
    smax = shalf
    IF (typeofspec_ice .GE. 0d0) THEN
      CALL INSPEC_ICE(smax, t_ice, nhet, dsh)
    ELSE
!monodisperse approximation
      nhet = nin_ice
    END IF
 686 IF (nhet .NE. nhet) nhet = 0d0
!avoiding errors
    IF (nhom .NE. nhom) nhom = 0d0
!avoiding errors
    nice = nhom + nhet
    IF (smax + 1.0 - dsh .LT. 1.0) THEN
      sc_ice = 1.0
    ELSE
      sc_ice = smax + 1.0 - dsh
    END IF
    IF (shom_ice + 1.0 .GT. sc_ice) THEN
      sc_ice = sc_ice
    ELSE
      sc_ice = shom_ice + 1.0
    END IF
    RETURN
  END SUBROUTINE NICE_PARAM_MOD
!  Differentiation of findsmax_d in reverse (adjoint) mode:
!   gradient     of useful results: dtnuc_dhf waux_ice abc_dep
!                g1_ice norg_ice del1bc_ice del1dust_ice dtnuc_dep
!                aimm dact_imm g2_ice beta_ice si0dust_ice si0bc_ice
!                lambda_ice lmeff_ice vw_ice kdust_ice ndust_ice
!                dorg_ice alfa_ice adust_dep kbc_ice denice_ice
!                vpresw_ice gdoin_ice vpresi_ice dbc_ice z_ice
!                nin_ice ddust_ice nbc_ice wpar_icef nearzerod
!                tf
!   with respect to varying inputs: dtnuc_dhf waux_ice abc_dep
!                g1_ice norg_ice del1bc_ice del1dust_ice dtnuc_dep
!                aimm dact_imm g2_ice beta_ice si0dust_ice si0bc_ice
!                lambda_ice lmeff_ice vw_ice kdust_ice ndust_ice
!                dorg_ice alfa_ice adust_dep kbc_ice denice_ice
!                vpresw_ice gdoin_ice vpresi_ice dbc_ice z_ice
!                nin_ice ddust_ice nbc_ice wpar_icef tf
!  Differentiation of findsmax in forward (tangent) mode:
!   variations   of useful results: nearzero
!   with respect to varying inputs: sxf
!   RW status of diff variables: sigiw_ice:(loc) dh1smooth:(loc)
!                rsc_ice:(loc) sxf:in nearzero:out
  SUBROUTINE FINDSMAX_D_B(tf, tfb, wpar_icef, wpar_icefb, sxf, sxfd, &
&   nearzero, nearzerod, nearzerodb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: sxf, wpar_icef, tf
    REAL*8 :: wpar_icefb, tfb
    REAL*8, INTENT(IN) :: sxfd
    REAL*8, INTENT(OUT) :: nearzero
    REAL*8 :: nearzerod
    REAL*8 :: nearzerodb
    REAL*8 :: sizecorrf, dstarf, taof, dlimf, nhet_f, dshf, gam, nstar
    REAL*8 :: sizecorrfb, dstarfb, taofb, dlimfb, nhet_fb, dshfb, gamb, &
&   nstarb
    REAL*8 :: sizecorrfd, dstarfd, taofd, dlimfd, nhet_fd, dshfd
    REAL*8 :: sizecorrfdb, dstarfdb, taofdb, dlimfdb, nhet_fdb, dshfdb
    INTRINSIC SQRT
    INTRINSIC EXP
    DOUBLE PRECISION :: result1
    REAL*8 :: result10
    REAL*8 :: result10b
    REAL*8 :: result10d
    REAL*8 :: result10db
    REAL*8 :: arg1
    REAL*8 :: arg1b
    REAL*8 :: arg1d
    REAL*8 :: arg1db
    INTEGER :: branch
    REAL*8 :: temp3
    REAL*8 :: temp2
    REAL*8 :: temp1
    REAL*8 :: temp0
    REAL*8 :: temp21
    REAL*8 :: temp20
    REAL*8 :: tempb9
    REAL*8 :: tempb8
    REAL*8 :: tempb7
    REAL*8 :: tempb6
    REAL*8 :: tempb5
    REAL*8 :: tempb4
    REAL*8 :: tempb19
    REAL*8 :: tempb3
    REAL*8 :: tempb18
    REAL*8 :: tempb2
    REAL*8 :: tempb17
    REAL*8 :: tempb1
    REAL*8 :: tempb16
    REAL*8 :: tempb0
    REAL*8 :: tempb15
    REAL*8 :: tempb14
    REAL*8 :: tempb13
    REAL*8 :: tempb12
    REAL*8 :: tempb11
    REAL*8 :: tempb10
    REAL*8 :: temp19
    REAL*8 :: temp18
    REAL*8 :: temp17
    REAL*8 :: temp16
    REAL*8 :: temp15
    REAL*8 :: temp14
    REAL*8 :: temp13
    REAL*8 :: temp12
    REAL*8 :: temp11
    REAL*8 :: temp10
    REAL*8 :: tempb
    REAL*8 :: tempb31
    REAL*8 :: tempb30
    REAL*8 :: tempb29
    REAL*8 :: tempb28
    REAL*8 :: tempb27
    REAL*8 :: tempb26
    REAL*8 :: tempb25
    REAL*8 :: temp
    REAL*8 :: tempb24
    REAL*8 :: tempb23
    REAL*8 :: tempb22
    REAL*8 :: temp9
    REAL*8 :: tempb21
    REAL*8 :: temp8
    REAL*8 :: tempb20
    REAL*8 :: temp7
    REAL*8 :: temp6
    REAL*8 :: temp5
    REAL*8 :: temp4
    result1 = SQRT(2d0)
    nstar = (g1_ice*alfa_ice*wpar_icef)**1.5d0/(beta_ice*z_ice*result1)
    gam = g2_ice/g1_ice
    IF (typeofspec_ice .GE. 0d0) THEN
!polydisperse expressions
      CALL PUSHREAL8(dbc_ice)
      CALL INSPEC_ICE_D(sxf, sxfd, tf, nhet_f, nhet_fd, dshf, dshfd)
      sizecorrfd = 2d0*sxfd*EXP(-(2d0/lambda_ice/sxf))/(lambda_ice*sxf**&
&       2)
      sizecorrf = EXP(-(2d0/lambda_ice/sxf))
      dstarfd = ((4d0*(dshfd*dshf+dshf*dshfd)/3d0+2d0*(dshfd*(sxf-dshf)+&
&       dshf*(sxfd-dshfd)))*(sxf-dshf+1d0)-(4d0*dshf*dshf/3d0+2d0*dshf*(&
&       sxf-dshf))*(sxfd-dshfd))/(sxf-dshf+1d0)**2
      dstarf = (4d0*dshf*dshf/3d0+2d0*dshf*(sxf-dshf))/(sxf-dshf+1d0)
      dstarf = dstarf + gdoin_ice*alfa_ice*wpar_icef
      IF (dstarf .EQ. 0.0) THEN
        result10d = 0.0_8
        CALL PUSHCONTROL1B(0)
      ELSE
        result10d = dstarfd/(2.0*SQRT(dstarf))
        CALL PUSHCONTROL1B(1)
      END IF
      result10 = SQRT(dstarf)
      CALL PUSHCONTROL1B(0)
    ELSE
!monodisperse approximation
      dshfd = sxfd
      dshf = sxf - sh_ice
      dstarfd = ((4d0*(dshfd*dshf+dshf*dshfd)/3d0+2d0*(dshfd*(sxf-dshf)+&
&       dshf*(sxfd-dshfd)))*(sxf-dshf+1d0)-(4d0*dshf*dshf/3d0+2d0*dshf*(&
&       sxf-dshf))*(sxfd-dshfd))/(sxf-dshf+1d0)**2
      dstarf = (4d0*dshf*dshf/3d0+2d0*dshf*(sxf-dshf))/(sxf-dshf+1d0)
      arg1d = 2d0*dstarfd/g1_ice/alfa_ice/wpar_icef
      arg1 = gam*gam + 2d0*dstarf/g1_ice/alfa_ice/wpar_icef
      IF (arg1 .EQ. 0.0) THEN
        result10d = 0.0_8
        CALL PUSHCONTROL1B(0)
      ELSE
        result10d = arg1d/(2.0*SQRT(arg1))
        CALL PUSHCONTROL1B(1)
      END IF
      result10 = SQRT(arg1)
      dlimfd = result10d
      dlimf = -gam + result10
      taofd = (alfa_ice*wpar_icef*sxfd*sxf/(z_ice*beta_ice)-alfa_ice*&
&       wpar_icef*(sxf+1d0)*sxfd/(z_ice*beta_ice))/sxf**2
      taof = alfa_ice*wpar_icef*(sxf+1d0)/z_ice/beta_ice/sxf
      CALL PUSHCONTROL1B(1)
    END IF
    taofdb = -nearzerodb
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      temp11 = (sxf+1d0)**2*nstar
      tempb9 = taofdb/temp11
      temp10 = sxfd*result10 + sxf*result10d
      temp9 = nhet_fd*sizecorrf + nhet_f*sizecorrfd
      tempb10 = (sxf+1d0)*tempb9
      tempb11 = sxf*result10*tempb10
      tempb12 = nhet_f*sizecorrf*tempb10
      tempb13 = -(sxf*sxfd*tempb9)
      nhet_fdb = sizecorrf*tempb11
      sizecorrfb = result10*nhet_f*tempb13 + temp10*nhet_f*tempb10 + &
&       nhet_fd*tempb11
      nhet_fb = result10*sizecorrf*tempb13 + temp10*sizecorrf*tempb10 + &
&       sizecorrfd*tempb11
      sizecorrfdb = nhet_f*tempb11
      result10b = nhet_f*sizecorrf*tempb13 + sxfd*tempb12 + sxf*temp9*&
&       tempb10
      result10db = sxf*tempb12
      nstarb = -(((sxf+1d0)*(sxf*(temp9*result10)+nhet_f*sizecorrf*&
&       temp10)-sxf*sxfd*(nhet_f*sizecorrf*result10))*(sxf+1d0)**2*&
&       tempb9/temp11)
      IF (dstarf .EQ. 0.0) THEN
        dstarfb = 0.0
      ELSE
        dstarfb = result10b/(2.0*SQRT(dstarf))
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        dstarfdb = 0.0_8
      ELSE
        temp8 = SQRT(dstarf)
        tempb8 = result10db/(2.0*temp8)
        dstarfdb = tempb8
        IF (.NOT.dstarf .EQ. 0.0) dstarfb = dstarfb - dstarfd*tempb8/(&
&           2.0*temp8**2)
      END IF
      temp3 = sxf**2*lambda_ice
      temp2 = sxf*lambda_ice
      temp1 = 2d0/temp2
      tempb7 = sxfd*2d0*sizecorrfdb/temp3
      temp7 = 4d0*dshf**2/3d0 + 2d0*dshf*(sxf-dshf)
      tempb4 = dstarfdb/(sxf-dshf+1d0)**2
      tempb6 = (sxf-dshf+1d0)*tempb4
      tempb2 = 4d0*tempb6/3d0
      tempb3 = 2d0*tempb6
      temp6 = 4d0*(dshfd*dshf+dshf*dshfd)/3d0 + 2d0*(dshfd*(sxf-dshf)+&
&       dshf*(sxfd-dshfd))
      tempb5 = -((sxfd-dshfd)*tempb4)
      gdoin_iceb = gdoin_iceb + wpar_icef*alfa_ice*dstarfb
      alfa_iceb = alfa_iceb + wpar_icef*gdoin_ice*dstarfb
      wpar_icefb = wpar_icefb + gdoin_ice*alfa_ice*dstarfb
      tempb1 = dstarfb/(sxf-dshf+1d0)
      dshfb = 2*dshfd*tempb2 + (sxfd-2*dshfd)*tempb3 + (2*(temp6*(sxf-&
&       dshf+1d0)-temp7*(sxfd-dshfd))/(sxf-dshf+1d0)-temp6)*tempb4 + (&
&       2d0*(sxf-dshf)-dshf*2d0+4d0*2*dshf/3d0)*tempb5 + ((4d0*(dshf**2/&
&       3d0)+2d0*(dshf*(sxf-dshf)))/(sxf-dshf+1d0)-dshf*2d0+2d0*(sxf-&
&       dshf)+4d0*2*dshf/3d0)*tempb1
      dshfdb = temp7*tempb4 + (sxf-2*dshf)*tempb3 + 2*dshf*tempb2
      temp5 = sxf*lambda_ice
      temp4 = 2d0/temp5
      lambda_iceb = lambda_iceb + (temp1*EXP(-temp1)*sxf/temp2-EXP(-&
&       temp1)*sxf**2/temp3)*tempb7 + temp4*EXP(-temp4)*sxf*sizecorrfb/&
&       temp5
      CALL POPREAL8(dbc_ice)
      CALL INSPEC_ICE_D_B(sxf, sxfd, tf, tfb, nhet_f, nhet_fb, nhet_fd, &
&                   nhet_fdb, dshf, dshfb, dshfd, dshfdb)
      gamb = 0.0_8
    ELSE
      temp20 = dlimf**2*nin_ice
      tempb17 = taofdb/temp20
      tempb18 = tempb17/dlimf
      tempb19 = dlimf*tempb18
      tempb20 = taofd*tempb19
      temp17 = taofd*(g1_ice*dlimf+g2_ice) + taof*g1_ice*dlimfd
      tempb21 = -(taof*dlimfd*tempb18)
      temp18 = g1_ice*dlimf + g2_ice
      temp21 = temp17*dlimf - temp18*taof*dlimfd
      temp16 = temp21/dlimf
      temp19 = taof*dlimfd/dlimf
      tempb22 = -(temp19*tempb17)
      tempb23 = -((g1_ice*dlimf+g2_ice)*tempb17/dlimf)
      tempb24 = -((temp16-(g1_ice*dlimf+g2_ice)*temp19)*tempb17/temp20)
      g1_iceb = g1_iceb + dlimf*tempb22 + dlimf*tempb21 + dlimfd*taof*&
&       tempb19 + dlimf*tempb20
      dlimfb = nin_ice*2*dlimf*tempb24 - temp19*tempb23 + g1_ice*tempb22&
&       + g1_ice*tempb21 + (temp17-temp16)*tempb18 + g1_ice*tempb20
      g2_iceb = g2_iceb + tempb22 + tempb21 + tempb20
      taofb = dlimfd*tempb23 - temp18*dlimfd*tempb18 + dlimfd*g1_ice*&
&       tempb19
      dlimfdb = taof*tempb23 - temp18*taof*tempb18 + taof*g1_ice*tempb19
      nin_iceb = nin_iceb + dlimf**2*tempb24
      taofdb = (g1_ice*dlimf+g2_ice)*tempb19
      temp15 = sxf*z_ice*beta_ice
      tempb25 = (sxf+1d0)*taofb/temp15
      tempb26 = -(alfa_ice*wpar_icef*tempb25/temp15)
      tempb31 = taofdb/sxf**2
      tempb27 = sxfd*sxf*tempb31/(z_ice*beta_ice)
      tempb29 = -(alfa_ice*wpar_icef*tempb27/(z_ice*beta_ice))
      tempb28 = -((sxf+1d0)*sxfd*tempb31/(z_ice*beta_ice))
      alfa_iceb = alfa_iceb + wpar_icef*tempb27 + wpar_icef*tempb28 + &
&       wpar_icef*tempb25
      wpar_icefb = wpar_icefb + alfa_ice*tempb27 + alfa_ice*tempb28 + &
&       alfa_ice*tempb25
      tempb30 = -(alfa_ice*wpar_icef*tempb28/(z_ice*beta_ice))
      z_iceb = z_iceb + beta_ice*tempb29 + beta_ice*tempb30 + beta_ice*&
&       sxf*tempb26
      beta_iceb = beta_iceb + z_ice*tempb29 + z_ice*tempb30 + sxf*z_ice*&
&       tempb26
      result10b = dlimfb
      gamb = -dlimfb
      result10db = dlimfdb
      IF (arg1 .EQ. 0.0) THEN
        arg1b = 0.0
      ELSE
        arg1b = result10b/(2.0*SQRT(arg1))
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        arg1db = 0.0_8
      ELSE
        temp14 = SQRT(arg1)
        tempb16 = result10db/(2.0*temp14)
        arg1db = tempb16
        IF (.NOT.arg1 .EQ. 0.0) arg1b = arg1b - arg1d*tempb16/(2.0*&
&           temp14**2)
      END IF
      temp12 = g1_ice*alfa_ice*wpar_icef
      tempb15 = -(dstarfd*2d0*arg1db/temp12**2)
      temp13 = g1_ice*alfa_ice*wpar_icef
      tempb14 = -(dstarf*2d0*arg1b/temp13**2)
      gamb = gamb + 2*gam*arg1b
      g1_iceb = g1_iceb + wpar_icef*alfa_ice*tempb15 + wpar_icef*&
&       alfa_ice*tempb14
      alfa_iceb = alfa_iceb + wpar_icef*g1_ice*tempb15 + wpar_icef*&
&       g1_ice*tempb14
      wpar_icefb = wpar_icefb + g1_ice*alfa_ice*tempb15 + g1_ice*&
&       alfa_ice*tempb14
      nstarb = 0.0_8
    END IF
    temp0 = result1*beta_ice*z_ice
    temp = g1_ice*alfa_ice*wpar_icef
    tempb = 1.5d0*temp**0.5D0*nstarb/temp0
    g2_iceb = g2_iceb + gamb/g1_ice
    g1_iceb = g1_iceb + wpar_icef*alfa_ice*tempb - g2_ice*gamb/g1_ice**2
    tempb0 = -(temp**1.5d0*nstarb/temp0**2)
    alfa_iceb = alfa_iceb + wpar_icef*g1_ice*tempb
    wpar_icefb = wpar_icefb + g1_ice*alfa_ice*tempb
    beta_iceb = beta_iceb + z_ice*result1*tempb0
    z_iceb = z_iceb + result1*beta_ice*tempb0
  END SUBROUTINE FINDSMAX_D_B
!  Differentiation of findsmax in forward (tangent) mode:
!   variations   of useful results: nearzero
!   with respect to varying inputs: sxf
!   RW status of diff variables: sigiw_ice:(loc) dh1smooth:(loc)
!                rsc_ice:(loc) sxf:in nearzero:out
  SUBROUTINE FINDSMAX_D(tf, wpar_icef, sxf, sxfd, nearzero, nearzerod)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: sxf, wpar_icef, tf
    REAL*8, INTENT(IN) :: sxfd
    REAL*8, INTENT(OUT) :: nearzero
    REAL*8, INTENT(OUT) :: nearzerod
    REAL*8 :: sizecorrf, dstarf, taof, dlimf, nhet_f, dshf, gam, nstar
    REAL*8 :: sizecorrfd, dstarfd, taofd, dlimfd, nhet_fd, dshfd
    INTRINSIC SQRT
    INTRINSIC EXP
    DOUBLE PRECISION :: result1
    REAL*8 :: result10
    REAL*8 :: result10d
    REAL*8 :: arg1
    REAL*8 :: arg1d
    result1 = SQRT(2d0)
    nstar = (g1_ice*alfa_ice*wpar_icef)**1.5d0/(beta_ice*z_ice*result1)
    gam = g2_ice/g1_ice
    IF (typeofspec_ice .GE. 0d0) THEN
!polydisperse expressions
      CALL INSPEC_ICE_D(sxf, sxfd, tf, nhet_f, nhet_fd, dshf, dshfd)
      sizecorrfd = 2d0*sxfd*EXP(-(2d0/lambda_ice/sxf))/(lambda_ice*sxf**&
&       2)
      sizecorrf = EXP(-(2d0/lambda_ice/sxf))
      dstarfd = ((4d0*(dshfd*dshf+dshf*dshfd)/3d0+2d0*(dshfd*(sxf-dshf)+&
&       dshf*(sxfd-dshfd)))*(sxf-dshf+1d0)-(4d0*dshf*dshf/3d0+2d0*dshf*(&
&       sxf-dshf))*(sxfd-dshfd))/(sxf-dshf+1d0)**2
      dstarf = (4d0*dshf*dshf/3d0+2d0*dshf*(sxf-dshf))/(sxf-dshf+1d0)
      dstarf = dstarf + gdoin_ice*alfa_ice*wpar_icef
      IF (dstarf .EQ. 0.0) THEN
        result10d = 0.0_8
      ELSE
        result10d = dstarfd/(2.0*SQRT(dstarf))
      END IF
      result10 = SQRT(dstarf)
      taofd = (((nhet_fd*sizecorrf+nhet_f*sizecorrfd)*sxf*result10+&
&       nhet_f*sizecorrf*(sxfd*result10+sxf*result10d))*(sxf+1d0)-nhet_f&
&       *sizecorrf*sxf*result10*sxfd)/(sxf+1d0)**2/nstar
      taof = nhet_f*sizecorrf*sxf*result10/(sxf+1d0)/nstar
    ELSE
!monodisperse approximation
      dshfd = sxfd
      dshf = sxf - sh_ice
      dstarfd = ((4d0*(dshfd*dshf+dshf*dshfd)/3d0+2d0*(dshfd*(sxf-dshf)+&
&       dshf*(sxfd-dshfd)))*(sxf-dshf+1d0)-(4d0*dshf*dshf/3d0+2d0*dshf*(&
&       sxf-dshf))*(sxfd-dshfd))/(sxf-dshf+1d0)**2
      dstarf = (4d0*dshf*dshf/3d0+2d0*dshf*(sxf-dshf))/(sxf-dshf+1d0)
      arg1d = 2d0*dstarfd/g1_ice/alfa_ice/wpar_icef
      arg1 = gam*gam + 2d0*dstarf/g1_ice/alfa_ice/wpar_icef
      IF (arg1 .EQ. 0.0) THEN
        result10d = 0.0_8
      ELSE
        result10d = arg1d/(2.0*SQRT(arg1))
      END IF
      result10 = SQRT(arg1)
      dlimfd = result10d
      dlimf = -gam + result10
      taofd = (alfa_ice*wpar_icef*sxfd*sxf/(z_ice*beta_ice)-alfa_ice*&
&       wpar_icef*(sxf+1d0)*sxfd/(z_ice*beta_ice))/sxf**2
      taof = alfa_ice*wpar_icef*(sxf+1d0)/z_ice/beta_ice/sxf
      taofd = (((taofd*(g1_ice*dlimf+g2_ice)+taof*g1_ice*dlimfd)*dlimf-&
&       taof*(g1_ice*dlimf+g2_ice)*dlimfd)/dlimf-taof*(g1_ice*dlimf+&
&       g2_ice)*dlimfd/dlimf)/dlimf**2/nin_ice
      taof = taof*(g1_ice*dlimf+g2_ice)/dlimf/dlimf/nin_ice
    END IF
    nearzerod = -taofd
    nearzero = 1d0 - taof
  END SUBROUTINE FINDSMAX_D
!  Differentiation of findsmax in reverse (adjoint) mode:
!   gradient     of useful results: dtnuc_dhf waux_ice abc_dep
!                g1_ice norg_ice del1bc_ice del1dust_ice dtnuc_dep
!                aimm dact_imm g2_ice beta_ice si0dust_ice si0bc_ice
!                lambda_ice lmeff_ice vw_ice kdust_ice ndust_ice
!                dorg_ice alfa_ice adust_dep kbc_ice denice_ice
!                vpresw_ice gdoin_ice vpresi_ice dbc_ice z_ice
!                nin_ice ddust_ice nbc_ice nearzero wpar_icef tf
!   with respect to varying inputs: dtnuc_dhf waux_ice abc_dep
!                g1_ice norg_ice del1bc_ice del1dust_ice dtnuc_dep
!                aimm dact_imm g2_ice beta_ice si0dust_ice si0bc_ice
!                lambda_ice lmeff_ice vw_ice kdust_ice ndust_ice
!                dorg_ice alfa_ice adust_dep kbc_ice denice_ice
!                vpresw_ice gdoin_ice vpresi_ice dbc_ice z_ice
!                nin_ice ddust_ice nbc_ice wpar_icef tf
  SUBROUTINE FINDSMAX_B(tf, tfb, wpar_icef, wpar_icefb, sxf, nearzero, &
&   nearzerob)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: sxf, wpar_icef, tf
    REAL*8 :: sxfb, wpar_icefb, tfb
    REAL*8 :: nearzero
    REAL*8 :: nearzerob
    REAL*8 :: sizecorrf, dstarf, taof, dlimf, nhet_f, dshf, gam, nstar
    REAL*8 :: sizecorrfb, dstarfb, taofb, dlimfb, nhet_fb, dshfb, gamb, &
&   nstarb
    INTRINSIC SQRT
    INTRINSIC EXP
    DOUBLE PRECISION :: result1
    REAL*8 :: result10
    REAL*8 :: result10b
    REAL*8 :: arg1
    REAL*8 :: arg1b
    INTEGER :: branch
    REAL*8 :: temp3
    REAL*8 :: temp2
    REAL*8 :: temp1
    REAL*8 :: temp0
    REAL*8 :: tempb8
    REAL*8 :: tempb7
    REAL*8 :: tempb6
    REAL*8 :: tempb5
    REAL*8 :: tempb4
    REAL*8 :: tempb3
    REAL*8 :: tempb2
    REAL*8 :: tempb1
    REAL*8 :: tempb0
    REAL*8 :: tempb
    REAL*8 :: temp
    REAL*8 :: temp5
    REAL*8 :: temp4
    result1 = SQRT(2d0)
    nstar = (g1_ice*alfa_ice*wpar_icef)**1.5d0/(beta_ice*z_ice*result1)
    gam = g2_ice/g1_ice
    IF (typeofspec_ice .GE. 0d0) THEN
!polydisperse expressions
      CALL PUSHREAL8(dbc_ice)
      CALL INSPEC_ICE(sxf, tf, nhet_f, dshf)
      sizecorrf = EXP(-(2d0/lambda_ice/sxf))
      dstarf = (4d0*dshf*dshf/3d0+2d0*dshf*(sxf-dshf))/(sxf-dshf+1d0)
      dstarf = dstarf + gdoin_ice*alfa_ice*wpar_icef
      result10 = SQRT(dstarf)
      CALL PUSHCONTROL1B(0)
    ELSE
!monodisperse approximation
      dshf = sxf - sh_ice
      dstarf = (4d0*dshf*dshf/3d0+2d0*dshf*(sxf-dshf))/(sxf-dshf+1d0)
      arg1 = gam*gam + 2d0*dstarf/g1_ice/alfa_ice/wpar_icef
      result10 = SQRT(arg1)
      dlimf = -gam + result10
      taof = alfa_ice*wpar_icef*(sxf+1d0)/z_ice/beta_ice/sxf
      CALL PUSHCONTROL1B(1)
    END IF
    taofb = -nearzerob
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      tempb1 = sxf*taofb/((sxf+1d0)*nstar)
      nhet_fb = result10*sizecorrf*tempb1
      sizecorrfb = result10*nhet_f*tempb1
      result10b = nhet_f*sizecorrf*tempb1
      nstarb = -(nhet_f*sizecorrf*result10*tempb1/nstar)
      IF (dstarf .EQ. 0.0) THEN
        dstarfb = 0.0
      ELSE
        dstarfb = result10b/(2.0*SQRT(dstarf))
      END IF
      gdoin_iceb = gdoin_iceb + wpar_icef*alfa_ice*dstarfb
      alfa_iceb = alfa_iceb + wpar_icef*gdoin_ice*dstarfb
      wpar_icefb = wpar_icefb + gdoin_ice*alfa_ice*dstarfb
      tempb2 = dstarfb/(sxf-dshf+1d0)
      dshfb = ((4d0*(dshf**2/3d0)+2d0*(dshf*(sxf-dshf)))/(sxf-dshf+1d0)-&
&       dshf*2d0+2d0*(sxf-dshf)+4d0*2*dshf/3d0)*tempb2
      temp2 = sxf*lambda_ice
      temp1 = 2d0/temp2
      lambda_iceb = lambda_iceb + temp1*EXP(-temp1)*sxf*sizecorrfb/temp2
      CALL POPREAL8(dbc_ice)
      sxfb = 0.0_8
      CALL INSPEC_ICE_B(sxf, sxfb, tf, tfb, nhet_f, nhet_fb, dshf, dshfb&
&                )
      gamb = 0.0_8
    ELSE
      temp5 = dlimf**2*nin_ice
      tempb3 = taofb/temp5
      tempb4 = taof*tempb3
      tempb5 = -(taof*(g1_ice*dlimf+g2_ice)*tempb3/temp5)
      dlimfb = nin_ice*2*dlimf*tempb5 + g1_ice*tempb4
      g2_iceb = g2_iceb + tempb4
      nin_iceb = nin_iceb + dlimf**2*tempb5
      taofb = (g1_ice*dlimf+g2_ice)*tempb3
      temp4 = sxf*z_ice*beta_ice
      tempb7 = (sxf+1d0)*taofb/temp4
      tempb8 = -(alfa_ice*wpar_icef*tempb7/temp4)
      z_iceb = z_iceb + beta_ice*sxf*tempb8
      beta_iceb = beta_iceb + sxf*z_ice*tempb8
      result10b = dlimfb
      IF (arg1 .EQ. 0.0) THEN
        arg1b = 0.0
      ELSE
        arg1b = result10b/(2.0*SQRT(arg1))
      END IF
      gamb = 2*gam*arg1b - dlimfb
      temp3 = g1_ice*alfa_ice*wpar_icef
      tempb6 = -(dstarf*2d0*arg1b/temp3**2)
      g1_iceb = g1_iceb + wpar_icef*alfa_ice*tempb6 + dlimf*tempb4
      alfa_iceb = alfa_iceb + wpar_icef*g1_ice*tempb6 + wpar_icef*tempb7
      wpar_icefb = wpar_icefb + g1_ice*alfa_ice*tempb6 + alfa_ice*tempb7
      nstarb = 0.0_8
    END IF
    temp0 = result1*beta_ice*z_ice
    temp = g1_ice*alfa_ice*wpar_icef
    tempb = 1.5d0*temp**0.5D0*nstarb/temp0
    g2_iceb = g2_iceb + gamb/g1_ice
    g1_iceb = g1_iceb + wpar_icef*alfa_ice*tempb - g2_ice*gamb/g1_ice**2
    tempb0 = -(temp**1.5d0*nstarb/temp0**2)
    alfa_iceb = alfa_iceb + wpar_icef*g1_ice*tempb
    wpar_icefb = wpar_icefb + g1_ice*alfa_ice*tempb
    beta_iceb = beta_iceb + z_ice*result1*tempb0
    z_iceb = z_iceb + result1*beta_ice*tempb0
  END SUBROUTINE FINDSMAX_B
  SUBROUTINE FINDSMAX(tf, wpar_icef, sxf, nearzero)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: sxf, wpar_icef, tf
    REAL*8, INTENT(OUT) :: nearzero
    REAL*8 :: sizecorrf, dstarf, taof, dlimf, nhet_f, dshf, gam, nstar
    INTRINSIC SQRT
    INTRINSIC EXP
    DOUBLE PRECISION :: result1
    REAL*8 :: result10
    REAL*8 :: arg1
    result1 = SQRT(2d0)
    nstar = (g1_ice*alfa_ice*wpar_icef)**1.5d0/(beta_ice*z_ice*result1)
    gam = g2_ice/g1_ice
    IF (typeofspec_ice .GE. 0d0) THEN
!polydisperse expressions
      CALL INSPEC_ICE(sxf, tf, nhet_f, dshf)
      sizecorrf = EXP(-(2d0/lambda_ice/sxf))
      dstarf = (4d0*dshf*dshf/3d0+2d0*dshf*(sxf-dshf))/(sxf-dshf+1d0)
      dstarf = dstarf + gdoin_ice*alfa_ice*wpar_icef
      result10 = SQRT(dstarf)
      taof = nhet_f*sizecorrf*sxf*result10/(sxf+1d0)/nstar
    ELSE
!monodisperse approximation
      dshf = sxf - sh_ice
      dstarf = (4d0*dshf*dshf/3d0+2d0*dshf*(sxf-dshf))/(sxf-dshf+1d0)
      arg1 = gam*gam + 2d0*dstarf/g1_ice/alfa_ice/wpar_icef
      result10 = SQRT(arg1)
      dlimf = -gam + result10
      taof = alfa_ice*wpar_icef*(sxf+1d0)/z_ice/beta_ice/sxf
      taof = taof*(g1_ice*dlimf+g2_ice)/dlimf/dlimf/nin_ice
    END IF
    nearzero = 1d0 - taof
  END SUBROUTINE FINDSMAX
!  Differentiation of prop_ice in reverse (adjoint) mode:
!   gradient     of useful results: dtnuc_dhf abc_dep g1_ice del1bc_ice
!                del1dust_ice dtnuc_dep aimm ddry_ice dact_imm
!                g2_ice beta_ice si0dust_ice si0bc_ice lambda_ice
!                lmeff_ice vw_ice kdust_ice ndust_ice alfa_ice
!                dliq_ice adust_dep kbc_ice koft_ice denice_ice
!                vpresw_ice gdoin_ice vpresi_ice z_ice denair_ice
!                nin_ice shom_ice nbc_ice t_ice
!   with respect to varying inputs: ddry_ice ndust_ice depcoef_ice
!                nbc_ice t_ice
!*************************************************************
!    Subroutine PROPERTIES. Set physical an thermodynamic 
!    properties at T and P 
!************************************************************   
  SUBROUTINE PROP_ICE_B(t_ice, t_iceb, p_ice)
    IMPLICIT NONE
    REAL*8 :: t_ice, p_ice
    REAL*8 :: t_iceb
    REAL*8 :: aux, aux1, aux2, sw, fice, mice, tc, hdust, hbc, b0, b1, &
&   b2, b3, x, t0bc, t0dust, gam, gamma
    REAL*8 :: aux1b, aux2b, swb, tcb, xb, t0bcb, t0dustb, gamb, gammab
    REAL*8 :: tr, vw, den_m, eact, toact, dact, acc, n1, siw, rgo, ngo, &
&   mw_molec
    REAL*8 :: trb, vwb, siwb, rgob, ngob
    INTRINSIC SQRT
    INTRINSIC SUM
    INTRINSIC LOG
    INTRINSIC EXP
    REAL*8 :: pwr1
    REAL*8 :: pwr1b
    REAL*8 :: arg1
    REAL*8 :: arg1b
    REAL*8 :: result1
    REAL*8 :: result1b
    REAL*8 :: arg2
    REAL*8 :: arg2b
    REAL*8 :: arg10
    REAL*8 :: arg10b
    INTEGER :: branch
    REAL*8 :: temp3
    REAL*8 :: temp2
    REAL*8 :: temp1
    REAL*8 :: temp0
    REAL*8 :: tempb9
    REAL*8 :: tempb8
    REAL*8 :: tempb7
    REAL*8 :: tempb6
    REAL*8 :: tempb5
    REAL*8 :: tempb4
    REAL*8 :: tempb19
    REAL*8 :: tempb3
    REAL*8 :: tempb18
    REAL*8 :: tempb2
    REAL*8 :: tempb17
    REAL*8 :: tempb1
    REAL*8 :: tempb16
    REAL*8 :: tempb0
    REAL*8 :: tempb15
    REAL*8 :: tempb14
    REAL*8 :: tempb13
    REAL*8 :: tempb12
    REAL*8 :: tempb11
    REAL*8 :: tempb10
    REAL*8 :: temp19
    REAL*8 :: temp18
    REAL*8 :: temp17
    REAL*8 :: temp16
    REAL*8 :: temp15
    REAL*8 :: temp14
    REAL*8 :: temp13
    REAL*8 :: temp12
    REAL*8 :: temp11
    REAL*8 :: temp10
    REAL*8 :: tempb
    REAL*8 :: tempb28
    REAL*8 :: tempb27
    REAL*8 :: tempb26
    REAL*8 :: tempb25
    REAL*8 :: temp
    REAL*8 :: tempb24
    REAL*8 :: tempb23
    REAL*8 :: tempb22
    REAL*8 :: temp9
    REAL*8 :: tempb21
    REAL*8 :: temp8
    REAL*8 :: tempb20
    REAL*8 :: temp7
    REAL*8 :: temp6
    REAL*8 :: temp5
    REAL*8 :: temp4
! Sanity check
    IF (t_ice .GT. 273d0) THEN
      t_ice = 273d0
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
! Use this properties only for ice
    IF (t_ice .LT. 180d0) THEN
      t_ice = 180d0
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
! Use this properties only for ice
    IF (p_ice .LT. 1d0) p_ice = 1d0
! Use this properties only for ice
    rv_ice = rgas_ice/wmw_ice
    dhs_ice = DHSUB_ICE(t_ice)
    vpresw_ice = VPRESWATER_ICE(t_ice)
    vpresi_ice = VPRESICE(t_ice)
    denice_ice = DENSITYICE(t_ice)
    denair_ice = p_ice*amw_ice/rgas_ice/t_ice
! Kinetic properties of the bulk vapor (SI UNITS, Seinfel and Pandis, 1997)
!m^2/s
    diff_ice = 0.211d0*101325d0/p_ice*(t_ice/273d0)**1.94d0*1.0d-4
!W/m
    aux1 = 1.0e-3*(4.39d0+0.071d0*t_ice)
!correcting Kair for size assuming D=1e-6 m
    aux2 = 2d0*aux1/(thaccom_ice*1.0d-6*denair_ice*cpa_ice)*(58.0d-3*&
&     pi_ice/(rgas_ice*t_ice))**0.5d0
    aircond_ice = aux1/(1.d0+aux2)
!Physical constants
    aux1 = grav_ice*dhs_ice/rv_ice/t_ice/t_ice/cpa_ice
    CALL PUSHREAL8(aux2)
    aux2 = grav_ice*amw_ice/rgas_ice/t_ice
    alfa_ice = aux1 - aux2
!Correction for T>250 K
!only important for high T (>250 K, Barahona et al. JGR 2010)
!Homogeneous freezing only 
!hom threeshold Si according to Ren & McKenzie, 2005
    shom_ice = 2.349d0 - t_ice/259d0
    sw = shom_ice*vpresi_ice/vpresw_ice
! constant related to Jmax, Barahona & Nenes JGR 2008
!Calculate Dliq using an approximation derived from the equilbrium calculations and the
!Approximation proposed by Lewis (2008), 13, D03205, JGR 
    IF (sw .LT. 0.99) THEN
!only subsaturated regime (Haze Aerosols)
      aux1 = 1d0/(1d0-sw) - 1.1764d0
      pwr1 = aux1**(1d0/3d0)
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
! calculate average G for homogeneous freezing   
    CALL PUSHREAL8(aux1)
    aux1 = denice_ice*rv_ice*t_ice/vpresi_ice/diff_ice
    aux2 = dhs_ice*denice_ice/aircond_ice/t_ice
    CALL PUSHREAL8(aux2)
    aux2 = aux2*(dhs_ice/rv_ice/t_ice-1.0d0)
    g1_ice = (aux1+aux2)/4.0d0
    g2_ice = denice_ice*rv_ice*t_ice/2.0d0/vpresi_ice/depcoef_ice
    CALL PUSHREAL8(g2_ice)
    g2_ice = g2_ice*(2.0d0*pi_ice/rv_ice/t_ice)**0.5d0
!assumed IN diameter at freezing
    doin_ice = 1.0d-6
    gam = g2_ice/g1_ice
!divided by sqrt(wparcel) in niceparam 
    arg1 = alfa_ice*g1_ice*gam*gam
    result1 = SQRT(arg1)
!!============Parameters needed for IN spectra=========
!parameters used in the Monodisperse approximation 
!assume freeizng threeshold
!!============Parameters needed for CNT spectra=========
!maximum freezing threeshold dust only used in CNT
!maximum freezing efficiency dust
!maximum freezing threeshold bc only used in CNT
!maximum freezing efficiency bc
!compatibility parameter dust
!compatibility parameter bc
    mice = 0.76d0
    fice = 0.25d0*(mice*mice*mice-3d0*mice+2d0)
!for Phillips, et. al. 2008 spectra PDA08!!!!!!!!!!!!!!!!!!!!!     
    tc = t_ice - 273.15d0
    hdust = 0.15d0
    t0dust = -40d0
    b0 = -1.0261d0
    b1 = 3.1656d-3
    b2 = 5.3938d-4
    b3 = 8.2584d-6
    x = b0 + b1*tc + b2*tc*tc + b3*tc*tc*tc
!bug corrected
    hbc = 0d0
    t0bc = -50d0
    b1 = 1.085d-2
    b2 = -3.118d-5
!bug corrected C to K
    arg10 = t0bc + 5d0
!===============================================================
!Parameters to calculate the het nuc rate. Barahona, ACP, 2011, 2012
!==============================================================
    tr = (t_ice-to_ice)/to_ice
    den_m = DENSITYICE(to_ice)
    vw = 1.0 - 0.05294*tr - 0.05637*tr*tr - 0.002913*tr*tr*tr
! m-3 according to Zobrist et al 2007 ACP
    CALL PUSHREAL8(vw)
    vw = wmw_ice/(na_ice*den_m*vw)
    mw_molec = wmw_ice/na_ice
!From Khvorostyano & Curry 2010
    lmeff_ice = 4186.0*(79.7+0.333*tc-2.5e-3*tc*tc+0.8e-7*tc*tc*tc*tc)
    eact = 892.0
    toact = 118.0
    siw = vpresw_ice/vpresi_ice
!value at saturation
    sigiw_ice = (-25.67+0.211*t_ice)*1.0e-3
!deposition***********************
    rgo = 2.0*vw*sigiv_ice/(kb_ice*t_ice*LOG(siw))
    arg1 = sigiv_ice/kb_ice/t_ice
    CALL PUSHREAL8(result1)
    result1 = SQRT(arg1)
    aux1 = vpresi_ice*vpresi_ice*vw*result1/(mw_molec*kb_ice*t_ice*&
&     vs_ice)
!dust 
!Seisel et al 2005
!soot       
!Seisel et al 2005
    acc = 4.7e-2
    dact = -4.4e-20
!multiplied by Si^2/sqrt(f) in JHET
!del_het freezing (or immersion in solution)*****************************
    CALL PUSHREAL8(rgo)
    rgo = 2.0*sigiw_ice/(denice_ice*lmeff_ice*LOG(to_ice/t_ice))
    ngo = 4.0*pi_ice*(rgo*rgo*rgo)/3.0/vw
    dact_imm = kb_ice*t_ice*t_ice*eact/(t_ice-toact)**2.0
!PK97
    n1 = 1.0e19
    arg1 = -(dact_imm/kb_ice/t_ice)
    arg2 = 3.0*pi_ice*kb_ice*t_ice
    CALL PUSHREAL8(result1)
    result1 = SQRT(arg2)
    temp9 = rv_ice*t_ice
    temp8 = 2.0d0*pi_ice/temp9
    temp19 = hp_ice*result1
    temp18 = t_ice/temp19
    tempb4 = kb_ice*n1*aimmb
    tempb5 = EXP(arg1)*tempb4/temp19
    arg1b = temp18*EXP(arg1)*tempb4
    result1b = -(temp18*hp_ice*tempb5)
    CALL POPREAL8(result1)
    IF (arg2 .EQ. 0.0) THEN
      arg2b = 0.0
    ELSE
      arg2b = result1b/(2.0*SQRT(arg2))
    END IF
    tempb8 = -(arg1b/(kb_ice*t_ice))
    dact_immb = dact_immb + tempb8
    temp17 = (t_ice-toact)**2.0
    tempb6 = kb_ice*eact*dact_immb/temp17
    tempb9 = -(dtnuc_dhfb/(ngo**2*alfa_ice**2))
    ngob = alfa_ice*tempb9
    alfa_iceb = alfa_iceb + ngo*tempb9
    tempb10 = pi_ice*4.0*ngob/(3.0*vw)
    rgob = 3*rgo**2*tempb10
    vwb = -(rgo**3*tempb10/vw)
    CALL POPREAL8(rgo)
    temp16 = to_ice/t_ice
    temp15 = LOG(temp16)
    temp14 = denice_ice*lmeff_ice*temp15
    tempb11 = 2.0*rgob/temp14
    tempb7 = -(sigiw_ice*tempb11/temp14)
    tempb12 = temp15*tempb7
    sigiw_iceb = tempb11
    lmeff_iceb = lmeff_iceb + denice_ice*tempb12
    arg1 = -(dact/kb_ice/t_ice)
    arg1b = aux1*acc*EXP(arg1)*abc_depb
    t_iceb = t_iceb + pi_ice*3.0*kb_ice*arg2b + (2*t_ice-t_ice**2*2.0*(&
&     t_ice-toact)/temp17)*tempb6 + dact*arg1b/(kb_ice*t_ice**2) - &
&     denice_ice*lmeff_ice*tempb7/t_ice - dact_imm*tempb8/t_ice + tempb5
    aux1b = acc*EXP(arg1)*abc_depb
    dact = -6.5e-20
    arg1 = -(dact/kb_ice/t_ice)
    acc = 6.3e-2
    arg1b = aux1*acc*EXP(arg1)*adust_depb
    aux1b = aux1b + acc*EXP(arg1)*adust_depb
    temp13 = mw_molec*kb_ice*vs_ice
    tempb17 = aux1b/(temp13*t_ice)
    t_iceb = t_iceb + dact*arg1b/(kb_ice*t_ice**2) - vpresi_ice**2*vw*&
&     result1*tempb17/t_ice
    tempb18 = vpresi_ice**2*tempb17
    vpresi_iceb = vpresi_iceb + vw*result1*2*vpresi_ice*tempb17
    result1b = vw*tempb18
    arg1 = sigiv_ice/kb_ice/t_ice
    IF (arg1 .EQ. 0.0) THEN
      arg1b = 0.0
    ELSE
      arg1b = result1b/(2.0*SQRT(arg1))
    END IF
    ngo = 4.0*pi_ice*(rgo*rgo*rgo)/3.0/vw
    tempb22 = -(dtnuc_depb/(ngo**2*alfa_ice**2))
    ngob = alfa_ice*tempb22
    tempb19 = pi_ice*4.0*ngob/(3.0*vw)
    rgob = 3*rgo**2*tempb19
    temp12 = LOG(siw)
    temp11 = kb_ice*t_ice*temp12
    tempb20 = sigiv_ice*2.0*rgob/temp11
    vwb = vwb + vw_iceb - rgo**3*tempb19/vw + tempb20 + result1*tempb18
    CALL POPREAL8(result1)
    tempb21 = -(vw*tempb20/temp11)
    siwb = kb_ice*t_ice*tempb21/siw
    vpresw_iceb = vpresw_iceb + siwb/vpresi_ice
    tempb26 = 4186.0*lmeff_iceb
    tcb = (0.8e-7*4*tc**3-2.5e-3*2*tc+0.333)*tempb26
    CALL POPREAL8(vw)
    temp10 = na_ice*den_m*vw
    vwb = -(wmw_ice*na_ice*den_m*vwb/temp10**2)
    trb = ((-0.05294)-0.05637*2*tr-0.002913*3*tr**2)*vwb
    t_iceb = t_iceb + temp12*kb_ice*tempb21 + trb/to_ice + (b2*2*t_ice+&
&     b1)*si0bc_iceb + 1.0e-3*0.211*sigiw_iceb - sigiv_ice*arg1b/(kb_ice&
&     *t_ice**2)
    t0bcb = 0.0_8
    CALL CUBICINT_ICE_B(tc, tcb, t0bc, t0bcb, arg10, arg10b, 1d0, hbc, &
&                 del1bc_iceb)
    arg10 = t0dust + 5d0
    t0dustb = 0.0_8
    CALL CUBICINT_ICE_B(tc, tcb, t0dust, t0dustb, arg10, arg10b, 1d0, &
&                 hdust, del1dust_iceb)
    pwr1b = si0dust_iceb
    xb = 10d0**x*LOG(10d0)*pwr1b
    b1 = 3.1656d-3
    b2 = 5.3938d-4
    tcb = tcb + (b3*3*tc**2+b2*2*tc+b1)*xb
    koft_iceb = koft_iceb + fice*kbc_iceb
    mice = 0.96d0
    fice = 0.25d0*(mice*mice*mice-3d0*mice+2d0)
    koft_iceb = koft_iceb + fice*kdust_iceb
    ndust_iceb = ndust_iceb + 0.05d0*nin_iceb
    nbc_iceb = nbc_iceb + 0.05d0*nin_iceb
    result1b = -(lambda_iceb/result1**2)
    arg1 = alfa_ice*g1_ice*gam*gam
    IF (arg1 .EQ. 0.0) THEN
      arg1b = 0.0
    ELSE
      arg1b = result1b/(2.0*SQRT(arg1))
    END IF
    tempb23 = gam**2*arg1b
    alfa_iceb = alfa_iceb + g1_ice*tempb23 + ngo*tempb22
    gamb = alfa_ice*g1_ice*2*gam*arg1b
    g1_iceb = g1_iceb + doin_ice**2*0.5d0*gdoin_iceb - g2_ice*gamb/&
&     g1_ice**2 + alfa_ice*tempb23
    g2_iceb = g2_iceb + doin_ice*gdoin_iceb + gamb/g1_ice
    tempb13 = pi_ice*z_iceb/(2.0d0*denair_ice)
    denair_iceb = denair_iceb - denice_ice*tempb13/denair_ice
    CALL POPREAL8(g2_ice)
    t_iceb = t_iceb + tcb - temp8*0.5d0*temp8**(-0.5D0)*g2_ice*rv_ice*&
&     g2_iceb/temp9
    g2_iceb = temp8**0.5d0*g2_iceb
    temp7 = 2.0d0*vpresi_ice*depcoef_ice
    tempb16 = rv_ice*g2_iceb/temp7
    tempb24 = -(denice_ice*t_ice*tempb16/temp7)
    depcoef_iceb = 2.0d0*vpresi_ice*tempb24
    aux1b = g1_iceb/4.0d0
    aux2b = g1_iceb/4.0d0
    CALL POPREAL8(aux2)
    temp6 = rv_ice*t_ice
    temp5 = dhs_ice/temp6
    tempb27 = aux2*aux2b/temp6
    aux2b = (temp5-1.0d0)*aux2b
    tempb14 = aux2b/(aircond_ice*t_ice)
    dhs_iceb = denice_ice*tempb14 + tempb27
    tempb28 = -(dhs_ice*denice_ice*tempb14/(aircond_ice*t_ice))
    aircond_iceb = t_ice*tempb28
    CALL POPREAL8(aux1)
    tempb15 = rv_ice*aux1b/(vpresi_ice*diff_ice)
    denice_iceb = denice_iceb + tempb13 + dhs_ice*tempb14 + t_ice*&
&     tempb15 + t_ice*tempb16 + lmeff_ice*tempb12
    t_iceb = t_iceb + denice_ice*tempb15 - temp5*rv_ice*tempb27 + &
&     aircond_ice*tempb28 + denice_ice*tempb16
    tempb25 = -(denice_ice*t_ice*tempb15/(vpresi_ice*diff_ice))
    vpresi_iceb = vpresi_iceb + depcoef_ice*2.0d0*tempb24 + diff_ice*&
&     tempb25 - vpresw_ice*siwb/vpresi_ice**2
    diff_iceb = vpresi_ice*tempb25
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      ddry_iceb = ddry_iceb + 0.9344d0*pwr1*dliq_iceb
      pwr1b = 0.9344d0*ddry_ice*dliq_iceb
      IF (aux1 .LE. 0.0 .AND. (1.0/3d0 .EQ. 0.0 .OR. 1.0/3d0 .NE. INT(&
&         1.0/3d0))) THEN
        aux1b = 0.0
      ELSE
        aux1b = aux1**(1.0/3d0-1)*pwr1b/3d0
      END IF
      swb = aux1b/(1d0-sw)**2
    ELSE
      swb = 0.0_8
    END IF
    aux1b = alfa_iceb
    aux2b = -alfa_iceb
    temp3 = rv_ice*cpa_ice*t_ice**2
    tempb1 = grav_ice*aux1b/temp3
    gammab = beta_iceb
    temp4 = rv_ice*cpa_ice*t_ice**2
    tempb = 1.5d0*gammab/temp4
    tempb0 = swb/vpresw_ice
    shom_iceb = shom_iceb + vpresi_ice*tempb0
    t_iceb = t_iceb + (0.0240d0*2*t_ice-8.035d0)*koft_iceb - grav_ice*&
&     amw_ice*aux2b/(rgas_ice*t_ice**2) - rv_ice*cpa_ice*dhs_ice**2*2*&
&     t_ice*tempb/temp4 - shom_iceb/259d0
    vpresi_iceb = vpresi_iceb + shom_ice*tempb0 - amw_ice*p_ice*&
&     beta_iceb/(wmw_ice*vpresi_ice**2)
    vpresw_iceb = vpresw_iceb - shom_ice*vpresi_ice*tempb0/vpresw_ice
    dhs_iceb = dhs_iceb + tempb1 + 2*dhs_ice*tempb
    CALL POPREAL8(aux2)
    aux1 = 1.0e-3*(4.39d0+0.071d0*t_ice)
    tempb2 = aircond_iceb/(aux2+1.d0)
    aux2b = -(aux1*tempb2/(aux2+1.d0))
    temp2 = 1.0d-6*thaccom_ice*cpa_ice
    temp1 = temp2*denair_ice
    temp0 = rgas_ice*t_ice
    temp = 58.0d-3*pi_ice/temp0
    tempb3 = temp**0.5d0*2d0*aux2b/temp1
    aux1b = tempb3 + tempb2
    denair_iceb = denair_iceb - aux1*temp2*tempb3/temp1
    t_iceb = t_iceb + 1.94d0*(t_ice/273d0)**0.94D0*101325d0*1.0d-4*&
&     0.211d0*diff_iceb/(p_ice*273d0) - temp*0.5d0*temp**(-0.5D0)*aux1*&
&     2d0*rgas_ice*aux2b/(temp0*temp1) - p_ice*amw_ice*denair_iceb/(&
&     rgas_ice*t_ice**2) + 1.0e-3*0.071d0*aux1b - rv_ice*cpa_ice*dhs_ice&
&     *2*t_ice*tempb1/temp3
    CALL DENSITYICE_B(t_ice, t_iceb, denice_iceb)
    CALL VPRESICE_B(t_ice, t_iceb, vpresi_iceb)
    CALL VPRESWATER_ICE_B(t_ice, t_iceb, vpresw_iceb)
    CALL DHSUB_ICE_B(t_ice, t_iceb, dhs_iceb)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) t_iceb = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) t_iceb = 0.0_8
  END SUBROUTINE PROP_ICE_B
!*************************************************************
!    Subroutine PROPERTIES. Set physical an thermodynamic 
!    properties at T and P 
!************************************************************   
  SUBROUTINE PROP_ICE(t_ice, p_ice)
    IMPLICIT NONE
    REAL*8 :: t_ice, p_ice
    REAL*8 :: aux, aux1, aux2, sw, fice, mice, tc, hdust, hbc, b0, b1, &
&   b2, b3, x, t0bc, t0dust, gam, gamma
    REAL*8 :: tr, vw, den_m, eact, toact, dact, acc, n1, siw, rgo, ngo, &
&   mw_molec
    INTRINSIC SQRT
    INTRINSIC SUM
    INTRINSIC LOG
    INTRINSIC EXP
    REAL*8 :: pwr1
    REAL*8 :: arg1
    REAL*8 :: result1
    REAL*8 :: arg2
    REAL*8 :: arg10
! Sanity check
    IF (t_ice .GT. 273d0) t_ice = 273d0
! Use this properties only for ice
    IF (t_ice .LT. 180d0) t_ice = 180d0
! Use this properties only for ice
    IF (p_ice .LT. 1d0) p_ice = 1d0
! Use this properties only for ice
    rv_ice = rgas_ice/wmw_ice
    dhs_ice = DHSUB_ICE(t_ice)
    vpresw_ice = VPRESWATER_ICE(t_ice)
    vpresi_ice = VPRESICE(t_ice)
    denice_ice = DENSITYICE(t_ice)
    denwat_ice = WATDENSITY_ICE(t_ice)
    denair_ice = p_ice*amw_ice/rgas_ice/t_ice
! Kinetic properties of the bulk vapor (SI UNITS, Seinfel and Pandis, 1997)
!m^2/s
    diff_ice = 0.211d0*101325d0/p_ice*(t_ice/273d0)**1.94d0*1.0d-4
!W/m
    aux1 = 1.0e-3*(4.39d0+0.071d0*t_ice)
!correcting Kair for size assuming D=1e-6 m
    aux2 = 2d0*aux1/(thaccom_ice*1.0d-6*denair_ice*cpa_ice)*(58.0d-3*&
&     pi_ice/(rgas_ice*t_ice))**0.5d0
    aircond_ice = aux1/(1.d0+aux2)
!Physical constants
    aux1 = grav_ice*dhs_ice/rv_ice/t_ice/t_ice/cpa_ice
    aux2 = grav_ice*amw_ice/rgas_ice/t_ice
    alfa_ice = aux1 - aux2
    beta_ice = amw_ice*p_ice/wmw_ice/vpresi_ice
!Correction for T>250 K
!only important for high T (>250 K, Barahona et al. JGR 2010)
!Homogeneous freezing only 
!hom threeshold Si according to Ren & McKenzie, 2005
    gamma = 1.5d0*dhs_ice*dhs_ice/rv_ice/t_ice/t_ice/cpa_ice
!only important for high T (>250 K, Barahona et al. JGR 2010)
    beta_ice = beta_ice + gamma
!Homogeneous freezing only 
!hom threeshold Si according to Ren & McKenzie, 2005
    shom_ice = 2.349d0 - t_ice/259d0
    sw = shom_ice*vpresi_ice/vpresw_ice
    shom_ice = shom_ice - 1d0
! constant related to Jmax, Barahona & Nenes JGR 2008
!Calculate Dliq using an approximation derived from the equilbrium calculations and the
!Approximation proposed by Lewis (2008), 13, D03205, JGR 
    koft_ice = 0.0240d0*t_ice*t_ice - 8.035d0*t_ice + 934.0d0
!Calculate Dliq using an approximation derived from the equilbrium calculations and the
!Approximation proposed by Lewis (2008), 13, D03205, JGR 
    IF (sw .LT. 0.99) THEN
!only subsaturated regime (Haze Aerosols)
      aux1 = 1d0/(1d0-sw) - 1.1764d0
      pwr1 = aux1**(1d0/3d0)
      dliq_ice = ddry_ice*0.9344d0*pwr1
    ELSE
      aux1 = 1d0/0.01 - 1.1764d0
    END IF
! calculate average G for homogeneous freezing   
    aux1 = denice_ice*rv_ice*t_ice/vpresi_ice/diff_ice
    aux2 = dhs_ice*denice_ice/aircond_ice/t_ice
    aux2 = aux2*(dhs_ice/rv_ice/t_ice-1.0d0)
    g1_ice = (aux1+aux2)/4.0d0
    g2_ice = denice_ice*rv_ice*t_ice/2.0d0/vpresi_ice/depcoef_ice
    g2_ice = g2_ice*(2.0d0*pi_ice/rv_ice/t_ice)**0.5d0
!assumed IN diameter at freezing
    doin_ice = 1.0d-6
    gdoin_ice = g1_ice*0.5d0*doin_ice*doin_ice + g2_ice*doin_ice
    z_ice = denice_ice*pi_ice/2.0d0/denair_ice
    gam = g2_ice/g1_ice
!divided by sqrt(wparcel) in niceparam 
    arg1 = alfa_ice*g1_ice*gam*gam
    result1 = SQRT(arg1)
    lambda_ice = 1d0/result1
!!============Parameters needed for IN spectra=========
!parameters used in the Monodisperse approximation 
!assume freeizng threeshold
!!============Parameters needed for CNT spectra=========
!maximum freezing threeshold dust only used in CNT
!maximum freezing efficiency dust
!maximum freezing threeshold bc only used in CNT
!maximum freezing efficiency bc
!compatibility parameter dust
!compatibility parameter bc
    sh_ice = 0.3d0
    nin_ice = (SUM(ndust_ice)+nbc_ice)*0.05d0
!!============Parameters needed for CNT spectra=========
!maximum freezing threeshold dust only used in CNT
    shdust_ice = 0.2d0
!maximum freezing efficiency dust
    effdust_ice = 0.1d0
!maximum freezing threeshold bc only used in CNT
    shbc_ice = 0.4d0
!maximum freezing efficiency bc
    effbc_ice = 0.01d0
!compatibility parameter dust
    mice = 0.96d0
    fice = 0.25d0*(mice*mice*mice-3d0*mice+2d0)
    kdust_ice = koft_ice*fice
!compatibility parameter bc
    mice = 0.76d0
    fice = 0.25d0*(mice*mice*mice-3d0*mice+2d0)
    kbc_ice = koft_ice*fice
!for Phillips, et. al. 2008 spectra PDA08!!!!!!!!!!!!!!!!!!!!!     
    tc = t_ice - 273.15d0
    hdust = 0.15d0
    t0dust = -40d0
    b0 = -1.0261d0
    b1 = 3.1656d-3
    b2 = 5.3938d-4
    b3 = 8.2584d-6
    x = b0 + b1*tc + b2*tc*tc + b3*tc*tc*tc
    pwr1 = 10d0**x
    si0dust_ice = 1d0 + pwr1
!bug corrected
    arg10 = t0dust + 5d0
    del1dust_ice = CUBICINT_ICE(tc, t0dust, arg10, 1d0, hdust)
    hbc = 0d0
    t0bc = -50d0
    b0 = 0.5652d0
    b1 = 1.085d-2
    b2 = -3.118d-5
!bug corrected C to K
    si0bc_ice = b0 + b1*t_ice + b2*t_ice*t_ice - 0.1d0
    arg10 = t0bc + 5d0
    del1bc_ice = CUBICINT_ICE(tc, t0bc, arg10, 1d0, hbc)
!===============================================================
!Parameters to calculate the het nuc rate. Barahona, ACP, 2011, 2012
!==============================================================
    tr = (t_ice-to_ice)/to_ice
    den_m = DENSITYICE(to_ice)
    vw = 1.0 - 0.05294*tr - 0.05637*tr*tr - 0.002913*tr*tr*tr
! m-3 according to Zobrist et al 2007 ACP
    vw = wmw_ice/(na_ice*den_m*vw)
    vw_ice = vw
    mw_molec = wmw_ice/na_ice
!From Khvorostyano & Curry 2010
    lmeff_ice = 4186.0*(79.7+0.333*tc-2.5e-3*tc*tc+0.8e-7*tc*tc*tc*tc)
    eact = 892.0
    toact = 118.0
    siw = vpresw_ice/vpresi_ice
!value at saturation
    sigiw_ice = (-25.67+0.211*t_ice)*1.0e-3
!deposition***********************
    rgo = 2.0*vw*sigiv_ice/(kb_ice*t_ice*LOG(siw))
    ngo = 4.0*pi_ice*(rgo*rgo*rgo)/3.0/vw
    dtnuc_dep = 1.0/(ngo*alfa_ice)
    arg1 = sigiv_ice/kb_ice/t_ice
    result1 = SQRT(arg1)
    aux1 = vpresi_ice*vpresi_ice*vw*result1/(mw_molec*kb_ice*t_ice*&
&     vs_ice)
!dust 
!Seisel et al 2005
!soot       
!Seisel et al 2005
    acc = 6.3e-2
    dact = -6.5e-20
    arg1 = -(dact/kb_ice/t_ice)
    adust_dep = acc*EXP(arg1)*aux1
!soot       
!Seisel et al 2005
    acc = 4.7e-2
    dact = -4.4e-20
!multiplied by Si^2/sqrt(f) in JHET
!del_het freezing (or immersion in solution)*****************************
    arg1 = -(dact/kb_ice/t_ice)
    abc_dep = acc*EXP(arg1)*aux1
!del_het freezing (or immersion in solution)*****************************
    rgo = 2.0*sigiw_ice/(denice_ice*lmeff_ice*LOG(to_ice/t_ice))
    ngo = 4.0*pi_ice*(rgo*rgo*rgo)/3.0/vw
    dtnuc_dhf = 1.0/(ngo*alfa_ice)
    dact_imm = kb_ice*t_ice*t_ice*eact/(t_ice-toact)**2.0
!PK97
    n1 = 1.0e19
    arg1 = -(dact_imm/kb_ice/t_ice)
    arg2 = 3.0*pi_ice*kb_ice*t_ice
    result1 = SQRT(arg2)
    aimm = kb_ice*t_ice*n1*EXP(arg1)/(result1*hp_ice)
    RETURN
  END SUBROUTINE PROP_ICE
!  Differentiation of vpreswater_ice in reverse (adjoint) mode:
!   gradient     of useful results: t vpreswater_ice
!   with respect to varying inputs: t
!*************************************************************
!    Function VPRESWATER. Calculates the saturated vapor pressure
!    of water (Pa) according to Murphy & Koop (2005)
!    T in K (173.15-373.15)
!************************************************************    
  SUBROUTINE VPRESWATER_ICE_B(t, tb, vpreswater_iceb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: t
    REAL*8 :: tb
    REAL*8 :: a(0:9)
    INTRINSIC LOG
    INTRINSIC TANH
    INTRINSIC EXP
    REAL*8 :: arg1
    REAL*8 :: arg1b
    REAL*8 :: vpreswater_ice
    REAL*8 :: vpreswater_iceb
    REAL*8 :: tempb
    REAL*8 :: temp
    DATA a /54.842763d0, -6763.22d0, -4.21d0, 0.000367d0, 0.0415d0, &
&        218.8d0, 53.878d0, -1331.22d0, -9.44523d0, 0.014025d0/
    arg1 = a(4)*(t-a(5))
    vpreswater_ice = a(0) + a(1)/t + a(2)*LOG(t) + a(3)*t + TANH(arg1)*(&
&     a(6)+a(7)/t+a(8)*LOG(t)+a(9)*t)
    vpreswater_iceb = EXP(vpreswater_ice)*vpreswater_iceb
    temp = a(7)/t
    tempb = TANH(arg1)*vpreswater_iceb
    arg1b = (a(6)+temp+a(8)*LOG(t)+a(9)*t)*(1.0-TANH(arg1)**2)*&
&     vpreswater_iceb
    tb = tb + a(4)*arg1b + (a(9)+a(8)/t-temp/t)*tempb + (a(3)+a(2)/t-a(1&
&     )/t**2)*vpreswater_iceb
  END SUBROUTINE VPRESWATER_ICE_B
!*************************************************************
!    Function VPRESWATER. Calculates the saturated vapor pressure
!    of water (Pa) according to Murphy & Koop (2005)
!    T in K (173.15-373.15)
!************************************************************    
  REAL*8 FUNCTION VPRESWATER_ICE(t)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: t
    REAL*8 :: a(0:9)
    INTRINSIC LOG
    INTRINSIC TANH
    INTRINSIC EXP
    REAL*8 :: arg1
    DATA a /54.842763d0, -6763.22d0, -4.21d0, 0.000367d0, 0.0415d0, &
&        218.8d0, 53.878d0, -1331.22d0, -9.44523d0, 0.014025d0/
    arg1 = a(4)*(t-a(5))
    vpreswater_ice = a(0) + a(1)/t + a(2)*LOG(t) + a(3)*t + TANH(arg1)*(&
&     a(6)+a(7)/t+a(8)*LOG(t)+a(9)*t)
    vpreswater_ice = EXP(vpreswater_ice)
    RETURN
  END FUNCTION VPRESWATER_ICE
!  Differentiation of vpresice in reverse (adjoint) mode:
!   gradient     of useful results: t vpresice
!   with respect to varying inputs: t
!*************************************************************
!    Function VPRESICE. Calculates the saturated vapor pressure
!    of ice (pa) according to Murphy & Koop (2005)
!    T in K (>110)
!************************************************************         
  SUBROUTINE VPRESICE_B(t, tb, vpresiceb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: t
    REAL*8 :: tb
    REAL*8 :: a(0:3)
    INTRINSIC LOG
    INTRINSIC EXP
    REAL*8 :: vpresice
    REAL*8 :: vpresiceb
    DATA a /9.550426d0, -5723.265d0, 3.53068d0, -0.00728332d0/
    vpresice = a(0) + a(1)/t + a(2)*LOG(t) + a(3)*t
    vpresiceb = EXP(vpresice)*vpresiceb
    tb = tb + (a(3)+a(2)/t-a(1)/t**2)*vpresiceb
  END SUBROUTINE VPRESICE_B
!*************************************************************
!    Function VPRESICE. Calculates the saturated vapor pressure
!    of ice (pa) according to Murphy & Koop (2005)
!    T in K (>110)
!************************************************************         
  REAL*8 FUNCTION VPRESICE(t)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: t
    REAL*8 :: a(0:3)
    INTRINSIC LOG
    INTRINSIC EXP
    DATA a /9.550426d0, -5723.265d0, 3.53068d0, -0.00728332d0/
    vpresice = a(0) + a(1)/t + a(2)*LOG(t) + a(3)*t
    vpresice = EXP(vpresice)
    RETURN
  END FUNCTION VPRESICE
!  Differentiation of dhsub_ice in reverse (adjoint) mode:
!   gradient     of useful results: dhsub_ice t
!   with respect to varying inputs: t
!*************************************************************
!    Function DHSUB. Calculates the latent heat of sublimation
!    of ice (J/Kg) according to Murphy & Koop (2005)
!    T in K (>30)
!************************************************************         
  SUBROUTINE DHSUB_ICE_B(t, tb, dhsub_iceb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: t
    REAL*8 :: tb
    REAL*8 :: a(0:4)
    INTRINSIC EXP
    REAL*8 :: arg1
    REAL*8 :: arg1b
    REAL*8 :: dhsub_ice
    REAL*8 :: dhsub_iceb
    DATA a /46782.5d0, 35.8925d0, -0.07414d0, 541.5d0, 123.75d0/
    arg1 = -((t/a(4))**2)
    dhsub_iceb = 1000d0*dhsub_iceb/18d0
    arg1b = a(3)*EXP(arg1)*dhsub_iceb
    tb = tb + (a(2)*2*t+a(1))*dhsub_iceb - 2*t*arg1b/a(4)**2
  END SUBROUTINE DHSUB_ICE_B
!*************************************************************
!    Function DHSUB. Calculates the latent heat of sublimation
!    of ice (J/Kg) according to Murphy & Koop (2005)
!    T in K (>30)
!************************************************************         
  REAL*8 FUNCTION DHSUB_ICE(t)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: t
    REAL*8 :: a(0:4)
    INTRINSIC EXP
    REAL*8 :: arg1
    DATA a /46782.5d0, 35.8925d0, -0.07414d0, 541.5d0, 123.75d0/
    arg1 = -((t/a(4))**2)
    dhsub_ice = a(0) + a(1)*t + a(2)*t*t + a(3)*EXP(arg1)
    dhsub_ice = 1000d0*dhsub_ice/18d0
    RETURN
  END FUNCTION DHSUB_ICE
!  Differentiation of densityice in reverse (adjoint) mode:
!   gradient     of useful results: t densityice
!   with respect to varying inputs: t
!*************************************************************
!    Function ICEDENSITY. Calculates the DENSITY OF ICE
!    of ice (Kg/m3) according to PK97 
!    T in K (>30)
!************************************************************         
  SUBROUTINE DENSITYICE_B(t, tb, densityiceb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: t
    REAL*8 :: tb
    REAL*8 :: a(0:2), ttemp
    REAL*8 :: ttempb
    REAL*8 :: densityice
    REAL*8 :: densityiceb
    DATA a /0.9167d0, -1.75d-4, -5.0d-7/
    ttemp = t - 273d0
    ttempb = (a(2)*1000d0*2*ttemp+1000d0*a(1))*densityiceb
    tb = tb + ttempb
  END SUBROUTINE DENSITYICE_B
!*************************************************************
!    Function ICEDENSITY. Calculates the DENSITY OF ICE
!    of ice (Kg/m3) according to PK97 
!    T in K (>30)
!************************************************************         
  REAL*8 FUNCTION DENSITYICE(t)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: t
    REAL*8 :: a(0:2), ttemp
    DATA a /0.9167d0, -1.75d-4, -5.0d-7/
    ttemp = t - 273d0
    densityice = 1000d0*(a(0)+a(1)*ttemp+a(2)*ttemp*ttemp)
    RETURN
  END FUNCTION DENSITYICE
!*************************************************************
!    Function WATDENSITY. Calculates the DENSITY OF ICE
!    of liquid water (Kg/m3) according to PK97 
!    T in K (>240)
!************************************************************         
  REAL*8 FUNCTION WATDENSITY_ICE(t)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: t
    REAL*8 :: a(0:6), ttemp, watdensity
    INTEGER :: i
    DATA a /0.99986d0, 6.690d-5, -8.486d-6, 1.518d-7, -6.9984d-9, -&
&        3.6449d-10, -7.497d-12/
    ttemp = t - 273d0
    IF (ttemp .LE. -40d0) ttemp = -40d0
    watdensity = a(6)*ttemp
    IF (t .GE. 240.0) THEN
      DO i=5,1,-1
        watdensity = (watdensity+a(i))*ttemp
      END DO
      watdensity = watdensity + a(0)
    ELSE
      watdensity = 0.979d0
    END IF
    watdensity = watdensity*1000d0
    watdensity_ice = watdensity
    RETURN
  END FUNCTION WATDENSITY_ICE
!  Differentiation of gausspdf in reverse (adjoint) mode:
!   gradient     of useful results: normv_ice sigmav_ice dp
!   with respect to varying inputs: normv_ice sigmav_ice x
!*************************************************************
!   Subroutine gauspdf (normalized over the width of the distribution).  
!************************************************************  
  SUBROUTINE GAUSSPDF_B(x, xb, dp, dpb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: x
    REAL*8 :: xb
    REAL*8 :: dp
    REAL*8 :: dpb
    INTRINSIC EXP
    INTRINSIC SQRT
    REAL*8 :: arg1
    REAL*8 :: arg1b
    REAL*8 :: result1
    REAL*8 :: tempb0
    REAL*8 :: tempb
    REAL*8 :: temp
    arg1 = -(0.5d0*(x-miuv_ice)*(x-miuv_ice)/sigmav_ice/sigmav_ice)
    result1 = SQRT(2d0*pi_ice)
    temp = result1*sigmav_ice*normv_ice
    tempb = -(EXP(arg1)*dpb/temp**2)
    arg1b = EXP(arg1)*dpb/temp
    normv_iceb = normv_iceb + result1*sigmav_ice*tempb
    tempb0 = -(0.5d0*arg1b/sigmav_ice**2)
    sigmav_iceb = sigmav_iceb + normv_ice*result1*tempb - (x-miuv_ice)**&
&     2*2*tempb0/sigmav_ice
    xb = 2*(x-miuv_ice)*tempb0
  END SUBROUTINE GAUSSPDF_B
!*************************************************************
!   Subroutine gauspdf (normalized over the width of the distribution).  
!************************************************************  
  SUBROUTINE GAUSSPDF(x, dp)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: x
    REAL*8, INTENT(OUT) :: dp
    INTRINSIC EXP
    INTRINSIC SQRT
    REAL*8 :: arg1
    REAL*8 :: result1
    arg1 = -(0.5d0*(x-miuv_ice)*(x-miuv_ice)/sigmav_ice/sigmav_ice)
    result1 = SQRT(2d0*pi_ice)
    dp = EXP(arg1)/sigmav_ice/result1/normv_ice
    RETURN
  END SUBROUTINE GAUSSPDF
!  Differentiation of inspec_ice_d in reverse (adjoint) mode:
!   gradient     of useful results: dtnuc_dhf waux_ice abc_dep
!                norg_ice del1bc_ice del1dust_ice dtnuc_dep aimm
!                dact_imm si0dust_ice si0bc_ice lmeff_ice vw_ice
!                kdust_ice ndust_ice dorg_ice adust_dep kbc_ice
!                denice_ice vpresw_ice vpresi_ice dbc_ice ddust_ice
!                nbc_ice n t dshd nd0 dsh
!   with respect to varying inputs: dtnuc_dhf waux_ice abc_dep
!                norg_ice del1bc_ice del1dust_ice dtnuc_dep aimm
!                dact_imm si0dust_ice si0bc_ice lmeff_ice vw_ice
!                kdust_ice ndust_ice dorg_ice adust_dep kbc_ice
!                denice_ice vpresw_ice vpresi_ice dbc_ice ddust_ice
!                nbc_ice t
!  Differentiation of inspec_ice in forward (tangent) mode:
!   variations   of useful results: n dsh
!   with respect to varying inputs: six
!*************************************************************
! Subroutine INSPEC_ice
!  Provides the Ice Nuclei concentration (m-3) 
! and the chracteristic freezing threeshold, DSh (Barahona & Nenes 2009), at given 
! si and T. The variable typeofspec_ice (integer) has the values
! 1 Meyers et. al. 1992
! 2  Phillips et. al. 2007
! 3  Barahona & Nenes 2009
! 4  Phillips et. al. 2008 
! 5  Barahona,        2012 
! si is supersaturation wrt ice and T is in K 
!      Written by Donifan Barahona 
!      donifan.o.barahona@nasa.gov
!************************************************************  
  SUBROUTINE INSPEC_ICE_D_B(six, sixd, t, tb, n, nb, nd0, nd0b, dsh, &
&   dshb, dshd, dshdb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: six, t
    REAL*8 :: tb
    REAL*8, INTENT(IN) :: sixd
    REAL*8 :: n, dsh
    REAL*8 :: nb, dshb
    REAL*8 :: nd0, dshd
    REAL*8 :: nd0b, dshdb
    REAL*8 :: nd, nbc, aux, si_, sw, del0, ddel0, fc, delw0, ddelw0, sw0&
&   , hdust, hbc, nbase, dnd, dnbc, dnbase, dh, dfc, ndaux, dndaux, &
&   dnorg, norg, ndustaux, frac, aux2, dx2, fdep, ndep, ndhf, dndep, &
&   dndhf, si, dfrac, siw
    REAL*8 :: ndb, nbcb, auxb, si_b, swb, del0b, ddel0b, fcb, delw0b, &
&   ddelw0b, sw0b, hdustb, hbcb, nbaseb, dndb, dnbcb, dnbaseb, dhb, dfcb&
&   , ndauxb, dndauxb, dnorgb, norgb, ndustauxb, fracb, dx2b, fdepb, &
&   ndepb, ndhfb, dndepb, dndhfb, sib, dfracb, siwb
    REAL*8 :: ndd, nbcd, auxd, si_d, swd, del0d, ddel0d, fcd, delw0d, &
&   ddelw0d, hdustd, hbcd, nbased, dndd, dnbcd, dnbased, dhd, dfcd, &
&   ndauxd, dndauxd, dnorgd, norgd, fracd, fdepd, ndepd, ndhfd, dndepd, &
&   dndhfd, sid, dfracd
    REAL*8 :: nddb, nbcdb, auxdb, si_db, swdb, del0db, ddel0db, fcdb, &
&   delw0db, ddelw0db, hdustdb, hbcdb, nbasedb, dnddb, dnbcdb, dnbasedb&
&   , dhdb, dfcdb, ndauxdb, dndauxdb, dnorgdb, norgdb, fracdb, fdepdb, &
&   ndepdb, ndhfdb, dndepdb, dndhfdb, dfracdb
!variables for DM11
    REAL*8 :: a, b, c, d, nbig, nbigexp, other
    REAL*8 :: nbigb, nbigexpb, otherb
    REAL*8, DIMENSION(3) :: sig_array, the_array, frac_array
    REAL*8, DIMENSION(3) :: sig_arrayd, the_arrayd, frac_arrayd
    REAL*8 :: n_iw, dsh_s, asolo
    REAL*8 :: n_iwb, dsh_sb, asolob
    REAL*8 :: n_iwd, dsh_sd
    REAL*8 :: n_iwdb, dsh_sdb
    REAL*8, DIMENSION(1) :: nbc_s, dbc_s, d_grid_bio, n_grid_bio
    REAL*8, DIMENSION(1) :: nbc_sb, dbc_sb
    REAL*8, DIMENSION(1) :: nbc_sd, dbc_sd, d_grid_biod, n_grid_biod
    REAL*8, DIMENSION(nbindust_ice) :: ndust_s, ddust_s
    REAL*8, DIMENSION(nbindust_ice) :: ndust_sb, ddust_sb
    REAL*8, DIMENSION(nbindust_ice) :: ndust_sd
    INTEGER :: index, kindex, mode
    INTRINSIC EXP
    INTRINSIC LOG
    INTRINSIC SQRT
    INTRINSIC MIN
    INTRINSIC MAX
    REAL*8 :: arg1
    REAL*8 :: arg1b
    REAL*8 :: arg1d
    REAL*8 :: arg1db
    DOUBLE PRECISION :: result1
    REAL*8 :: result2
    REAL*8 :: result2b
    REAL*8 :: pwx1
    REAL*8 :: pwx1b
    REAL*8 :: pwr1
    REAL*8 :: pwr1b
    REAL*8 :: x2
    REAL*8 :: x2b
    REAL*8 :: x2d
    REAL*8 :: x2db
    REAL*8 :: x1
    REAL*8 :: x1b
    REAL*8 :: x1d
    REAL*8 :: x1db
    REAL*8 :: arg10
    REAL*8 :: arg10b
    INTEGER :: branch
    REAL*8 :: temp3
    REAL*8 :: tempb52
    REAL*8 :: temp2
    REAL*8 :: tempb51
    REAL*8 :: temp1
    REAL*8 :: tempb50
    REAL*8 :: temp0
    REAL*8 :: tempb9
    REAL*8 :: tempb8
    REAL*8 :: tempb7
    REAL*8 :: tempb6
    REAL*8 :: tempb5
    REAL*8 :: tempb4
    REAL*8 :: tempb19
    REAL*8 :: tempb3
    REAL*8 :: tempb18
    REAL*8 :: tempb2
    REAL*8 :: tempb17
    REAL*8 :: tempb1
    REAL*8 :: tempb16
    REAL*8 :: tempb0
    REAL*8 :: tempb15
    REAL*8 :: tempb14
    REAL*8 :: tempb13
    REAL*8 :: tempb12
    REAL*8 :: tempb49
    REAL*8 :: tempb11
    REAL*8 :: tempb48
    REAL*8 :: tempb10
    REAL*8 :: tempb47
    REAL*8 :: tempb46
    REAL*8 :: tempb45
    REAL*8 :: tempb44
    REAL*8 :: tempb43
    REAL*8 :: tempb42
    REAL*8 :: dummydiffb0
    REAL*8 :: tempb41
    REAL*8 :: tempb40
    REAL*8 :: temp14
    REAL*8 :: temp13
    REAL*8 :: temp12
    REAL*8 :: temp11
    REAL*8 :: temp10
    REAL*8 :: tempb70
    REAL*8 :: tempb
    REAL*8 :: tempb39
    REAL*8 :: tempb38
    REAL*8 :: tempb37
    REAL*8 :: tempb36
    REAL*8 :: tempb35
    REAL*8 :: tempb34
    REAL*8 :: tempb33
    REAL*8 :: dummydiffb
    REAL*8 :: tempb32
    REAL*8 :: tempb69
    REAL*8 :: tempb31
    REAL*8 :: tempb68
    REAL*8 :: tempb30
    REAL*8 :: tempb67
    REAL*8 :: tempb66
    REAL*8 :: tempb65
    REAL*8 :: tempb64
    REAL*8 :: tempb63
    REAL*8 :: tempb62
    REAL*8 :: tempb61
    REAL*8 :: tempb60
    REAL*8 :: tempb29
    REAL*8 :: tempb28
    REAL*8 :: tempb27
    REAL*8 :: tempb26
    REAL*8 :: tempb25
    REAL*8 :: temp
    REAL*8 :: tempb24
    REAL*8 :: tempb23
    REAL*8 :: tempb22
    REAL*8 :: tempb59
    REAL*8 :: tempb21
    REAL*8 :: temp9
    REAL*8 :: tempb58
    REAL*8 :: tempb20
    REAL*8 :: temp8
    REAL*8 :: tempb57
    REAL*8 :: temp7
    REAL*8 :: tempb56
    REAL*8 :: temp6
    REAL*8 :: tempb55
    REAL*8 :: temp5
    REAL*8 :: tempb54
    REAL*8 :: temp4
    REAL*8 :: tempb53
    sid = sixd
    si = six
    si_d = sid
    si_ = si + 1d0
!new2
    swd = vpresi_ice*si_d/vpresw_ice
    sw = si_*vpresi_ice/vpresw_ice
    IF (sw .GE. 1.0) THEN
!limit to subsaturated conditions
      sw = 1.0
      si_ = vpresw_ice/vpresi_ice
      si = si_ - 1.0
      si_d = 0.0_8
      sid = 0.0_8
      swd = 0.0_8
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    siw = vpresw_ice/vpresi_ice
    sig_array = 0.0
    the_array = 0.0
    frac_array = 0.0
    SELECT CASE  (typeofspec_ice) 
    CASE (1) 
!Phillips2007
      IF (t .LE. 243d0) THEN
        CALL PUSHCONTROL4B(0)
        dsh = 1d0/3.88d0
      ELSE
        CALL PUSHCONTROL4B(0)
        dsh = 1d0/12.96d0
      END IF
    CASE (2) 
!Meyers1992 
      dsh = 1d0/12.96d0
      CALL PUSHCONTROL4B(1)
    CASE (3) 
!Barahona&Nenes CNT
!dust contribution
      ndustaux = 0.0d0
      DO index=1,nbindust_ice
        ndustaux = ndustaux + ndust_ice(index)
      END DO
      IF (si .LE. shdust_ice) THEN
        arg1d = kdust_ice*sid
        arg1 = -(kdust_ice*(shdust_ice-si))
        ndd = ndustaux*effdust_ice*(sid*EXP(arg1)/shdust_ice+si*arg1d*&
&         EXP(arg1)/shdust_ice)
        nd = si/shdust_ice*ndustaux*effdust_ice*EXP(arg1)
        dndd = ndd*(1d0/si+kdust_ice) - nd*sid/si**2
        dnd = nd*(1d0/si+kdust_ice)
        CALL PUSHCONTROL1B(0)
      ELSE
        nd = ndustaux*effdust_ice
        dnd = 0d0
        dndd = 0.0_8
        ndd = 0.0_8
        CALL PUSHCONTROL1B(1)
      END IF
!soot contribution
      IF (si .LE. shbc_ice) THEN
        arg1d = kbc_ice*sid
        arg1 = -(kbc_ice*(shbc_ice-si))
        nbcd = nbc_ice*effbc_ice*(sid*EXP(arg1)/shbc_ice+si*arg1d*EXP(&
&         arg1)/shbc_ice)
        nbc = si/shbc_ice*nbc_ice*effbc_ice*EXP(arg1)
        dnbcd = nbcd*(1d0/si+kbc_ice) - nbc*sid/si**2
        dnbc = nbc*(1d0/si+kbc_ice)
        CALL PUSHCONTROL1B(0)
      ELSE
        nbc = nbc_ice*effbc_ice
        dnbc = 0d0
        dnbcd = 0.0_8
        nbcd = 0.0_8
        CALL PUSHCONTROL1B(1)
      END IF
      nd0 = ndd + nbcd
      n = nd + nbc
      IF (dnd + dnbc .GT. 0d0) THEN
        dsh = n/(dnd+dnbc)
        CALL PUSHCONTROL4B(2)
      ELSE
        dsh = si
        CALL PUSHCONTROL4B(3)
      END IF
    CASE (4) 
!PDA2008. Allows multiple lognormal modes for dust. Single mode lognormal distributions are assumed for bc and organics
! Dust
      sw0 = 0.97d0
      delw0d = CUBICINT_ICE_D(sw, swd, sw0, 1d0, 0d0, 1d0, delw0)
      ddelw0d = DCUBICINT_ICE_D(sw, swd, sw0, 1d0, 0d0, 1d0, ddelw0)
      nbased = PDG07_ICE_D(si, sid, t, nbase)
      IF (t .LE. 243d0) THEN
        dnbased = 3.88d0*nbased
        dnbase = 3.88d0*nbase
        CALL PUSHCONTROL1B(0)
      ELSE
        dnbased = 12.96d0*nbased
        dnbase = 12.96d0*nbase
        CALL PUSHCONTROL1B(1)
      END IF
!dust contribution
      arg10 = si0dust_ice + 0.1d0
      del0d = CUBICINT_ICE_D(si_, si_d, si0dust_ice, arg10, 0d0, 1d0, &
&       del0)
      arg10 = si0dust_ice + 0.1d0
      ddel0d = DCUBICINT_ICE_D(si_, si_d, si0dust_ice, arg10, 0d0, 1d0, &
&       ddel0)
      fcd = 0.5d0*del1dust_ice*del0d
      fc = 0.5d0*del1dust_ice*del0
      dfcd = 0.5d0*del1dust_ice*ddel0d
      dfc = 0.5d0*del1dust_ice*ddel0
      hdustd = fcd + (1d0-fc)*delw0d - fcd*delw0
      hdust = fc + (1d0-fc)*delw0
      dhd = dfcd*(1d0-delw0) - dfc*delw0d + ddelw0d*(1d0-fc) - ddelw0*&
&       fcd
      dh = dfc*(1d0-delw0) + ddelw0*(1d0-fc)
      IF (hdust .GT. 1d0) THEN
        hdust = 1d0
        dh = 0d0
        hdustd = 0.0_8
        dhd = 0.0_8
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      auxd = 2d0*pi_ice*(hdustd*nbase/0.76d0+hdust*nbased/0.76d0)/3d0/&
&       5.0d-7/4d0
      aux = 2d0/3d0*hdust*(nbase/0.76d0)*pi_ice/5.0d-7/4d0
!The last 4d0 was introduced as recommnedation of V Phillips
      aux2 = 2d0/3d0*pi_ice/0.76d0/5.0d-7/4d0
      nd = 0d0
      dnd = 0d0
      dndd = 0.0_8
      ndd = 0.0_8
      DO index=1,nbindust_ice
!Dx2= ddust_ice(index)*ddust_ice(index)
!new 07/10/12
        CALL PUSHREAL8(dx2)
        dx2 = ddust_ice(index)*ddust_ice(index)*ddust_ice(index)*0.52*&
&         acorr_dust
!fraction above 0.1 microns
!sigma_dust=log(sigma_bc_g)
        CALL PUSHREAL8(result1)
        result1 = SQRT(2d0)
        CALL PUSHREAL8(arg10)
        arg10 = -(LOG(ddust_ice(index)/0.1e-6)/sigdust_ice(index)/&
&         result1)
        result2 = ERFAPP(arg10)
        CALL PUSHREAL8(frac)
        frac = 0.5d0*(1d0-result2)
        CALL PUSHREAL8(ndauxd)
        ndauxd = frac*ndust_ice(index)*dx2*auxd*EXP(-(aux*dx2))
        CALL PUSHREAL8(ndaux)
        ndaux = frac*ndust_ice(index)*(1d0-EXP(-(aux*dx2)))
        ndd = ndd + ndauxd
        nd = nd + ndaux
        ndauxd = -ndauxd
        ndaux = frac*ndust_ice(index) - ndaux
        dndauxd = aux2*dx2*(ndauxd*(dh*nbase+hdust*dnbase)+ndaux*(dhd*&
&         nbase+dh*nbased+hdustd*dnbase+hdust*dnbased))
        dndaux = ndaux*(dh*nbase+hdust*dnbase)*aux2*dx2
        dndd = dndd + dndauxd
        dnd = dnd + dndaux
      END DO
!soot contribution
      CALL PUSHREAL8(arg10)
      arg10 = si0bc_ice + 0.1d0
      CALL PUSHREAL8(del0d)
      CALL PUSHREAL8(del0)
      del0d = CUBICINT_ICE_D(si_, si_d, si0bc_ice, arg10, 0d0, 1d0, del0&
&       )
      arg10 = si0bc_ice + 0.1d0
      CALL PUSHREAL8(ddel0d)
      CALL PUSHREAL8(ddel0)
      ddel0d = DCUBICINT_ICE_D(si_, si_d, si0bc_ice, arg10, 0d0, 1d0, &
&       ddel0)
      CALL PUSHREAL8(fcd)
      fcd = 0.5d0*del1bc_ice*del0d
      CALL PUSHREAL8(fc)
      fc = 0.5d0*del1bc_ice*del0
      hbcd = fcd + (1d0-fc)*delw0d - fcd*delw0
      hbc = fc + (1d0-fc)*delw0
      CALL PUSHREAL8(dfcd)
      dfcd = 0.5d0*del1bc_ice*ddel0d
      CALL PUSHREAL8(dfc)
      dfc = 0.5d0*del1bc_ice*ddel0
      CALL PUSHREAL8(dhd)
      dhd = dfcd*(1d0-delw0) - dfc*delw0d + ddelw0d*(1d0-fc) - ddelw0*&
&       fcd
      CALL PUSHREAL8(dh)
      dh = dfc*(1d0-delw0) + ddelw0*(1d0-fc)
      IF (hbc .GT. 1d0) THEN
        hbc = 1d0
        dh = 0d0
        dhd = 0.0_8
        hbcd = 0.0_8
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
!sigbc=log(sigma_bc_g)
      CALL PUSHREAL8(result1)
      result1 = SQRT(2d0)
      arg10 = -(LOG(dbc_ice/0.1e-6)/sigbc_ice/result1)
      result2 = ERFAPP(arg10)
      CALL PUSHREAL8(frac)
      frac = 0.5d0*(1d0-result2)
!Dx2=dbc_ice*dbc_ice	       
!new 07/10/12
      CALL PUSHREAL8(dx2)
      dx2 = dbc_ice*dbc_ice*dbc_ice*0.52*acorr_bc
      auxd = (1d0/3d0-0.06d0)*pi_ice*(hbcd*nbase/0.76d0+hbc*nbased/&
&       0.76d0)/2.7d-7
      aux = (1d0/3d0-0.06d0)*hbc*(nbase/0.76d0)*pi_ice/2.7d-7
      aux2 = (1d0/3d0-0.06d0)*pi_ice/0.76d0/2.7d-7
      nbcd = nbc_ice*frac*dx2*auxd*EXP(-(aux*dx2))
      nbc = nbc_ice*frac*(1d0-EXP(-(aux*dx2)))
      dnbcd = aux2*dx2*((nbc_ice*frac-nbc)*(dhd*nbase+dh*nbased+hbcd*&
&       dnbase+hbc*dnbased)-nbcd*(dh*nbase+hbc*dnbase))
      dnbc = (nbc_ice*frac-nbc)*(dh*nbase+hbc*dnbase)*aux2*dx2
!Organics contribution
!sigorg=log(sigma_org_g)
      CALL PUSHREAL8(result1)
      result1 = SQRT(2d0)
      CALL PUSHREAL8(arg10)
      arg10 = -(LOG(dorg_ice/0.1e-6)/sigorg_ice/result1)
      result2 = ERFAPP(arg10)
      CALL PUSHREAL8(frac)
      frac = 0.5d0*(1d0-result2)
      dx2 = dorg_ice*dorg_ice
      auxd = 0.06d0*pi_ice*(hbcd*nbase/0.76d0+hbc*nbased/0.76d0)/9.1d-7
      aux = 0.06d0*hbc*(nbase/0.76d0)*pi_ice/9.1d-7
      aux2 = 0.06d0*pi_ice/0.76d0/9.1d-7
      norgd = norg_ice*frac*dx2*auxd*EXP(-(aux*dx2))
      norg = norg_ice*frac*(1d0-EXP(-(aux*dx2)))
      dnorgd = aux2*dx2*((norg_ice*frac-norg)*(dhd*nbase+dh*nbased+hbcd*&
&       dnbase+hbc*dnbased)-norgd*(dh*nbase+hbc*dnbase))
      dnorg = (norg_ice*frac-norg)*(dh*nbase+hbc*dnbase)*aux2*dx2
      nd0 = ndd + nbcd + norgd
      n = nd + nbc + norg
      IF (dnd + dnbc + dnorg .GT. 0d0) THEN
        dsh = n/(dnd+dnbc+dnorg)
        CALL PUSHCONTROL4B(4)
      ELSE
        dsh = si
        CALL PUSHCONTROL4B(5)
      END IF
    CASE (5) 
!Phillips et al 2013.
      d_grid_bio(1) = dbio_ice
      n_grid_bio(1) = nbio_ice
!dust
      DO index=1,nbindust_ice
!fraction above 0.1 microns
        CALL PUSHREAL8(result1)
        result1 = SQRT(2d0)
        CALL PUSHREAL8(arg10)
        arg10 = LOG(0.1e-6/ddust_ice(index))/sigdust_ice(index)/result1
        result2 = ERFAPP(arg10)
        CALL PUSHREAL8(frac)
        frac = 0.5d0*(1d0-result2)
        ndust_s(index) = frac*ndust_ice(index)
        ddust_s = ddust_ice(index)
      END DO
!black carbon
!fraction above 0.1 microns
      CALL PUSHREAL8(result1)
      result1 = SQRT(2d0)
      CALL PUSHREAL8(arg10)
      arg10 = LOG(0.1e-6/dbc_ice)/sigbc_ice/result1
      result2 = ERFAPP(arg10)
      CALL PUSHREAL8(frac)
      frac = 0.5d0*(1d0-result2)
      nbc_s(1) = frac*nbc_ice
      IF (dbc_ice .GT. 2.e-6) THEN
        CALL PUSHREAL8(dbc_ice)
        dbc_ice = 2.e-6
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHREAL8(dbc_ice)
        dbc_ice = dbc_ice
        CALL PUSHCONTROL1B(1)
      END IF
      dbc_s(1) = dbc_ice*1.0
!Soluble organics (spherical)
!sigorg=log(sigma_org_g) !20-30% of organics are soluble (Saxena and HIdeelman 1996). 
      CALL PUSHREAL8(result1)
      result1 = SQRT(2d0)
      CALL PUSHREAL8(arg10)
      arg10 = LOG(0.1e-6/dorg_ice)/sigorg_ice/result1
      result2 = ERFAPP(arg10)
      CALL PUSHREAL8(frac)
      frac = 0.25d0*0.5d0*(1d0-result2)
!
      asolo = frac*norg_ice*3.1415*dorg_ice*dorg_ice
      CALL EMPIRICAL_PARAM_PHILLIPS_D(t, pice, si_, si_d, siw, sw, swd, &
&                               ddust_s, ndust_s, 2, dbc_s, nbc_s, 1, &
&                               d_grid_bio, n_grid_bio, 1, asolo, n_iw, &
&                               n_iwd, dsh_s, dsh_sd)
      dsh = dsh_s
      CALL PUSHCONTROL4B(6)
    CASE (6) 
!Barahona 2012. Spectrum based on NPDF-Theory and CNT (Unpublished)
!dust contribution*******************************************
!linear approx to decide DHF vs deposition, loosely based on Seisel 2005.
      fdepd = (-swd)/0.1
      fdep = (1.0-sw)/0.1
      IF (fdep .LT. 0.0) THEN
        x1 = 0.0
        x1d = 0.0_8
        CALL PUSHCONTROL1B(0)
      ELSE
        x1d = fdepd
        x1 = fdep
        CALL PUSHCONTROL1B(1)
      END IF
      IF (x1 .GT. 1.0) THEN
        fdep = 1.0
        fdepd = 0.0_8
        CALL PUSHCONTROL1B(0)
      ELSE
        fdepd = x1d
        fdep = x1
        CALL PUSHCONTROL1B(1)
      END IF
!Deposition *******
!deposition             
      mode = 1
      sig_array(1) = 21.4
      sig_array(2) = 21.4
      sig_array(3) = 21.4
      the_array(1) = 9.9
      the_array(2) = 15.1
      the_array(3) = 19.8
      frac_array(1) = 0.20
      frac_array(2) = 0.25
      frac_array(3) = 0.55
      dgh_ice = 0.0
      ndep = 0.0
      dndep = 0.0
      dndepd = 0.0_8
      ndepd = 0.0_8
      DO index=1,nbindust_ice
!new 07/10/12    
        dx2 = ddust_ice(index)*ddust_ice(index)*ddust_ice(index)*0.52*&
&         acorr_dust
!Dx2= ddust_ice(index)*ddust_ice(index)*pi_ice*4.0 !Assume spheres by now
        CALL PUSHREAL8(dfracd)
        CALL PUSHREAL8(dfrac)
        CALL PUSHREAL8(fracd)
        CALL PUSHREAL8(frac)
        CALL NUC_FRAC_D(frac, fracd, dfrac, dfracd, sig_array, the_array&
&                 , frac_array, t, si_, si_d, mode, dx2, adust_dep, 3)
        ndauxd = ndust_ice(index)*(fracd*fdep+frac*fdepd)
        ndaux = frac*ndust_ice(index)*fdep
        ndepd = ndepd + ndauxd
        ndep = ndep + ndaux
        dndauxd = ndust_ice(index)*(dfracd*fdep+dfrac*fdepd)
        dndaux = dfrac*ndust_ice(index)*fdep
        dndepd = dndepd + dndauxd
        dndep = dndep + dndaux
      END DO
!immersion *******
      mode = 3
!sig_array=(/ 10.0, 10.0, 10.0 /)
!the_array=(/ 85.0, 85.0, 85.0 /)
!frac_array=(/ 1.0, 0.0, 0.0 /)      
      CALL PUSHREAL8(sig_array(1))
      sig_array(1) = 1.014
      CALL PUSHREAL8(sig_array(2))
      sig_array(2) = 1.014
      CALL PUSHREAL8(sig_array(3))
      sig_array(3) = 1.014
      CALL PUSHREAL8(the_array(1))
      the_array(1) = 53.44
      CALL PUSHREAL8(the_array(2))
      the_array(2) = 53.44
      CALL PUSHREAL8(the_array(3))
      the_array(3) = 53.44
      CALL PUSHREAL8(frac_array(1))
      frac_array(1) = 1.0
      CALL PUSHREAL8(frac_array(2))
      frac_array(2) = 0.0
      CALL PUSHREAL8(frac_array(3))
      frac_array(3) = 0.0
      dgh_ice = 0.5
      ndhf = 0.0
      dndhf = 0.0
      dndhfd = 0.0_8
      ndhfd = 0.0_8
      DO index=1,nbindust_ice
!new 07/10/12
        dx2 = ddust_ice(index)*ddust_ice(index)*ddust_ice(index)*0.52*&
&         acorr_dust
!Dx2= ddust_ice(index)*ddust_ice(index)*pi_ice*4.0 !Assume spheres by now
        CALL PUSHREAL8(dfracd)
        CALL PUSHREAL8(dfrac)
        CALL PUSHREAL8(fracd)
        CALL PUSHREAL8(frac)
        CALL NUC_FRAC_D(frac, fracd, dfrac, dfracd, sig_array, the_array&
&                 , frac_array, t, si_, si_d, mode, dx2, aimm, 1)
        ndauxd = ndust_ice(index)*(fracd*(1.0-fdep)-frac*fdepd)
        ndaux = frac*ndust_ice(index)*(1.0-fdep)
        ndhfd = ndhfd + ndauxd
        ndhf = ndhf + ndaux
        dndauxd = ndust_ice(index)*(dfracd*(1.0-fdep)-dfrac*fdepd)
        dndaux = dfrac*ndust_ice(index)*(1.0-fdep)
        dndhfd = dndhfd + dndauxd
        dndhf = dndhf + dndaux
      END DO
      ndd = ndepd + ndhfd
      nd = ndep + ndhf
      dndd = dndepd + dndhfd
      dnd = dndep + dndhf
!soot contribution*****************************************
!linear approx to decide DHF vs deposition, loosely based on Seisel 2005.
      CALL PUSHREAL8(fdepd)
      fdepd = (-swd)/0.1
      CALL PUSHREAL8(fdep)
      fdep = (1.0-sw)/0.1
      IF (fdep .LT. 0.0) THEN
        x2 = 0.0
        x2d = 0.0_8
        CALL PUSHCONTROL1B(0)
      ELSE
        x2d = fdepd
        x2 = fdep
        CALL PUSHCONTROL1B(1)
      END IF
      IF (x2 .GT. 1.0) THEN
        fdep = 1.0
        fdepd = 0.0_8
        CALL PUSHCONTROL1B(0)
      ELSE
        fdepd = x2d
        fdep = x2
        CALL PUSHCONTROL1B(1)
      END IF
!deposition***
      mode = 1
      CALL PUSHREAL8(sig_array(1))
      sig_array(1) = 28.3
      CALL PUSHREAL8(sig_array(2))
      sig_array(2) = 28.3
      CALL PUSHREAL8(sig_array(3))
      sig_array(3) = 28.3
      CALL PUSHREAL8(the_array(1))
      the_array(1) = 34.2
      CALL PUSHREAL8(the_array(2))
      the_array(2) = 34.2
      CALL PUSHREAL8(the_array(3))
      the_array(3) = 34.2
      CALL PUSHREAL8(frac_array(1))
      frac_array(1) = 1.0
      CALL PUSHREAL8(frac_array(2))
      frac_array(2) = 0.0
      CALL PUSHREAL8(frac_array(3))
      frac_array(3) = 0.0
      dgh_ice = 0.0
!new 07/10/12
      dx2 = dbc_ice*dbc_ice*dbc_ice*0.52*acorr_bc
!Dx2=100.0e-12  !Popovicheva 2006. Not safe assuming spheres      
      CALL PUSHREAL8(dfracd)
      CALL PUSHREAL8(dfrac)
      CALL PUSHREAL8(fracd)
      CALL PUSHREAL8(frac)
      CALL NUC_FRAC_D(frac, fracd, dfrac, dfracd, sig_array, the_array, &
&               frac_array, t, si_, si_d, mode, dx2, abc_dep, 1)
      ndepd = nbc_ice*(fracd*fdep+frac*fdepd)
      ndep = frac*nbc_ice*fdep
      dndepd = nbc_ice*(dfracd*fdep+dfrac*fdepd)
      dndep = dfrac*nbc_ice*fdep
!Immersion***	 
      mode = 3
!sig_array=(/ 3.0, 3.0, 3.0 /)
!the_array=(/ 153.8, 153.8, 153.8/) !Barahona, in prep
      CALL PUSHREAL8(sig_array(1))
      sig_array(1) = 2.7988
      CALL PUSHREAL8(sig_array(2))
      sig_array(2) = 2.7
      CALL PUSHREAL8(sig_array(3))
      sig_array(3) = 2.7
      CALL PUSHREAL8(the_array(1))
      the_array(1) = 49.1769
      CALL PUSHREAL8(the_array(2))
      the_array(2) = 49.1769
      CALL PUSHREAL8(the_array(3))
      the_array(3) = 49.0
      CALL PUSHREAL8(frac_array(1))
      frac_array(1) = 1.0
      CALL PUSHREAL8(frac_array(2))
      frac_array(2) = 0.0
      CALL PUSHREAL8(frac_array(3))
      frac_array(3) = 0.0
      dgh_ice = 6.45
      CALL PUSHREAL8(dfracd)
      CALL PUSHREAL8(dfrac)
      CALL PUSHREAL8(fracd)
      CALL PUSHREAL8(frac)
      CALL NUC_FRAC_D(frac, fracd, dfrac, dfracd, sig_array, the_array, &
&               frac_array, t, si_, si_d, mode, dx2, aimm, 1)
      ndhfd = nbc_ice*(fracd*(1.0-fdep)-frac*fdepd)
      ndhf = frac*nbc_ice*(1.0-fdep)
      dndhfd = nbc_ice*(dfracd*(1.0-fdep)-dfrac*fdepd)
      dndhf = dfrac*nbc_ice*(1.0-fdep)
      nbcd = ndepd + ndhfd
      nbc = ndep + ndhf
      dnbcd = dndepd + dndhfd
      dnbc = dndep + dndhf
!Total   	 
      nd0 = ndd + nbcd
      n = nd + nbc
      IF (dnd + dnbc .GT. 0d0) THEN
        dsh = n/(dnd+dnbc)
        CALL PUSHCONTROL4B(7)
      ELSE
        dsh = si
        CALL PUSHCONTROL4B(8)
      END IF
    CASE (7) 
!DeMott 2011
      nd = 0.0d0
      a = 0.0000594d0
      b = 3.33d0
      c = 0.0264d0
      d = 0.0033d0
!dust number with D > 0.5 um
      DO index=1,nbindust_ice
!fraction above 0.5 microns
        CALL PUSHREAL8(result1)
        result1 = SQRT(2d0)
        CALL PUSHREAL8(arg10)
        arg10 = -(LOG(ddust_ice(index)/0.5d-6)/sigdust_ice(index)/&
&         result1)
        result2 = ERFAPP(arg10)
        CALL PUSHREAL8(frac)
        frac = 0.5d0*(1d0-result2)
        nd = nd + frac*ndust_ice(index)
      END DO
!BC number with D > 0.5 um
!sigbc=log(sigma_bc_g)
      CALL PUSHREAL8(result1)
      result1 = SQRT(2d0)
      CALL PUSHREAL8(arg10)
      arg10 = -(LOG(dbc_ice/0.5d-6)/sigbc_ice/result1)
      result2 = ERFAPP(arg10)
      CALL PUSHREAL8(frac)
      frac = 0.5d0*(1d0-result2)
      nbc = frac*nbc_ice
!org number with D > 0.5 um
!sigorg=log(sigma_org_g)
      CALL PUSHREAL8(result1)
      result1 = SQRT(2d0)
      CALL PUSHREAL8(arg10)
      arg10 = -(LOG(dorg_ice/0.5d-6)/sigorg_ice/result1)
      result2 = ERFAPP(arg10)
      CALL PUSHREAL8(frac)
      frac = 0.5d0*(1d0-result2)
      norg = frac*norg_ice
      nbig = nd + nbc + norg
!nbig must be in cc-1
      nbig = nbig/10d6
      nbigexp = c*(273.16d0-t) + d
      pwx1 = 273.16d0 - t
      pwr1 = pwx1**b
      n = a*pwr1
      other = nbig**nbigexp
!N should be output in m-3
      dsh = si
      CALL PUSHCONTROL4B(9)
    CASE DEFAULT
      dsh = si
      CALL PUSHCONTROL4B(10)
    END SELECT
    IF (dsh .GE. si) THEN
      sib = dshb
      dshdb = 0.0_8
      dshb = 0.0_8
    ELSE
      sib = 0.0_8
    END IF
    CALL POPCONTROL4B(branch)
    IF (branch .LT. 5) THEN
      IF (branch .LT. 2) THEN
        IF (branch .EQ. 0) THEN
          CALL PDG07_ICE_D_B(si, sib, sid, t, n, nb, nd0b)
          swdb = 0.0_8
          si_b = 0.0_8
          swb = 0.0_8
          siwb = 0.0_8
        ELSE
          sib = sib + EXP(12.96d0*si)*EXP(-0.639d0)*sid*12.96d0**2*&
&           1000d0*nd0b + EXP(12.96d0*si)*EXP(-0.639d0)*1000d0*12.96d0*&
&           nb
          swdb = 0.0_8
          si_b = 0.0_8
          swb = 0.0_8
          siwb = 0.0_8
        END IF
      ELSE
        IF (branch .EQ. 2) THEN
          tempb11 = dshdb/(dnd+dnbc)**2
          tempb12 = -((nd0*(dnd+dnbc)-n*(dndd+dnbcd))*2*tempb11/(dnd+&
&           dnbc))
          tempb9 = dshb/(dnd+dnbc)
          tempb10 = -(n*tempb9/(dnd+dnbc))
          nb = nb + tempb9 - (dndd+dnbcd)*tempb11
          dndb = nd0*tempb11 + tempb12 + tempb10
          dnbcb = nd0*tempb11 + tempb12 + tempb10
          nd0b = nd0b + (dnd+dnbc)*tempb11
          dnddb = -(n*tempb11)
          dnbcdb = -(n*tempb11)
        ELSE IF (branch .EQ. 3) THEN
          sib = sib + dshb
          dnddb = 0.0_8
          dndb = 0.0_8
          dnbcb = 0.0_8
          dnbcdb = 0.0_8
        ELSE
          temp13 = (dnd+dnbc+dnorg)**2
          tempb54 = dshdb/temp13
          tempb55 = nd0*tempb54
          tempb56 = -((nd0*(dnd+dnbc+dnorg)-n*(dndd+dnbcd+dnorgd))*2*(&
&           dnd+dnbc+dnorg)*tempb54/temp13)
          tempb52 = dshb/(dnd+dnbc+dnorg)
          tempb53 = -(n*tempb52/(dnd+dnbc+dnorg))
          nb = nb + tempb52 - (dndd+dnbcd+dnorgd)*tempb54
          dndb = tempb55 + tempb56 + tempb53
          dnbcb = tempb55 + tempb56 + tempb53
          dnorgb = tempb55 + tempb56 + tempb53
          tempb57 = -(n*tempb54)
          nd0b = nd0b + (dnd+dnbc+dnorg)*tempb54
          dnddb = tempb57
          dnbcdb = tempb57
          dnorgdb = tempb57
          GOTO 100
        END IF
        ndb = nb
        nbcb = nb
        nddb = nd0b
        nbcdb = nd0b
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          temp1 = si*arg1d/shbc_ice
          temp2 = EXP(arg1)
          tempb5 = -(sid*dnbcdb/si**2)
          nbcb = nbcb + tempb5 + (1.0/si+kbc_ice)*dnbcb
          nbcdb = nbcdb + (1.0/si+kbc_ice)*dnbcdb
          tempb7 = EXP(arg1)*effbc_ice*nbcb/shbc_ice
          nbc_iceb = nbc_iceb + effbc_ice*(sid*(EXP(arg1)/shbc_ice)+&
&           temp1*temp2)*nbcdb + si*tempb7
          tempb8 = effbc_ice*nbc_ice*nbcdb
          arg1b = (temp1*EXP(arg1)+sid*EXP(arg1)/shbc_ice)*tempb8 + si*&
&           nbc_ice*effbc_ice*EXP(arg1)*nbcb/shbc_ice
          tempb6 = temp2*tempb8/shbc_ice
          sib = sib + arg1d*tempb6 - nbc*2*tempb5/si - nbcd*dnbcdb/si**2&
&           + kbc_ice*arg1b + nbc_ice*tempb7 - nbc*dnbcb/si**2
          arg1db = si*tempb6
          kbc_iceb = kbc_iceb + nbcd*dnbcdb + sid*arg1db - (shbc_ice-si)&
&           *arg1b + nbc*dnbcb
        ELSE
          nbc_iceb = nbc_iceb + effbc_ice*nbcb
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          tempb1 = -(sid*dnddb/si**2)
          ndb = ndb + tempb1 + (1.0/si+kdust_ice)*dndb
          nddb = nddb + (1.0/si+kdust_ice)*dnddb
          arg1 = -(kdust_ice*(shdust_ice-si))
          tempb3 = EXP(arg1)*effdust_ice*ndb/shdust_ice
          arg1d = kdust_ice*sid
          temp0 = EXP(arg1)
          temp = si*arg1d/shdust_ice
          ndustauxb = effdust_ice*(sid*(EXP(arg1)/shdust_ice)+temp*temp0&
&           )*nddb + si*tempb3
          tempb4 = effdust_ice*ndustaux*nddb
          arg1b = (temp*EXP(arg1)+sid*EXP(arg1)/shdust_ice)*tempb4 + si*&
&           ndustaux*effdust_ice*EXP(arg1)*ndb/shdust_ice
          tempb2 = temp0*tempb4/shdust_ice
          sib = sib + arg1d*tempb2 - nd*2*tempb1/si - ndd*dnddb/si**2 + &
&           kdust_ice*arg1b + ndustaux*tempb3 - nd*dndb/si**2
          arg1db = si*tempb2
          kdust_iceb = kdust_iceb + ndd*dnddb + sid*arg1db - (shdust_ice&
&           -si)*arg1b + nd*dndb
        ELSE
          ndustauxb = effdust_ice*ndb
        END IF
        DO index=nbindust_ice,1,-1
          ndust_iceb(index) = ndust_iceb(index) + ndustauxb
        END DO
        swdb = 0.0_8
        si_b = 0.0_8
        swb = 0.0_8
        siwb = 0.0_8
      END IF
    ELSE
      IF (branch .LT. 8) THEN
        IF (branch .EQ. 5) THEN
          sib = sib + dshb
          dnddb = 0.0_8
          dndb = 0.0_8
          dnorgb = 0.0_8
          dnbcb = 0.0_8
          dnbcdb = 0.0_8
          dnorgdb = 0.0_8
          GOTO 100
        ELSE IF (branch .EQ. 6) THEN
          dsh_sb = dshb
          dsh_sdb = dshdb
          n_iwb = nb
          n_iwdb = nd0b
          CALL EMPIRICAL_PARAM_PHILLIPS_D_B(t, tb, pice, si_, si_b, si_d&
&                                     , siw, siwb, sw, swb, swd, swdb, &
&                                     ddust_s, ddust_sb, ndust_s, &
&                                     ndust_sb, 2, dbc_s, dbc_sb, nbc_s&
&                                     , nbc_sb, 1, d_grid_bio, &
&                                     n_grid_bio, 1, asolo, asolob, n_iw&
&                                     , n_iwb, n_iwd, n_iwdb, dsh_s, &
&                                     dsh_sb, dsh_sd, dsh_sdb)
          tempb58 = 3.1415*dorg_ice**2*asolob
          fracb = norg_ice*tempb58
          norg_iceb = norg_iceb + frac*tempb58
          dorg_iceb = dorg_iceb + frac*norg_ice*3.1415*2*dorg_ice*asolob
          CALL POPREAL8(frac)
          result2b = -(0.5d0*0.25d0*fracb)
          arg10b = 0.0_8
          CALL ERFAPP_B(arg10, arg10b, result2b)
          CALL POPREAL8(arg10)
          dorg_iceb = dorg_iceb - arg10b/(dorg_ice*sigorg_ice*result1)
          CALL POPREAL8(result1)
          dbc_iceb = dbc_iceb + dbc_sb(1)
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL8(dbc_ice)
            dbc_iceb = 0.0_8
          ELSE
            CALL POPREAL8(dbc_ice)
          END IF
          fracb = nbc_ice*nbc_sb(1)
          nbc_iceb = nbc_iceb + frac*nbc_sb(1)
          CALL POPREAL8(frac)
          result2b = -(0.5d0*fracb)
          arg10b = 0.0_8
          CALL ERFAPP_B(arg10, arg10b, result2b)
          CALL POPREAL8(arg10)
          dbc_iceb = dbc_iceb - arg10b/(dbc_ice*sigbc_ice*result1)
          CALL POPREAL8(result1)
          DO index=nbindust_ice,1,-1
            temp14 = 0.1e-6/ddust_ice(index)
            fracb = ndust_ice(index)*ndust_sb(index)
            ndust_iceb(index) = ndust_iceb(index) + frac*ndust_sb(index)
            CALL POPREAL8(frac)
            result2b = -(0.5d0*fracb)
            arg10b = 0.0_8
            CALL ERFAPP_B(arg10, arg10b, result2b)
            ddust_iceb(index) = ddust_iceb(index) + SUM(ddust_sb) - &
&             arg10b/(ddust_ice(index)*sigdust_ice(index)*result1)
            ndust_sb(index) = 0.0_8
            CALL POPREAL8(arg10)
            CALL POPREAL8(result1)
            ddust_sb = 0.0_8
          END DO
          GOTO 110
        ELSE
          tempb69 = dshdb/(dnd+dnbc)**2
          tempb70 = -((nd0*(dnd+dnbc)-n*(dndd+dnbcd))*2*tempb69/(dnd+&
&           dnbc))
          tempb67 = dshb/(dnd+dnbc)
          tempb68 = -(n*tempb67/(dnd+dnbc))
          nb = nb + tempb67 - (dndd+dnbcd)*tempb69
          dndb = nd0*tempb69 + tempb70 + tempb68
          dnbcb = nd0*tempb69 + tempb70 + tempb68
          nd0b = nd0b + (dnd+dnbc)*tempb69
          dnddb = -(n*tempb69)
          dnbcdb = -(n*tempb69)
        END IF
      ELSE IF (branch .EQ. 8) THEN
        sib = sib + dshb
        dnddb = 0.0_8
        dndb = 0.0_8
        dnbcb = 0.0_8
        dnbcdb = 0.0_8
      ELSE
        IF (branch .EQ. 9) THEN
          sib = sib + dshb
          nb = 1000d0*nb
          otherb = n*nb
          nb = other*nb
          IF (nbig .LE. 0.0 .AND. (nbigexp .EQ. 0.0 .OR. nbigexp .NE. &
&             INT(nbigexp))) THEN
            nbigb = 0.0
          ELSE
            nbigb = nbigexp*nbig**(nbigexp-1)*otherb
          END IF
          IF (nbig .LE. 0.0) THEN
            nbigexpb = 0.0
          ELSE
            nbigexpb = nbig**nbigexp*LOG(nbig)*otherb
          END IF
          pwr1b = a*nb
          IF (pwx1 .LE. 0.0 .AND. (b .EQ. 0.0 .OR. b .NE. INT(b))) THEN
            pwx1b = 0.0
          ELSE
            pwx1b = b*pwx1**(b-1)*pwr1b
          END IF
          tb = tb - c*nbigexpb - pwx1b
          nbigb = nbigb/10d6
          ndb = nbigb
          nbcb = nbigb
          norgb = nbigb
          fracb = norg_ice*norgb
          norg_iceb = norg_iceb + frac*norgb
          CALL POPREAL8(frac)
          result2b = -(0.5d0*fracb)
          arg10b = 0.0_8
          CALL ERFAPP_B(arg10, arg10b, result2b)
          CALL POPREAL8(arg10)
          dorg_iceb = dorg_iceb - arg10b/(dorg_ice*sigorg_ice*result1)
          CALL POPREAL8(result1)
          fracb = nbc_ice*nbcb
          nbc_iceb = nbc_iceb + frac*nbcb
          CALL POPREAL8(frac)
          result2b = -(0.5d0*fracb)
          arg10b = 0.0_8
          CALL ERFAPP_B(arg10, arg10b, result2b)
          CALL POPREAL8(arg10)
          dbc_iceb = dbc_iceb - arg10b/(dbc_ice*sigbc_ice*result1)
          CALL POPREAL8(result1)
          DO index=nbindust_ice,1,-1
            fracb = ndust_ice(index)*ndb
            ndust_iceb(index) = ndust_iceb(index) + frac*ndb
            CALL POPREAL8(frac)
            result2b = -(0.5d0*fracb)
            arg10b = 0.0_8
            CALL ERFAPP_B(arg10, arg10b, result2b)
            CALL POPREAL8(arg10)
            ddust_iceb(index) = ddust_iceb(index) - arg10b/(ddust_ice(&
&             index)*sigdust_ice(index)*result1)
            CALL POPREAL8(result1)
          END DO
          swdb = 0.0_8
          si_b = 0.0_8
          swb = 0.0_8
          siwb = 0.0_8
        ELSE
          sib = sib + dshb
          swdb = 0.0_8
          si_b = 0.0_8
          swb = 0.0_8
          siwb = 0.0_8
        END IF
        GOTO 110
      END IF
      ndb = nb
      nbcb = nb
      nddb = nd0b
      nbcdb = nd0b
      dndepb = dnbcb
      dndhfb = dnbcb
      dndepdb = dnbcdb
      dndhfdb = dnbcdb
      ndepb = nbcb
      ndhfb = nbcb
      ndepdb = nbcdb
      ndhfdb = nbcdb
      nbc_iceb = nbc_iceb + (dfracd*(1.0-fdep)-dfrac*fdepd)*dndhfdb + (&
&       fracd*(1.0-fdep)-frac*fdepd)*ndhfdb + (1.0-fdep)*frac*ndhfb + (&
&       1.0-fdep)*dfrac*dndhfb
      tempb63 = nbc_ice*dndhfdb
      dfracb = (1.0-fdep)*nbc_ice*dndhfb - fdepd*tempb63
      dfracdb = (1.0-fdep)*tempb63
      tempb64 = nbc_ice*ndhfdb
      fdepb = -(dfracd*tempb63) - fracd*tempb64 - frac*nbc_ice*ndhfb - &
&       dfrac*nbc_ice*dndhfb
      fdepdb = -(frac*tempb64) - dfrac*tempb63
      fracb = (1.0-fdep)*nbc_ice*ndhfb - fdepd*tempb64
      fracdb = (1.0-fdep)*tempb64
      CALL POPREAL8(frac)
      CALL POPREAL8(fracd)
      CALL POPREAL8(dfrac)
      CALL POPREAL8(dfracd)
      si_b = 0.0_8
      dx2b = 0.0_8
      CALL NUC_FRAC_D_B(frac, fracb, fracd, fracdb, dfrac, dfracb, &
&                 dfracd, dfracdb, sig_array, the_array, frac_array, t, &
&                 tb, si_, si_b, si_d, mode, dx2, dx2b, aimm, aimmb, 1)
      CALL POPREAL8(frac_array(3))
      CALL POPREAL8(frac_array(2))
      CALL POPREAL8(frac_array(1))
      CALL POPREAL8(the_array(3))
      CALL POPREAL8(the_array(2))
      CALL POPREAL8(the_array(1))
      CALL POPREAL8(sig_array(3))
      CALL POPREAL8(sig_array(2))
      CALL POPREAL8(sig_array(1))
      nbc_iceb = nbc_iceb + (dfracd*fdep+dfrac*fdepd)*dndepdb + (fracd*&
&       fdep+frac*fdepd)*ndepdb + fdep*frac*ndepb + fdep*dfrac*dndepb
      tempb65 = nbc_ice*dndepdb
      dfracb = fdepd*tempb65 + fdep*nbc_ice*dndepb
      dfracdb = fdep*tempb65
      tempb66 = nbc_ice*ndepdb
      fdepb = fdepb + dfracd*tempb65 + fracd*tempb66 + frac*nbc_ice*&
&       ndepb + dfrac*nbc_ice*dndepb
      fdepdb = fdepdb + frac*tempb66 + dfrac*tempb65
      fracb = fdepd*tempb66 + fdep*nbc_ice*ndepb
      fracdb = fdep*tempb66
      dgh_ice = 0.0
      mode = 1
      CALL POPREAL8(frac)
      CALL POPREAL8(fracd)
      CALL POPREAL8(dfrac)
      CALL POPREAL8(dfracd)
      CALL NUC_FRAC_D_B(frac, fracb, fracd, fracdb, dfrac, dfracb, &
&                 dfracd, dfracdb, sig_array, the_array, frac_array, t, &
&                 tb, si_, si_b, si_d, mode, dx2, dx2b, abc_dep, &
&                 abc_depb, 1)
      dbc_iceb = dbc_iceb + acorr_bc*0.52*3*dbc_ice**2*dx2b
      CALL POPREAL8(frac_array(3))
      CALL POPREAL8(frac_array(2))
      CALL POPREAL8(frac_array(1))
      CALL POPREAL8(the_array(3))
      CALL POPREAL8(the_array(2))
      CALL POPREAL8(the_array(1))
      CALL POPREAL8(sig_array(3))
      CALL POPREAL8(sig_array(2))
      CALL POPREAL8(sig_array(1))
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        x2db = 0.0_8
        x2b = 0.0_8
      ELSE
        x2b = fdepb
        x2db = fdepdb
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        fdepb = 0.0_8
        fdepdb = 0.0_8
      ELSE
        fdepb = x2b
        fdepdb = x2db
      END IF
      CALL POPREAL8(fdep)
      swb = -(fdepb/0.1)
      CALL POPREAL8(fdepd)
      swdb = -(fdepdb/0.1)
      dndepb = dndb
      dndhfb = dndb
      dndepdb = dnddb
      dndhfdb = dnddb
      ndepb = ndb
      ndhfb = ndb
      ndepdb = nddb
      ndhfdb = nddb
      dgh_ice = 0.5
      mode = 3
      fdepb = 0.0_8
      fdepdb = 0.0_8
      DO index=nbindust_ice,1,-1
        ndauxdb = ndhfdb
        tempb62 = ndust_ice(index)*ndauxdb
        ndauxb = ndhfb
        dndauxb = dndhfb
        dndauxdb = dndhfdb
        ndust_iceb(index) = ndust_iceb(index) + (dfracd*(1.0-fdep)-dfrac&
&         *fdepd)*dndauxdb + (fracd*(1.0-fdep)-frac*fdepd)*ndauxdb + &
&         frac*(1.0-fdep)*ndauxb + dfrac*(1.0-fdep)*dndauxb
        tempb61 = ndust_ice(index)*dndauxdb
        dfracb = ndust_ice(index)*(1.0-fdep)*dndauxb - fdepd*tempb61
        fdepb = fdepb - dfracd*tempb61 - fracd*tempb62 - frac*ndust_ice(&
&         index)*ndauxb - dfrac*ndust_ice(index)*dndauxb
        dfracdb = (1.0-fdep)*tempb61
        fdepdb = fdepdb - frac*tempb62 - dfrac*tempb61
        fracb = ndust_ice(index)*(1.0-fdep)*ndauxb - fdepd*tempb62
        fracdb = (1.0-fdep)*tempb62
        dx2 = ddust_ice(index)*ddust_ice(index)*ddust_ice(index)*0.52*&
&         acorr_dust
        CALL POPREAL8(frac)
        CALL POPREAL8(fracd)
        CALL POPREAL8(dfrac)
        CALL POPREAL8(dfracd)
        dx2b = 0.0_8
        CALL NUC_FRAC_D_B(frac, fracb, fracd, fracdb, dfrac, dfracb, &
&                   dfracd, dfracdb, sig_array, the_array, frac_array, t&
&                   , tb, si_, si_b, si_d, mode, dx2, dx2b, aimm, aimmb&
&                   , 1)
        ddust_iceb(index) = ddust_iceb(index) + acorr_dust*0.52*3*&
&         ddust_ice(index)**2*dx2b
      END DO
      CALL POPREAL8(frac_array(3))
      CALL POPREAL8(frac_array(2))
      CALL POPREAL8(frac_array(1))
      CALL POPREAL8(the_array(3))
      CALL POPREAL8(the_array(2))
      CALL POPREAL8(the_array(1))
      CALL POPREAL8(sig_array(3))
      CALL POPREAL8(sig_array(2))
      CALL POPREAL8(sig_array(1))
      dgh_ice = 0.0
      mode = 1
      DO index=nbindust_ice,1,-1
        ndauxdb = ndepdb
        tempb60 = ndust_ice(index)*ndauxdb
        ndauxb = ndepb
        dndauxb = dndepb
        dndauxdb = dndepdb
        ndust_iceb(index) = ndust_iceb(index) + (dfracd*fdep+dfrac*fdepd&
&         )*dndauxdb + (fracd*fdep+frac*fdepd)*ndauxdb + frac*fdep*&
&         ndauxb + dfrac*fdep*dndauxb
        tempb59 = ndust_ice(index)*dndauxdb
        dfracb = fdepd*tempb59 + ndust_ice(index)*fdep*dndauxb
        fdepb = fdepb + dfracd*tempb59 + fracd*tempb60 + ndust_ice(index&
&         )*frac*ndauxb + ndust_ice(index)*dfrac*dndauxb
        dfracdb = fdep*tempb59
        fdepdb = fdepdb + frac*tempb60 + dfrac*tempb59
        fracb = fdepd*tempb60 + ndust_ice(index)*fdep*ndauxb
        fracdb = fdep*tempb60
        dx2 = ddust_ice(index)*ddust_ice(index)*ddust_ice(index)*0.52*&
&         acorr_dust
        CALL POPREAL8(frac)
        CALL POPREAL8(fracd)
        CALL POPREAL8(dfrac)
        CALL POPREAL8(dfracd)
        dx2b = 0.0_8
        CALL NUC_FRAC_D_B(frac, fracb, fracd, fracdb, dfrac, dfracb, &
&                   dfracd, dfracdb, sig_array, the_array, frac_array, t&
&                   , tb, si_, si_b, si_d, mode, dx2, dx2b, adust_dep, &
&                   adust_depb, 3)
        ddust_iceb(index) = ddust_iceb(index) + acorr_dust*0.52*3*&
&         ddust_ice(index)**2*dx2b
      END DO
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        x1db = 0.0_8
        x1b = 0.0_8
      ELSE
        x1b = fdepb
        x1db = fdepdb
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        fdepb = 0.0_8
        fdepdb = 0.0_8
      ELSE
        fdepb = x1b
        fdepdb = x1db
      END IF
      swb = swb - fdepb/0.1
      swdb = swdb - fdepdb/0.1
      siwb = 0.0_8
    END IF
    GOTO 110
 100 temp11 = dhd*nbase + dh*nbased + hbcd*dnbase + hbc*dnbased
    tempb29 = aux2*dx2*dnorgdb
    tempb27 = temp11*tempb29
    temp12 = dh*nbase + hbc*dnbase
    tempb30 = aux2*(dh*nbase+hbc*dnbase)*dnorgb
    tempb26 = dx2*tempb30
    norgb = nb - tempb27 - tempb26
    norgdb = nd0b - temp12*tempb29
    tempb31 = aux2*(norg_ice*frac-norg)*dx2*dnorgb
    tempb33 = (1d0-EXP(-(aux*dx2)))*norgb
    tempb36 = -(norg_ice*frac*EXP(-(aux*dx2))*norgb)
    tempb32 = EXP(-(aux*dx2))*norgdb
    temp10 = dx2*auxd
    tempb34 = norg_ice*frac*tempb32
    tempb35 = norg_ice*frac*temp10*EXP(-(aux*dx2))*norgdb
    dx2b = aux2*((norg_ice*frac-norg)*temp11-norgd*temp12)*dnorgdb + &
&     auxd*tempb34 - aux*tempb35 - aux*tempb36 + (norg_ice*frac-norg)*&
&     tempb30
    auxb = -(dx2*tempb35) - dx2*tempb36
    auxdb = dx2*tempb34
    aux2 = (1d0/3d0-0.06d0)*pi_ice/0.76d0/2.7d-7
    dx2 = dbc_ice*dbc_ice*dbc_ice*0.52*acorr_bc
    tempb46 = aux2*(dh*nbase+hbc*dnbase)*dnbcb
    tempb24 = dx2*tempb46
    temp9 = dh*nbase + hbc*dnbase
    temp8 = dhd*nbase + dh*nbased + hbcd*dnbase + hbc*dnbased
    tempb28 = aux2*dx2*dnbcdb
    tempb25 = temp8*tempb28
    tempb40 = -(nbcd*tempb28)
    ndb = nb
    nbcb = nb - tempb25 - tempb24
    nddb = nd0b
    nbcdb = nd0b - temp9*tempb28
    norg_iceb = norg_iceb + frac*tempb27 + temp10*frac*tempb32 + frac*&
&     tempb33 + frac*tempb26
    fracb = norg_ice*tempb27 + temp10*norg_ice*tempb32 + norg_ice*&
&     tempb33 + norg_ice*tempb26
    tempb37 = (norg_ice*frac-norg)*tempb29
    tempb38 = -(norgd*tempb29)
    tempb45 = pi_ice*0.06d0*auxb/(0.76d0*9.1d-7)
    tempb42 = pi_ice*0.06d0*auxdb/9.1d-7
    CALL POPREAL8(frac)
    result2b = -(0.5d0*fracb)
    arg10b = 0.0_8
    CALL ERFAPP_B(arg10, arg10b, result2b)
    dorg_iceb = dorg_iceb + 2*dorg_ice*dx2b - arg10b/(dorg_ice*&
&     sigorg_ice*result1)
    CALL POPREAL8(arg10)
    CALL POPREAL8(result1)
    tempb41 = aux2*(nbc_ice*frac-nbc)*dx2*dnbcb
    tempb39 = (nbc_ice*frac-nbc)*tempb28
    dhb = nbased*tempb37 + nbase*tempb38 + nbased*tempb39 + nbase*&
&     tempb40 + nbase*tempb41 + nbase*tempb31
    dnbaseb = hbcd*tempb37 + hbc*tempb38 + hbcd*tempb39 + hbc*tempb40 + &
&     hbc*tempb41 + hbc*tempb31
    dhdb = nbase*tempb39 + nbase*tempb37
    dnbasedb = hbc*tempb39 + hbc*tempb37
    aux = (1d0/3d0-0.06d0)*hbc*(nbase/0.76d0)*pi_ice/2.7d-7
    tempb48 = (1d0-EXP(-(aux*dx2)))*nbcb
    tempb51 = -(nbc_ice*frac*EXP(-(aux*dx2))*nbcb)
    auxd = (1d0/3d0-0.06d0)*pi_ice*(hbcd*nbase/0.76d0+hbc*nbased/0.76d0)&
&     /2.7d-7
    tempb47 = EXP(-(aux*dx2))*nbcdb
    temp7 = dx2*auxd
    nbc_iceb = nbc_iceb + frac*tempb25 + temp7*frac*tempb47 + frac*&
&     tempb48 + frac*tempb24
    fracb = nbc_ice*tempb25 + temp7*nbc_ice*tempb47 + nbc_ice*tempb48 + &
&     nbc_ice*tempb24
    tempb49 = nbc_ice*frac*tempb47
    tempb50 = nbc_ice*frac*temp7*EXP(-(aux*dx2))*nbcdb
    dx2b = aux2*((nbc_ice*frac-nbc)*temp8-nbcd*temp9)*dnbcdb + auxd*&
&     tempb49 - aux*tempb50 - aux*tempb51 + (nbc_ice*frac-nbc)*tempb46
    auxb = -(dx2*tempb50) - dx2*tempb51
    auxdb = dx2*tempb49
    tempb44 = (1.0/3d0-0.06d0)*pi_ice*auxb/(0.76d0*2.7d-7)
    tempb43 = (1.0/3d0-0.06d0)*pi_ice*auxdb/2.7d-7
    nbaseb = dhd*tempb37 + dh*tempb38 + hbcd*tempb42/0.76d0 + dhd*&
&     tempb39 + dh*tempb40 + hbcd*tempb43/0.76d0 + hbc*tempb44 + dh*&
&     tempb41 + hbc*tempb45 + dh*tempb31
    hbcb = dnbased*tempb37 + dnbase*tempb38 + nbased*tempb42/0.76d0 + &
&     dnbased*tempb39 + dnbase*tempb40 + nbased*tempb43/0.76d0 + nbase*&
&     tempb44 + dnbase*tempb41 + nbase*tempb45 + dnbase*tempb31
    nbasedb = hbc*tempb42/0.76d0 + hbc*tempb43/0.76d0 + dh*tempb39 + dh*&
&     tempb37
    hbcdb = nbase*tempb42/0.76d0 + nbase*tempb43/0.76d0 + dnbase*tempb39&
&     + dnbase*tempb37
    CALL POPREAL8(dx2)
    CALL POPREAL8(frac)
    result2b = -(0.5d0*fracb)
    arg10b = 0.0_8
    CALL ERFAPP_B(arg10, arg10b, result2b)
    dbc_iceb = dbc_iceb + acorr_bc*0.52*3*dbc_ice**2*dx2b - arg10b/(&
&     dbc_ice*sigbc_ice*result1)
    CALL POPREAL8(result1)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      dhb = 0.0_8
      hbcdb = 0.0_8
      dhdb = 0.0_8
      hbcb = 0.0_8
    END IF
    CALL POPREAL8(dh)
    dfcb = (1d0-delw0)*dhb - delw0d*dhdb
    delw0b = (1d0-fc)*hbcb - fcd*hbcdb - dfcd*dhdb - dfc*dhb
    ddelw0b = (1d0-fc)*dhb - fcd*dhdb
    fcb = (1.0_8-delw0)*hbcb - delw0d*hbcdb - ddelw0d*dhdb - ddelw0*dhb
    CALL POPREAL8(dhd)
    dfcdb = (1d0-delw0)*dhdb
    delw0db = (1d0-fc)*hbcdb - dfc*dhdb
    ddelw0db = (1d0-fc)*dhdb
    fcdb = (1.0_8-delw0)*hbcdb - ddelw0*dhdb
    CALL POPREAL8(dfc)
    del1bc_iceb = del1bc_iceb + 0.5d0*ddel0d*dfcdb + 0.5d0*del0d*fcdb + &
&     0.5d0*del0*fcb + 0.5d0*ddel0*dfcb
    ddel0b = 0.5d0*del1bc_ice*dfcb
    CALL POPREAL8(dfcd)
    ddel0db = 0.5d0*del1bc_ice*dfcdb
    CALL POPREAL8(fc)
    del0b = 0.5d0*del1bc_ice*fcb
    CALL POPREAL8(fcd)
    del0db = 0.5d0*del1bc_ice*fcdb
    arg10 = si0bc_ice + 0.1d0
    CALL POPREAL8(ddel0)
    CALL POPREAL8(ddel0d)
    si_b = 0.0_8
    CALL DCUBICINT_ICE_D_B(si_, si_b, si_d, si_db, si0bc_ice, si0bc_iceb&
&                    , arg10, arg10b, 0d0, 1d0, ddel0, ddel0b, ddel0db)
    si0bc_iceb = si0bc_iceb + arg10b
    arg10 = si0bc_ice + 0.1d0
    CALL POPREAL8(del0)
    CALL POPREAL8(del0d)
    si_db = 0.0_8
    CALL CUBICINT_ICE_D_B(si_, si_b, si_d, si_db, si0bc_ice, si0bc_iceb&
&                   , arg10, arg10b, 0d0, 1d0, del0, del0b, del0db)
    CALL POPREAL8(arg10)
    si0bc_iceb = si0bc_iceb + arg10b
    aux2 = 2d0/3d0*pi_ice/0.76d0/5.0d-7/4d0
    aux = 2d0/3d0*hdust*(nbase/0.76d0)*pi_ice/5.0d-7/4d0
    auxd = 2d0*pi_ice*(hdustd*nbase/0.76d0+hdust*nbased/0.76d0)/3d0/&
&     5.0d-7/4d0
    hdustb = 0.0_8
    dhb = 0.0_8
    dhdb = 0.0_8
    auxb = 0.0_8
    hdustdb = 0.0_8
    auxdb = 0.0_8
    DO index=nbindust_ice,1,-1
      temp3 = ndust_ice(index)*auxd
      temp4 = frac*dx2
      dndauxb = dndb
      dndauxdb = dnddb
      tempb15 = aux2*ndaux*dx2*dndauxb
      tempb16 = aux2*(dh*nbase+hdust*dnbase)*dndauxb
      temp6 = dhd*nbase + dh*nbased + hdustd*dnbase + hdust*dnbased
      temp5 = dh*nbase + hdust*dnbase
      tempb19 = aux2*dx2*dndauxdb
      ndauxb = temp6*tempb19 + dx2*tempb16
      tempb17 = ndauxd*tempb19
      tempb18 = ndaux*tempb19
      dhb = dhb + nbase*tempb17 + nbased*tempb18 + nbase*tempb15
      nbaseb = nbaseb + dh*tempb17 + dhd*tempb18 + dh*tempb15
      hdustb = hdustb + dnbase*tempb17 + dnbased*tempb18 + dnbase*&
&       tempb15
      dnbaseb = dnbaseb + hdust*tempb17 + hdustd*tempb18 + hdust*tempb15
      ndauxdb = temp5*tempb19
      dhdb = dhdb + nbase*tempb18
      nbasedb = nbasedb + dh*tempb18
      hdustdb = hdustdb + dnbase*tempb18
      dnbasedb = dnbasedb + hdust*tempb18
      fracb = ndust_ice(index)*ndauxb
      ndust_iceb(index) = ndust_iceb(index) + frac*ndauxb
      ndauxb = ndb - ndauxb
      ndauxdb = nddb - ndauxdb
      tempb23 = (1d0-EXP(-(aux*dx2)))*ndauxb
      tempb22 = -(frac*ndust_ice(index)*EXP(-(aux*dx2))*ndauxb)
      tempb20 = EXP(-(aux*dx2))*ndauxdb
      fracb = fracb + temp3*dx2*tempb20 + ndust_ice(index)*tempb23
      ndust_iceb(index) = ndust_iceb(index) + temp4*auxd*tempb20 + frac*&
&       tempb23
      tempb21 = temp3*temp4*EXP(-(aux*dx2))*ndauxdb
      dx2b = aux2*(ndauxd*temp5+ndaux*temp6)*dndauxdb + temp3*frac*&
&       tempb20 - aux*tempb21 - aux*tempb22 + ndaux*tempb16
      CALL POPREAL8(ndaux)
      auxb = auxb - dx2*tempb21 - dx2*tempb22
      CALL POPREAL8(ndauxd)
      auxdb = auxdb + temp4*ndust_ice(index)*tempb20
      CALL POPREAL8(frac)
      result2b = -(0.5d0*fracb)
      arg10b = 0.0_8
      CALL ERFAPP_B(arg10, arg10b, result2b)
      CALL POPREAL8(arg10)
      ddust_iceb(index) = ddust_iceb(index) + acorr_dust*0.52*3*&
&       ddust_ice(index)**2*dx2b - arg10b/(ddust_ice(index)*sigdust_ice(&
&       index)*result1)
      CALL POPREAL8(result1)
      CALL POPREAL8(dx2)
    END DO
    tempb14 = pi_ice*2d0*auxdb/(3d0*5.0d-7*4d0)
    tempb13 = pi_ice*2d0*auxb/(3d0*0.76d0*5.0d-7*4d0)
    hdustb = hdustb + nbased*tempb14/0.76d0 + nbase*tempb13
    nbaseb = nbaseb + hdustd*tempb14/0.76d0 + hdust*tempb13
    hdustdb = hdustdb + nbase*tempb14/0.76d0
    nbasedb = nbasedb + hdust*tempb14/0.76d0
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      dfc = 0.5d0*del1dust_ice*ddel0
      fc = 0.5d0*del1dust_ice*del0
      dfcd = 0.5d0*del1dust_ice*ddel0d
      fcd = 0.5d0*del1dust_ice*del0d
      hdustb = 0.0_8
      dhb = 0.0_8
      dhdb = 0.0_8
      hdustdb = 0.0_8
    END IF
    dfcb = (1d0-delw0)*dhb - delw0d*dhdb
    delw0b = delw0b + (1d0-fc)*hdustb - fcd*hdustdb - dfcd*dhdb - dfc*&
&     dhb
    ddelw0b = ddelw0b + (1d0-fc)*dhb - fcd*dhdb
    fcb = (1.0_8-delw0)*hdustb - delw0d*hdustdb - ddelw0d*dhdb - ddelw0*&
&     dhb
    dfcdb = (1d0-delw0)*dhdb
    delw0db = delw0db + (1d0-fc)*hdustdb - dfc*dhdb
    ddelw0db = ddelw0db + (1d0-fc)*dhdb
    fcdb = (1.0_8-delw0)*hdustdb - ddelw0*dhdb
    del1dust_iceb = del1dust_iceb + 0.5d0*ddel0d*dfcdb + 0.5d0*del0d*&
&     fcdb + 0.5d0*del0*fcb + 0.5d0*ddel0*dfcb
    ddel0b = 0.5d0*del1dust_ice*dfcb
    ddel0db = 0.5d0*del1dust_ice*dfcdb
    del0b = 0.5d0*del1dust_ice*fcb
    del0db = 0.5d0*del1dust_ice*fcdb
    arg10 = si0dust_ice + 0.1d0
    CALL DCUBICINT_ICE_D_B(si_, si_b, si_d, si_db, si0dust_ice, &
&                    si0dust_iceb, arg10, arg10b, 0d0, 1d0, ddel0, &
&                    ddel0b, ddel0db)
    si0dust_iceb = si0dust_iceb + arg10b
    arg10 = si0dust_ice + 0.1d0
    si_db = 0.0_8
    CALL CUBICINT_ICE_D_B(si_, si_b, si_d, si_db, si0dust_ice, &
&                   si0dust_iceb, arg10, arg10b, 0d0, 1d0, del0, del0b, &
&                   del0db)
    si0dust_iceb = si0dust_iceb + arg10b
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      nbaseb = nbaseb + 3.88d0*dnbaseb
      nbasedb = nbasedb + 3.88d0*dnbasedb
    ELSE
      nbaseb = nbaseb + 12.96d0*dnbaseb
      nbasedb = nbasedb + 12.96d0*dnbasedb
    END IF
    CALL PDG07_ICE_D_B(si, sib, sid, t, nbase, nbaseb, nbasedb)
    swb = 0.0_8
    sw0b = 0.0_8
    CALL DCUBICINT_ICE_D_B(sw, swb, swd, swdb, sw0, sw0b, 1d0, &
&                    dummydiffb0, 0d0, 1d0, ddelw0, ddelw0b, ddelw0db)
    sw0b = 0.0_8
    CALL CUBICINT_ICE_D_B(sw, swb, swd, swdb, sw0, sw0b, 1d0, dummydiffb&
&                   , 0d0, 1d0, delw0, delw0b, delw0db)
    siwb = 0.0_8
 110 vpresw_iceb = vpresw_iceb + siwb/vpresi_ice
    vpresi_iceb = vpresi_iceb - vpresw_ice*siwb/vpresi_ice**2
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      sid = sixd
      si_d = sid
      si_b = si_b + sib
      vpresw_iceb = vpresw_iceb + si_b/vpresi_ice
      vpresi_iceb = vpresi_iceb - vpresw_ice*si_b/vpresi_ice**2
      si = six
      si_ = si + 1d0
      swdb = 0.0_8
      swb = 0.0_8
    END IF
    tempb0 = si_d*swdb/vpresw_ice
    tempb = si_*swb/vpresw_ice
    vpresi_iceb = vpresi_iceb + tempb0 + tempb
    vpresw_iceb = vpresw_iceb - vpresi_ice*tempb0/vpresw_ice - &
&     vpresi_ice*tempb/vpresw_ice
  END SUBROUTINE INSPEC_ICE_D_B
!  Differentiation of inspec_ice in forward (tangent) mode:
!   variations   of useful results: n dsh
!   with respect to varying inputs: six
!*************************************************************
! Subroutine INSPEC_ice
!  Provides the Ice Nuclei concentration (m-3) 
! and the chracteristic freezing threeshold, DSh (Barahona & Nenes 2009), at given 
! si and T. The variable typeofspec_ice (integer) has the values
! 1 Meyers et. al. 1992
! 2  Phillips et. al. 2007
! 3  Barahona & Nenes 2009
! 4  Phillips et. al. 2008 
! 5  Barahona,        2012 
! si is supersaturation wrt ice and T is in K 
!      Written by Donifan Barahona 
!      donifan.o.barahona@nasa.gov
!************************************************************  
  SUBROUTINE INSPEC_ICE_D(six, sixd, t, n, nd0, dsh, dshd)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: six, t
    REAL*8, INTENT(IN) :: sixd
    REAL*8, INTENT(OUT) :: n, dsh
    REAL*8, INTENT(OUT) :: nd0, dshd
    REAL*8 :: nd, nbc, aux, si_, sw, del0, ddel0, fc, delw0, ddelw0, sw0&
&   , hdust, hbc, nbase, dnd, dnbc, dnbase, dh, dfc, ndaux, dndaux, &
&   dnorg, norg, ndustaux, frac, aux2, dx2, fdep, ndep, ndhf, dndep, &
&   dndhf, si, dfrac, siw
    REAL*8 :: ndd, nbcd, auxd, si_d, swd, del0d, ddel0d, fcd, delw0d, &
&   ddelw0d, hdustd, hbcd, nbased, dndd, dnbcd, dnbased, dhd, dfcd, &
&   ndauxd, dndauxd, dnorgd, norgd, fracd, fdepd, ndepd, ndhfd, dndepd, &
&   dndhfd, sid, dfracd
!variables for DM11
    REAL*8 :: a, b, c, d, nbig, nbigexp, other
    REAL*8, DIMENSION(3) :: sig_array, the_array, frac_array
    REAL*8, DIMENSION(3) :: sig_arrayd, the_arrayd, frac_arrayd
    REAL*8 :: n_iw, dsh_s, asolo
    REAL*8 :: n_iwd, dsh_sd
    REAL*8, DIMENSION(1) :: nbc_s, dbc_s, d_grid_bio, n_grid_bio
    REAL*8, DIMENSION(1) :: nbc_sd, dbc_sd, d_grid_biod, n_grid_biod
    REAL*8, DIMENSION(nbindust_ice) :: ndust_s, ddust_s
    REAL*8, DIMENSION(nbindust_ice) :: ndust_sd
    INTEGER :: index, kindex, mode
    INTRINSIC EXP
    INTRINSIC LOG
    INTRINSIC SQRT
    INTRINSIC MIN
    INTRINSIC MAX
    REAL*8 :: arg1
    REAL*8 :: arg1d
    DOUBLE PRECISION :: result1
    REAL*8 :: result2
    REAL*8 :: pwx1
    REAL*8 :: pwr1
    REAL*8 :: x2
    REAL*8 :: x2d
    REAL*8 :: x1
    REAL*8 :: x1d
    REAL*8 :: arg10
    sid = sixd
    si = six
    si_d = sid
    si_ = si + 1d0
!new2
    swd = vpresi_ice*si_d/vpresw_ice
    sw = si_*vpresi_ice/vpresw_ice
    IF (sw .GE. 1.0) THEN
!limit to subsaturated conditions
      sw = 1.0
      si_ = vpresw_ice/vpresi_ice
      si = si_ - 1.0
      si_d = 0.0_8
      sid = 0.0_8
      swd = 0.0_8
    END IF
    siw = vpresw_ice/vpresi_ice
    sig_array = 0.0
    the_array = 0.0
    frac_array = 0.0
    fdep = 0.0
    SELECT CASE  (typeofspec_ice) 
    CASE (1) 
!Phillips2007
      nd0 = PDG07_ICE_D(si, sid, t, n)
      IF (t .LE. 243d0) THEN
        dsh = 1d0/3.88d0
        dshd = 0.0_8
      ELSE
        dsh = 1d0/12.96d0
        dshd = 0.0_8
      END IF
    CASE (2) 
!Meyers1992 
      nd0 = 1000d0*EXP(-0.639d0)*12.96d0*sid*EXP(12.96d0*si)
      n = 1000d0*EXP(-0.639d0)*(EXP(12.96d0*si)-1d0)
      dsh = 1d0/12.96d0
      dshd = 0.0_8
    CASE (3) 
!Barahona&Nenes CNT
!dust contribution
      ndustaux = 0.0d0
      DO index=1,nbindust_ice
        ndustaux = ndustaux + ndust_ice(index)
      END DO
      IF (si .LE. shdust_ice) THEN
        arg1d = kdust_ice*sid
        arg1 = -(kdust_ice*(shdust_ice-si))
        ndd = ndustaux*effdust_ice*(sid*EXP(arg1)/shdust_ice+si*arg1d*&
&         EXP(arg1)/shdust_ice)
        nd = si/shdust_ice*ndustaux*effdust_ice*EXP(arg1)
        dndd = ndd*(1d0/si+kdust_ice) - nd*sid/si**2
        dnd = nd*(1d0/si+kdust_ice)
      ELSE
        nd = ndustaux*effdust_ice
        dnd = 0d0
        dndd = 0.0_8
        ndd = 0.0_8
      END IF
!soot contribution
      IF (si .LE. shbc_ice) THEN
        arg1d = kbc_ice*sid
        arg1 = -(kbc_ice*(shbc_ice-si))
        nbcd = nbc_ice*effbc_ice*(sid*EXP(arg1)/shbc_ice+si*arg1d*EXP(&
&         arg1)/shbc_ice)
        nbc = si/shbc_ice*nbc_ice*effbc_ice*EXP(arg1)
        dnbcd = nbcd*(1d0/si+kbc_ice) - nbc*sid/si**2
        dnbc = nbc*(1d0/si+kbc_ice)
      ELSE
        nbc = nbc_ice*effbc_ice
        dnbc = 0d0
        dnbcd = 0.0_8
        nbcd = 0.0_8
      END IF
      nd0 = ndd + nbcd
      n = nd + nbc
      IF (dnd + dnbc .GT. 0d0) THEN
        dshd = (nd0*(dnd+dnbc)-n*(dndd+dnbcd))/(dnd+dnbc)**2
        dsh = n/(dnd+dnbc)
      ELSE
        dshd = sid
        dsh = si
      END IF
    CASE (4) 
!PDA2008. Allows multiple lognormal modes for dust. Single mode lognormal distributions are assumed for bc and organics
! Dust
      sw0 = 0.97d0
      delw0d = CUBICINT_ICE_D(sw, swd, sw0, 1d0, 0d0, 1d0, delw0)
      ddelw0d = DCUBICINT_ICE_D(sw, swd, sw0, 1d0, 0d0, 1d0, ddelw0)
      nbased = PDG07_ICE_D(si, sid, t, nbase)
      IF (t .LE. 243d0) THEN
        dnbased = 3.88d0*nbased
        dnbase = 3.88d0*nbase
      ELSE
        dnbased = 12.96d0*nbased
        dnbase = 12.96d0*nbase
      END IF
!dust contribution
      arg10 = si0dust_ice + 0.1d0
      del0d = CUBICINT_ICE_D(si_, si_d, si0dust_ice, arg10, 0d0, 1d0, &
&       del0)
      arg10 = si0dust_ice + 0.1d0
      ddel0d = DCUBICINT_ICE_D(si_, si_d, si0dust_ice, arg10, 0d0, 1d0, &
&       ddel0)
      fcd = 0.5d0*del1dust_ice*del0d
      fc = 0.5d0*del1dust_ice*del0
      dfcd = 0.5d0*del1dust_ice*ddel0d
      dfc = 0.5d0*del1dust_ice*ddel0
      hdustd = fcd + (1d0-fc)*delw0d - fcd*delw0
      hdust = fc + (1d0-fc)*delw0
      dhd = dfcd*(1d0-delw0) - dfc*delw0d + ddelw0d*(1d0-fc) - ddelw0*&
&       fcd
      dh = dfc*(1d0-delw0) + ddelw0*(1d0-fc)
      IF (hdust .GT. 1d0) THEN
        hdust = 1d0
        dh = 0d0
        hdustd = 0.0_8
        dhd = 0.0_8
      END IF
      auxd = 2d0*pi_ice*(hdustd*nbase/0.76d0+hdust*nbased/0.76d0)/3d0/&
&       5.0d-7/4d0
      aux = 2d0/3d0*hdust*(nbase/0.76d0)*pi_ice/5.0d-7/4d0
!The last 4d0 was introduced as recommnedation of V Phillips
      aux2 = 2d0/3d0*pi_ice/0.76d0/5.0d-7/4d0
      nd = 0d0
      dnd = 0d0
      dndd = 0.0_8
      ndd = 0.0_8
      DO index=1,nbindust_ice
!Dx2= ddust_ice(index)*ddust_ice(index)
!new 07/10/12
        dx2 = ddust_ice(index)*ddust_ice(index)*ddust_ice(index)*0.52*&
&         acorr_dust
!fraction above 0.1 microns
!sigma_dust=log(sigma_bc_g)
        result1 = SQRT(2d0)
        arg10 = -(LOG(ddust_ice(index)/0.1e-6)/sigdust_ice(index)/&
&         result1)
        result2 = ERFAPP(arg10)
        frac = 0.5d0*(1d0-result2)
        ndauxd = frac*ndust_ice(index)*dx2*auxd*EXP(-(aux*dx2))
        ndaux = frac*ndust_ice(index)*(1d0-EXP(-(aux*dx2)))
        ndd = ndd + ndauxd
        nd = nd + ndaux
        ndauxd = -ndauxd
        ndaux = frac*ndust_ice(index) - ndaux
        dndauxd = aux2*dx2*(ndauxd*(dh*nbase+hdust*dnbase)+ndaux*(dhd*&
&         nbase+dh*nbased+hdustd*dnbase+hdust*dnbased))
        dndaux = ndaux*(dh*nbase+hdust*dnbase)*aux2*dx2
        dndd = dndd + dndauxd
        dnd = dnd + dndaux
      END DO
!soot contribution
      arg10 = si0bc_ice + 0.1d0
      del0d = CUBICINT_ICE_D(si_, si_d, si0bc_ice, arg10, 0d0, 1d0, del0&
&       )
      arg10 = si0bc_ice + 0.1d0
      ddel0d = DCUBICINT_ICE_D(si_, si_d, si0bc_ice, arg10, 0d0, 1d0, &
&       ddel0)
      fcd = 0.5d0*del1bc_ice*del0d
      fc = 0.5d0*del1bc_ice*del0
      hbcd = fcd + (1d0-fc)*delw0d - fcd*delw0
      hbc = fc + (1d0-fc)*delw0
      dfcd = 0.5d0*del1bc_ice*ddel0d
      dfc = 0.5d0*del1bc_ice*ddel0
      dhd = dfcd*(1d0-delw0) - dfc*delw0d + ddelw0d*(1d0-fc) - ddelw0*&
&       fcd
      dh = dfc*(1d0-delw0) + ddelw0*(1d0-fc)
      IF (hbc .GT. 1d0) THEN
        hbc = 1d0
        dh = 0d0
        dhd = 0.0_8
        hbcd = 0.0_8
      END IF
!sigbc=log(sigma_bc_g)
      result1 = SQRT(2d0)
      arg10 = -(LOG(dbc_ice/0.1e-6)/sigbc_ice/result1)
      result2 = ERFAPP(arg10)
      frac = 0.5d0*(1d0-result2)
!Dx2=dbc_ice*dbc_ice	       
!new 07/10/12
      dx2 = dbc_ice*dbc_ice*dbc_ice*0.52*acorr_bc
      auxd = (1d0/3d0-0.06d0)*pi_ice*(hbcd*nbase/0.76d0+hbc*nbased/&
&       0.76d0)/2.7d-7
      aux = (1d0/3d0-0.06d0)*hbc*(nbase/0.76d0)*pi_ice/2.7d-7
      aux2 = (1d0/3d0-0.06d0)*pi_ice/0.76d0/2.7d-7
      nbcd = nbc_ice*frac*dx2*auxd*EXP(-(aux*dx2))
      nbc = nbc_ice*frac*(1d0-EXP(-(aux*dx2)))
      dnbcd = aux2*dx2*((nbc_ice*frac-nbc)*(dhd*nbase+dh*nbased+hbcd*&
&       dnbase+hbc*dnbased)-nbcd*(dh*nbase+hbc*dnbase))
      dnbc = (nbc_ice*frac-nbc)*(dh*nbase+hbc*dnbase)*aux2*dx2
!Organics contribution
!sigorg=log(sigma_org_g)
      result1 = SQRT(2d0)
      arg10 = -(LOG(dorg_ice/0.1e-6)/sigorg_ice/result1)
      result2 = ERFAPP(arg10)
      frac = 0.5d0*(1d0-result2)
      dx2 = dorg_ice*dorg_ice
      auxd = 0.06d0*pi_ice*(hbcd*nbase/0.76d0+hbc*nbased/0.76d0)/9.1d-7
      aux = 0.06d0*hbc*(nbase/0.76d0)*pi_ice/9.1d-7
      aux2 = 0.06d0*pi_ice/0.76d0/9.1d-7
      norgd = norg_ice*frac*dx2*auxd*EXP(-(aux*dx2))
      norg = norg_ice*frac*(1d0-EXP(-(aux*dx2)))
      dnorgd = aux2*dx2*((norg_ice*frac-norg)*(dhd*nbase+dh*nbased+hbcd*&
&       dnbase+hbc*dnbased)-norgd*(dh*nbase+hbc*dnbase))
      dnorg = (norg_ice*frac-norg)*(dh*nbase+hbc*dnbase)*aux2*dx2
      nd0 = ndd + nbcd + norgd
      n = nd + nbc + norg
      IF (dnd + dnbc + dnorg .GT. 0d0) THEN
        dshd = (nd0*(dnd+dnbc+dnorg)-n*(dndd+dnbcd+dnorgd))/(dnd+dnbc+&
&         dnorg)**2
        dsh = n/(dnd+dnbc+dnorg)
      ELSE
        dshd = sid
        dsh = si
      END IF
    CASE (5) 
!Phillips et al 2013.
      d_grid_biod(1) = 0.0_8
      d_grid_bio(1) = dbio_ice
      n_grid_biod(1) = 0.0_8
      n_grid_bio(1) = nbio_ice
!dust
      DO index=1,nbindust_ice
!fraction above 0.1 microns
        result1 = SQRT(2d0)
        arg10 = LOG(0.1e-6/ddust_ice(index))/sigdust_ice(index)/result1
        result2 = ERFAPP(arg10)
        frac = 0.5d0*(1d0-result2)
        ndust_sd(index) = 0.0_8
        ndust_s(index) = frac*ndust_ice(index)
        ddust_s = ddust_ice(index)
      END DO
!black carbon
!fraction above 0.1 microns
      result1 = SQRT(2d0)
      arg10 = LOG(0.1e-6/dbc_ice)/sigbc_ice/result1
      result2 = ERFAPP(arg10)
      frac = 0.5d0*(1d0-result2)
      nbc_sd(1) = 0.0_8
      nbc_s(1) = frac*nbc_ice
      IF (dbc_ice .GT. 2.e-6) THEN
        dbc_ice = 2.e-6
      ELSE
        dbc_ice = dbc_ice
      END IF
      dbc_sd(1) = 0.0_8
      dbc_s(1) = dbc_ice*1.0
!Soluble organics (spherical)
!sigorg=log(sigma_org_g) !20-30% of organics are soluble (Saxena and HIdeelman 1996). 
      result1 = SQRT(2d0)
      arg10 = LOG(0.1e-6/dorg_ice)/sigorg_ice/result1
      result2 = ERFAPP(arg10)
      frac = 0.25d0*0.5d0*(1d0-result2)
!
      asolo = frac*norg_ice*3.1415*dorg_ice*dorg_ice
      CALL EMPIRICAL_PARAM_PHILLIPS_D(t, pice, si_, si_d, siw, sw, swd, &
&                               ddust_s, ndust_s, 2, dbc_s, nbc_s, 1, &
&                               d_grid_bio, n_grid_bio, 1, asolo, n_iw, &
&                               n_iwd, dsh_s, dsh_sd)
      nd0 = n_iwd
      n = n_iw
      dshd = dsh_sd
      dsh = dsh_s
    CASE (6) 
!Barahona 2012. Spectrum based on NPDF-Theory and CNT (Unpublished)
!dust contribution*******************************************
!linear approx to decide DHF vs deposition, loosely based on Seisel 2005.
      fdepd = (-swd)/0.1
      fdep = (1.0-sw)/0.1
      IF (fdep .LT. 0.0) THEN
        x1 = 0.0
        x1d = 0.0_8
      ELSE
        x1d = fdepd
        x1 = fdep
      END IF
      IF (x1 .GT. 1.0) THEN
        fdep = 1.0
        fdepd = 0.0_8
      ELSE
        fdepd = x1d
        fdep = x1
      END IF
      nd = 0.0
      dnd = 0.0
!Deposition *******
!deposition             
      mode = 1
      sig_arrayd(1) = 0.0_8
      sig_array(1) = 21.4
      sig_arrayd(2) = 0.0_8
      sig_array(2) = 21.4
      sig_arrayd(3) = 0.0_8
      sig_array(3) = 21.4
      the_arrayd(1) = 0.0_8
      the_array(1) = 9.9
      the_arrayd(2) = 0.0_8
      the_array(2) = 15.1
      the_arrayd(3) = 0.0_8
      the_array(3) = 19.8
      frac_arrayd(1) = 0.0_8
      frac_array(1) = 0.20
      frac_arrayd(2) = 0.0_8
      frac_array(2) = 0.25
      frac_arrayd(3) = 0.0_8
      frac_array(3) = 0.55
      dgh_ice = 0.0
      ndep = 0.0
      dndep = 0.0
      dndepd = 0.0_8
      ndepd = 0.0_8
      DO index=1,nbindust_ice
!new 07/10/12    
        dx2 = ddust_ice(index)*ddust_ice(index)*ddust_ice(index)*0.52*&
&         acorr_dust
!Dx2= ddust_ice(index)*ddust_ice(index)*pi_ice*4.0 !Assume spheres by now
        CALL NUC_FRAC_D(frac, fracd, dfrac, dfracd, sig_array, the_array&
&                 , frac_array, t, si_, si_d, mode, dx2, adust_dep, 3)
        ndauxd = ndust_ice(index)*(fracd*fdep+frac*fdepd)
        ndaux = frac*ndust_ice(index)*fdep
        ndepd = ndepd + ndauxd
        ndep = ndep + ndaux
        dndauxd = ndust_ice(index)*(dfracd*fdep+dfrac*fdepd)
        dndaux = dfrac*ndust_ice(index)*fdep
        dndepd = dndepd + dndauxd
        dndep = dndep + dndaux
      END DO
!immersion *******
      mode = 3
!sig_array=(/ 10.0, 10.0, 10.0 /)
!the_array=(/ 85.0, 85.0, 85.0 /)
!frac_array=(/ 1.0, 0.0, 0.0 /)      
      sig_arrayd(1) = 0.0_8
      sig_array(1) = 1.014
      sig_arrayd(2) = 0.0_8
      sig_array(2) = 1.014
      sig_arrayd(3) = 0.0_8
      sig_array(3) = 1.014
      the_arrayd(1) = 0.0_8
      the_array(1) = 53.44
      the_arrayd(2) = 0.0_8
      the_array(2) = 53.44
      the_arrayd(3) = 0.0_8
      the_array(3) = 53.44
      frac_arrayd(1) = 0.0_8
      frac_array(1) = 1.0
      frac_arrayd(2) = 0.0_8
      frac_array(2) = 0.0
      frac_arrayd(3) = 0.0_8
      frac_array(3) = 0.0
      dgh_ice = 0.5
      ndhf = 0.0
      dndhf = 0.0
      dndhfd = 0.0_8
      ndhfd = 0.0_8
      DO index=1,nbindust_ice
!new 07/10/12
        dx2 = ddust_ice(index)*ddust_ice(index)*ddust_ice(index)*0.52*&
&         acorr_dust
!Dx2= ddust_ice(index)*ddust_ice(index)*pi_ice*4.0 !Assume spheres by now
        CALL NUC_FRAC_D(frac, fracd, dfrac, dfracd, sig_array, the_array&
&                 , frac_array, t, si_, si_d, mode, dx2, aimm, 1)
        ndauxd = ndust_ice(index)*(fracd*(1.0-fdep)-frac*fdepd)
        ndaux = frac*ndust_ice(index)*(1.0-fdep)
        ndhfd = ndhfd + ndauxd
        ndhf = ndhf + ndaux
        dndauxd = ndust_ice(index)*(dfracd*(1.0-fdep)-dfrac*fdepd)
        dndaux = dfrac*ndust_ice(index)*(1.0-fdep)
        dndhfd = dndhfd + dndauxd
        dndhf = dndhf + dndaux
      END DO
      ndd = ndepd + ndhfd
      nd = ndep + ndhf
      dndd = dndepd + dndhfd
      dnd = dndep + dndhf
!soot contribution*****************************************
!linear approx to decide DHF vs deposition, loosely based on Seisel 2005.
      fdepd = (-swd)/0.1
      fdep = (1.0-sw)/0.1
      IF (fdep .LT. 0.0) THEN
        x2 = 0.0
        x2d = 0.0_8
      ELSE
        x2d = fdepd
        x2 = fdep
      END IF
      IF (x2 .GT. 1.0) THEN
        fdep = 1.0
        fdepd = 0.0_8
      ELSE
        fdepd = x2d
        fdep = x2
      END IF
      nbc = 0.0
      dnbc = 0.0
!deposition***
      mode = 1
      sig_arrayd(1) = 0.0_8
      sig_array(1) = 28.3
      sig_arrayd(2) = 0.0_8
      sig_array(2) = 28.3
      sig_arrayd(3) = 0.0_8
      sig_array(3) = 28.3
      the_arrayd(1) = 0.0_8
      the_array(1) = 34.2
      the_arrayd(2) = 0.0_8
      the_array(2) = 34.2
      the_arrayd(3) = 0.0_8
      the_array(3) = 34.2
      frac_arrayd(1) = 0.0_8
      frac_array(1) = 1.0
      frac_arrayd(2) = 0.0_8
      frac_array(2) = 0.0
      frac_arrayd(3) = 0.0_8
      frac_array(3) = 0.0
      dgh_ice = 0.0
!new 07/10/12
      dx2 = dbc_ice*dbc_ice*dbc_ice*0.52*acorr_bc
!Dx2=100.0e-12  !Popovicheva 2006. Not safe assuming spheres      
      CALL NUC_FRAC_D(frac, fracd, dfrac, dfracd, sig_array, the_array, &
&               frac_array, t, si_, si_d, mode, dx2, abc_dep, 1)
      ndepd = nbc_ice*(fracd*fdep+frac*fdepd)
      ndep = frac*nbc_ice*fdep
      dndepd = nbc_ice*(dfracd*fdep+dfrac*fdepd)
      dndep = dfrac*nbc_ice*fdep
!Immersion***	 
      mode = 3
!sig_array=(/ 3.0, 3.0, 3.0 /)
!the_array=(/ 153.8, 153.8, 153.8/) !Barahona, in prep
      sig_arrayd(1) = 0.0_8
      sig_array(1) = 2.7988
      sig_arrayd(2) = 0.0_8
      sig_array(2) = 2.7
      sig_arrayd(3) = 0.0_8
      sig_array(3) = 2.7
      the_arrayd(1) = 0.0_8
      the_array(1) = 49.1769
      the_arrayd(2) = 0.0_8
      the_array(2) = 49.1769
      the_arrayd(3) = 0.0_8
      the_array(3) = 49.0
      frac_arrayd(1) = 0.0_8
      frac_array(1) = 1.0
      frac_arrayd(2) = 0.0_8
      frac_array(2) = 0.0
      frac_arrayd(3) = 0.0_8
      frac_array(3) = 0.0
      dgh_ice = 6.45
      CALL NUC_FRAC_D(frac, fracd, dfrac, dfracd, sig_array, the_array, &
&               frac_array, t, si_, si_d, mode, dx2, aimm, 1)
      ndhfd = nbc_ice*(fracd*(1.0-fdep)-frac*fdepd)
      ndhf = frac*nbc_ice*(1.0-fdep)
      dndhfd = nbc_ice*(dfracd*(1.0-fdep)-dfrac*fdepd)
      dndhf = dfrac*nbc_ice*(1.0-fdep)
      nbcd = ndepd + ndhfd
      nbc = ndep + ndhf
      dnbcd = dndepd + dndhfd
      dnbc = dndep + dndhf
!Total   	 
      nd0 = ndd + nbcd
      n = nd + nbc
      IF (dnd + dnbc .GT. 0d0) THEN
        dshd = (nd0*(dnd+dnbc)-n*(dndd+dnbcd))/(dnd+dnbc)**2
        dsh = n/(dnd+dnbc)
      ELSE
        dshd = sid
        dsh = si
      END IF
    CASE (7) 
!DeMott 2011
      frac = 0.0d0
      nd = 0.0d0
      nbc = 0.0d0
      norg = 0.0d0
      nbig = 0.0d0
      a = 0.0000594d0
      b = 3.33d0
      c = 0.0264d0
      d = 0.0033d0
!dust number with D > 0.5 um
      DO index=1,nbindust_ice
!fraction above 0.5 microns
        result1 = SQRT(2d0)
        arg10 = -(LOG(ddust_ice(index)/0.5d-6)/sigdust_ice(index)/&
&         result1)
        result2 = ERFAPP(arg10)
        frac = 0.5d0*(1d0-result2)
        nd = nd + frac*ndust_ice(index)
      END DO
!BC number with D > 0.5 um
!sigbc=log(sigma_bc_g)
      result1 = SQRT(2d0)
      arg10 = -(LOG(dbc_ice/0.5d-6)/sigbc_ice/result1)
      result2 = ERFAPP(arg10)
      frac = 0.5d0*(1d0-result2)
      nbc = frac*nbc_ice
!org number with D > 0.5 um
!sigorg=log(sigma_org_g)
      result1 = SQRT(2d0)
      arg10 = -(LOG(dorg_ice/0.5d-6)/sigorg_ice/result1)
      result2 = ERFAPP(arg10)
      frac = 0.5d0*(1d0-result2)
      norg = frac*norg_ice
      nbig = nd + nbc + norg
!nbig must be in cc-1
      nbig = nbig/10d6
      nbigexp = c*(273.16d0-t) + d
      pwx1 = 273.16d0 - t
      pwr1 = pwx1**b
      n = a*pwr1
      other = nbig**nbigexp
      n = n*other
!N should be output in m-3
      n = n*1000d0
      dshd = sid
      dsh = si
      nd0 = 0.0_8
    CASE DEFAULT
      n = 0d0
      dshd = sid
      dsh = si
      nd0 = 0.0_8
    END SELECT
    IF (dsh .GE. si) THEN
      dshd = sid
      dsh = si
    END IF
  END SUBROUTINE INSPEC_ICE_D
!  Differentiation of cubicint_ice_d in reverse (adjoint) mode:
!   gradient     of useful results: y1 cubicint_ice_d y yd cubicint_ice
!   with respect to varying inputs: y1 y2 y yd
!  Differentiation of cubicint_ice in forward (tangent) mode:
!   variations   of useful results: cubicint_ice
!   with respect to varying inputs: y
!*************************************************************
!   Function cubicint_ice (cubic interpolation between y1 and y2 within a and b).  
!************************************************************  
  SUBROUTINE CUBICINT_ICE_D_B(y, yb, yd, ydb, y1, y1b, y2, y2b, a, b, &
&   cubicint_ice, cubicint_iceb, cubicint_ice_db)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: y, y1, y2, a, b
    REAL*8 :: yb, y1b, y2b
    REAL*8, INTENT(IN) :: yd
    REAL*8 :: ydb
    REAL*8 :: a_, b_, a0, a1, a2, a3, d, aux
    REAL*8 :: a_b, b_b, a0b, a1b, a2b, a3b, db, auxb
    REAL*8 :: dd
    REAL*8 :: ddb
    REAL*8 :: cubicint_ice
    REAL*8 :: cubicint_iceb
    INTEGER :: branch
    REAL*8 :: cubicint_ice_d
    REAL*8 :: cubicint_ice_db
    REAL*8 :: temp0
    REAL*8 :: tempb3
    REAL*8 :: tempb2
    REAL*8 :: tempb1
    REAL*8 :: tempb0
    REAL*8 :: tempb
    REAL*8 :: temp
    IF (y .LE. y1) THEN
      CALL PUSHCONTROL2B(0)
    ELSE IF (y .GE. y2) THEN
      CALL PUSHCONTROL2B(1)
    ELSE
      aux = y2 - y1
      a_ = 6d0*(a-b)/(aux*aux*aux)
      a1 = a_*y1*y2
      a2 = -(a_*(y1+y2)*0.5d0)
      a3 = a_/3d0
      CALL PUSHCONTROL2B(2)
    END IF
    db = cubicint_iceb
    ddb = cubicint_ice_db
    CALL POPCONTROL2B(branch)
    IF (branch .EQ. 0) THEN
      y2b = 0.0_8
    ELSE IF (branch .EQ. 1) THEN
      y2b = 0.0_8
    ELSE
      tempb1 = a3*ddb
      tempb0 = y*tempb1
      temp0 = yd*y + y*yd
      tempb = a2*ddb
      a0b = db
      a1b = yd*ddb + y*db
      yb = yb + 2*yd*tempb + 2*yd*tempb0 + (yd*2*y+temp0)*tempb1 + (a3*3&
&       *y**2+a2*2*y+a1)*db
      a2b = (yd*y+y*yd)*ddb + y**2*db
      a3b = (temp0*y+y**2*yd)*ddb + y**3*db
      ydb = ydb + y**2*tempb1 + 2*y*tempb0 + 2*y*tempb + a1*ddb
      tempb3 = -(0.5d0*a_*a2b)
      b_b = a0b
      tempb2 = -(0.5d0*y1**2*b_b)
      a_b = y1**3*b_b/6d0 - 0.5d0*(y1+y2)*a2b + y2*tempb2 + y2*y1*a1b + &
&       a3b/3d0
      temp = aux**3
      auxb = -((a-b)*6d0*3*aux**2*a_b/temp**2)
      y1b = y1b + y2*a_*a1b - auxb + (a_*3*y1**2/6d0-a_*y2*0.5d0*2*y1)*&
&       b_b + tempb3
      y2b = a_*y1*a1b + auxb + a_*tempb2 + tempb3
    END IF
  END SUBROUTINE CUBICINT_ICE_D_B
!  Differentiation of cubicint_ice in forward (tangent) mode:
!   variations   of useful results: cubicint_ice
!   with respect to varying inputs: y
!*************************************************************
!   Function cubicint_ice (cubic interpolation between y1 and y2 within a and b).  
!************************************************************  
  REAL*8 FUNCTION CUBICINT_ICE_D(y, yd, y1, y2, a, b, cubicint_ice)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: y, y1, y2, a, b
    REAL*8, INTENT(IN) :: yd
    REAL*8 :: a_, b_, a0, a1, a2, a3, d, aux
    REAL*8 :: dd
    REAL*8 :: cubicint_ice
    IF (y .LE. y1) THEN
      d = a
      dd = 0.0_8
    ELSE IF (y .GE. y2) THEN
      d = b
      dd = 0.0_8
    ELSE
      aux = y2 - y1
      a_ = 6d0*(a-b)/(aux*aux*aux)
      b_ = a + a_*(y1*y1*y1)/6d0 - a_*(y1*y1)*y2*0.5d0
      a0 = b_
      a1 = a_*y1*y2
      a2 = -(a_*(y1+y2)*0.5d0)
      a3 = a_/3d0
      dd = a1*yd + a2*(yd*y+y*yd) + a3*((yd*y+y*yd)*y+y**2*yd)
      d = a0 + a1*y + a2*y*y + a3*y*y*y
    END IF
    cubicint_ice_d = dd
    cubicint_ice = d
  END FUNCTION CUBICINT_ICE_D
!  Differentiation of dcubicint_ice_d in reverse (adjoint) mode:
!   gradient     of useful results: y1 y dcubicint_ice dcubicint_ice_d
!   with respect to varying inputs: y1 y2 y yd
!  Differentiation of dcubicint_ice in forward (tangent) mode:
!   variations   of useful results: dcubicint_ice
!   with respect to varying inputs: y
!*************************************************************
!   Function dcubicint_ice (used in the PDA08 spectrum).  
!************************************************************  
  SUBROUTINE DCUBICINT_ICE_D_B(y, yb, yd, ydb, y1, y1b, y2, y2b, a, b, &
&   dcubicint_ice, dcubicint_iceb, dcubicint_ice_db)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: y, y1, y2, a, b
    REAL*8 :: yb, y1b, y2b
    REAL*8, INTENT(IN) :: yd
    REAL*8 :: ydb
    REAL*8 :: a_, a0, a1, a2, a3, d, aux
    REAL*8 :: a_b, a1b, a2b, a3b, db, auxb
    REAL*8 :: dd
    REAL*8 :: ddb
    REAL*8 :: dcubicint_ice
    REAL*8 :: dcubicint_iceb
    INTEGER :: branch
    REAL*8 :: dcubicint_ice_d
    REAL*8 :: dcubicint_ice_db
    REAL*8 :: tempb0
    REAL*8 :: tempb
    REAL*8 :: temp
    IF (y .LE. y1) THEN
      CALL PUSHCONTROL2B(0)
    ELSE IF (y .GE. y2) THEN
      CALL PUSHCONTROL2B(1)
    ELSE
      aux = y2 - y1
      a_ = 6d0*(a-b)/(aux*aux*aux)
      a2 = -(a_*(y1+y2)*0.5d0)
      a3 = a_/3d0
      CALL PUSHCONTROL2B(2)
    END IF
    db = dcubicint_iceb
    ddb = dcubicint_ice_db
    CALL POPCONTROL2B(branch)
    IF (branch .EQ. 0) THEN
      y2b = 0.0_8
      ydb = 0.0_8
    ELSE IF (branch .EQ. 1) THEN
      y2b = 0.0_8
      ydb = 0.0_8
    ELSE
      tempb = 3d0*a3*ddb
      a1b = db
      a2b = 2d0*yd*ddb + 2d0*y*db
      yb = yb + 2*yd*tempb + (a3*3d0*2*y+2d0*a2)*db
      a3b = 3d0*(yd*y+y*yd)*ddb + 3d0*y**2*db
      ydb = 2*y*tempb + 2d0*a2*ddb
      a_b = y2*y1*a1b - 0.5d0*(y1+y2)*a2b + a3b/3d0
      tempb0 = -(0.5d0*a_*a2b)
      temp = aux**3
      auxb = -((a-b)*6d0*3*aux**2*a_b/temp**2)
      y1b = y1b + y2*a_*a1b - auxb + tempb0
      y2b = a_*y1*a1b + auxb + tempb0
    END IF
  END SUBROUTINE DCUBICINT_ICE_D_B
!  Differentiation of dcubicint_ice in forward (tangent) mode:
!   variations   of useful results: dcubicint_ice
!   with respect to varying inputs: y
!*************************************************************
!   Function dcubicint_ice (used in the PDA08 spectrum).  
!************************************************************  
  REAL*8 FUNCTION DCUBICINT_ICE_D(y, yd, y1, y2, a, b, dcubicint_ice)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: y, y1, y2, a, b
    REAL*8, INTENT(IN) :: yd
    REAL*8 :: a_, a0, a1, a2, a3, d, aux
    REAL*8 :: dd
    REAL*8 :: dcubicint_ice
    IF (y .LE. y1) THEN
      d = 0
      dd = 0.0_8
    ELSE IF (y .GE. y2) THEN
      d = 0
      dd = 0.0_8
    ELSE
      aux = y2 - y1
      a_ = 6d0*(a-b)/(aux*aux*aux)
      a1 = a_*y1*y2
      a2 = -(a_*(y1+y2)*0.5d0)
      a3 = a_/3d0
      dd = 2d0*a2*yd + 3d0*a3*(yd*y+y*yd)
      d = a1 + 2d0*a2*y + 3d0*a3*y*y
    END IF
    dcubicint_ice_d = dd
    dcubicint_ice = d
  END FUNCTION DCUBICINT_ICE_D
!  Differentiation of pdg07_ice_d in reverse (adjoint) mode:
!   gradient     of useful results: pdg07_ice_d pdg07_ice si
!   with respect to varying inputs: si
!  Differentiation of pdg07_ice in forward (tangent) mode:
!   variations   of useful results: pdg07_ice
!   with respect to varying inputs: si
!*************************************************************
! Function PDG07 (simplified ice nucleation 
!                     spectra according to Phillips et. al. 2007).  
! si is supersaturation wrt ice and T is in K 
!************************************************************  
  SUBROUTINE PDG07_ICE_D_B(si, sib, sid, t, pdg07_ice, pdg07_iceb, &
&   pdg07_ice_db)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: si, t
    REAL*8 :: sib
    REAL*8, INTENT(IN) :: sid
    REAL*8 :: n
    REAL*8 :: nb
    REAL*8 :: nd
    REAL*8 :: ndb
    INTRINSIC EXP
    REAL*8 :: pdg07_ice
    REAL*8 :: pdg07_iceb
    INTEGER :: branch
    REAL*8 :: pdg07_ice_db
    REAL*8 :: pdg07_ice_d
    IF (t .LE. 243d0) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    nb = pdg07_iceb
    ndb = pdg07_ice_db
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      sib = sib + EXP(3.88d0*si)*EXP(-0.388d0)*sid*3.88d0**2*1000d0*ndb &
&       + EXP(3.88d0*si)*EXP(-0.388d0)*1000d0*3.88d0*nb
    ELSE
      sib = sib + EXP(12.96d0*si)*EXP(-0.639d0)*sid*12.96d0**2*60d0*ndb &
&       + EXP(12.96d0*si)*EXP(-0.639d0)*60d0*12.96d0*nb
    END IF
  END SUBROUTINE PDG07_ICE_D_B
!  Differentiation of pdg07_ice in forward (tangent) mode:
!   variations   of useful results: pdg07_ice
!   with respect to varying inputs: si
!*************************************************************
! Function PDG07 (simplified ice nucleation 
!                     spectra according to Phillips et. al. 2007).  
! si is supersaturation wrt ice and T is in K 
!************************************************************  
  REAL*8 FUNCTION PDG07_ICE_D(si, sid, t, pdg07_ice)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: si, t
    REAL*8, INTENT(IN) :: sid
    REAL*8 :: n
    REAL*8 :: nd
    INTRINSIC EXP
    REAL*8 :: pdg07_ice
    IF (t .LE. 243d0) THEN
      nd = 1000d0*EXP(-0.388d0)*3.88d0*sid*EXP(3.88d0*si)
      n = 1000d0*EXP(-0.388d0)*(EXP(3.88d0*si)-1d0)
    ELSE
      nd = 60d0*EXP(-0.639d0)*12.96d0*sid*EXP(12.96d0*si)
      n = 60d0*EXP(-0.639d0)*(EXP(12.96d0*si)-1d0)
    END IF
    pdg07_ice_d = nd
    pdg07_ice = n
  END FUNCTION PDG07_ICE_D
!  Differentiation of nuc_frac_d in reverse (adjoint) mode:
!   gradient     of useful results: dtnuc_dhf waux_ice dtnuc_dep
!                aimm dact_imm lmeff_ice vw_ice denice_ice vpresw_ice
!                vpresi_ice fracd dfracd t ahet dfrac frac si_
!                a
!   with respect to varying inputs: dtnuc_dhf waux_ice dtnuc_dep
!                aimm dact_imm lmeff_ice vw_ice denice_ice vpresw_ice
!                vpresi_ice t ahet si_ a
!  Differentiation of nuc_frac in forward (tangent) mode:
!   variations   of useful results: dfrac frac
!   with respect to varying inputs: si_
!*************************************************************
! Subroutine nucfrac
! Calculates the ice nucleation fraction according to Barahona et al . 2012 (in prep) 
!************************************************************  
  SUBROUTINE NUC_FRAC_D_B(frac, fracb, fracd, fracdb, dfrac, dfracb, &
&   dfracd, dfracdb, sig_array, the_array, frac_array, t, tb, si_, si_b&
&   , si_d, mode, ahet, ahetb, a, ab, nlogmodes)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: si_, ahet, a, t
    REAL*8 :: si_b, ahetb, ab, tb
    REAL*8, INTENT(IN) :: si_d
    REAL*8, DIMENSION(:) :: the_array, frac_array, sig_array
    INTEGER, INTENT(IN) :: nlogmodes, mode
    REAL*8 :: frac, dfrac
    REAL*8 :: fracb, dfracb
    REAL*8 :: fracd, dfracd
    REAL*8 :: fracdb, dfracdb
    REAL*8 :: phi, j, dtnuc, fder, aux
    REAL*8 :: phib, jb, dtnucb, fderb, auxb
    REAL*8 :: phid, jd, dtnucd, fderd, auxd
    REAL*8 :: phidb, jdb, dtnucdb, fderdb, auxdb
    INTEGER :: kindex
    INTRINSIC LOG
    INTRINSIC SQRT
    INTRINSIC EXP
    REAL*8 :: result1
    REAL*8 :: result1b
    REAL*8 :: result1d
    REAL*8 :: result1db
    REAL*8 :: arg1
    REAL*8 :: arg1b
    REAL*8 :: arg1d
    REAL*8 :: arg1db
    INTEGER :: branch
    REAL*8 :: tempb1
    REAL*8 :: tempb0
    REAL*8 :: tempb
    REAL*8 :: temp
    DO kindex=1,nlogmodes
      CALL PUSHREAL8(fderd)
      CALL PUSHREAL8(fder)
      CALL PUSHREAL8(dtnucd)
      CALL PUSHREAL8(dtnuc)
      CALL PUSHREAL8(jd)
      CALL PUSHREAL8(j)
      CALL JHET_D(j, jd, dtnuc, dtnucd, fder, fderd, si_, si_d, t, &
&           the_array(kindex), mode, a)
      phid = ahet*(dtnucd*j+dtnuc*jd)
      phi = dtnuc*j*ahet
      IF (phi .GT. 0.0) THEN
        CALL PUSHREAL8(result1)
        result1 = SQRT(pi_ice)
        CALL PUSHREAL8(auxd)
        auxd = phid/phi/sig_array(kindex)/result1
        CALL PUSHREAL8(aux)
        aux = LOG(phi)/sig_array(kindex)/result1
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    fracb = -fracb
    fracdb = -fracdb
    DO kindex=nlogmodes,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        fracdb = 0.0_8
        dfracdb = 0.0_8
        dfracb = 0.0_8
        fracb = 0.0_8
        fderb = 0.0_8
        fderdb = 0.0_8
        phib = 0.0_8
        phidb = 0.0_8
      ELSE
        tempb0 = frac_array(kindex)*dfracdb/(sig_array(kindex)*pi_ice)
        arg1d = -(2*aux*auxd)
        arg1 = -(aux**2)
        arg1b = (fderd*EXP(arg1)+arg1d*fder*EXP(arg1))*tempb0 + fder*&
&         frac_array(kindex)*EXP(arg1)*dfracb/(sig_array(kindex)*pi_ice)
        tempb1 = EXP(arg1)*tempb0
        fderb = arg1d*tempb1 + EXP(arg1)*frac_array(kindex)*dfracb/(&
&         sig_array(kindex)*pi_ice)
        arg1db = fder*tempb1
        fderdb = EXP(arg1)*tempb0
        auxb = -(2*auxd*arg1db) - 2*aux*arg1b
        auxdb = -(2*aux*arg1db)
        result1b = -(0.5*frac_array(kindex)*fracb)
        result1db = -(frac_array(kindex)*0.5*fracdb)
        phi = dtnuc*j*ahet
        phid = ahet*(dtnucd*j+dtnuc*jd)
        CALL ERFAPP_D_B(aux, auxb, auxd, auxdb, result1, result1b, &
&                 result1db)
        CALL POPREAL8(aux)
        CALL POPREAL8(auxd)
        temp = sig_array(kindex)*result1*phi
        phib = auxb/(sig_array(kindex)*result1*phi) - phid*sig_array(&
&         kindex)*result1*auxdb/temp**2
        phidb = auxdb/temp
        CALL POPREAL8(result1)
      END IF
      tempb = ahet*phidb
      dtnucb = jd*tempb + ahet*j*phib
      jb = dtnucd*tempb + ahet*dtnuc*phib
      ahetb = ahetb + (dtnucd*j+dtnuc*jd)*phidb + dtnuc*j*phib
      dtnucdb = j*tempb
      jdb = dtnuc*tempb
      CALL POPREAL8(j)
      CALL POPREAL8(jd)
      CALL POPREAL8(dtnuc)
      CALL POPREAL8(dtnucd)
      CALL POPREAL8(fder)
      CALL POPREAL8(fderd)
      CALL JHET_D_B(j, jb, jd, jdb, dtnuc, dtnucb, dtnucd, dtnucdb, fder&
&             , fderb, fderd, fderdb, si_, si_b, si_d, t, tb, the_array(&
&             kindex), mode, a, ab)
    END DO
  END SUBROUTINE NUC_FRAC_D_B
!  Differentiation of nuc_frac in forward (tangent) mode:
!   variations   of useful results: dfrac frac
!   with respect to varying inputs: si_
!*************************************************************
! Subroutine nucfrac
! Calculates the ice nucleation fraction according to Barahona et al . 2012 (in prep) 
!************************************************************  
  SUBROUTINE NUC_FRAC_D(frac, fracd, dfrac, dfracd, sig_array, the_array&
&   , frac_array, t, si_, si_d, mode, ahet, a, nlogmodes)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: si_, ahet, a, t
    REAL*8, INTENT(IN) :: si_d
    REAL*8, DIMENSION(:) :: the_array, frac_array, sig_array
    INTEGER, INTENT(IN) :: nlogmodes, mode
    REAL*8, INTENT(OUT) :: frac, dfrac
    REAL*8, INTENT(OUT) :: fracd, dfracd
    REAL*8 :: phi, j, dtnuc, fder, aux
    REAL*8 :: phid, jd, dtnucd, fderd, auxd
    INTEGER :: kindex
    INTRINSIC LOG
    INTRINSIC SQRT
    INTRINSIC EXP
    REAL*8 :: result1
    REAL*8 :: result1d
    REAL*8 :: arg1
    REAL*8 :: arg1d
    frac = 0.0
    dfrac = 0.0
    dfracd = 0.0_8
    fracd = 0.0_8
    DO kindex=1,nlogmodes
      CALL JHET_D(j, jd, dtnuc, dtnucd, fder, fderd, si_, si_d, t, &
&           the_array(kindex), mode, a)
      phid = ahet*(dtnucd*j+dtnuc*jd)
      phi = dtnuc*j*ahet
      IF (phi .GT. 0.0) THEN
        result1 = SQRT(pi_ice)
        auxd = phid/phi/sig_array(kindex)/result1
        aux = LOG(phi)/sig_array(kindex)/result1
        result1d = ERFAPP_D(aux, auxd, result1)
        fracd = fracd - 0.5*frac_array(kindex)*result1d
        frac = 0.5*(1.0-result1)*frac_array(kindex) + frac
        arg1d = -(2*aux*auxd)
        arg1 = -(aux**2)
        dfracd = frac_array(kindex)*(arg1d*EXP(arg1)*fder+EXP(arg1)*&
&         fderd)/sig_array(kindex)/pi_ice + dfracd
        dfrac = frac_array(kindex)*EXP(arg1)*fder/sig_array(kindex)/&
&         pi_ice + dfrac
      ELSE
        frac = 1.0
        dfrac = 0.0
        dfracd = 0.0_8
        fracd = 0.0_8
      END IF
    END DO
    fracd = -fracd
    frac = 1.0 - frac
  END SUBROUTINE NUC_FRAC_D
!  Differentiation of erfapp_d in reverse (adjoint) mode:
!   gradient     of useful results: xd x erfapp erfapp_d
!   with respect to varying inputs: xd x
!  Differentiation of erfapp in forward (tangent) mode:
!   variations   of useful results: erfapp
!   with respect to varying inputs: x
!*************************************************************     
!Approximation to the error function
!*************************************************************
  SUBROUTINE ERFAPP_D_B(x, xb, xd, xdb, erfapp, erfappb, erfapp_db)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: x
    REAL*8 :: xb
    REAL*8, INTENT(IN) :: xd
    REAL*8 :: xdb
    REAL*8 :: a
    REAL*8 :: ab
    REAL*8 :: ad
    REAL*8 :: adb
    INTRINSIC EXP
    INTRINSIC SQRT
    REAL*8 :: arg1
    REAL*8 :: arg1b
    REAL*8 :: arg1d
    REAL*8 :: arg1db
    REAL*8 :: erfapp
    REAL*8 :: erfappb
    INTEGER :: branch
    REAL*8 :: erfapp_d
    REAL*8 :: erfapp_db
    REAL*8 :: temp3
    REAL*8 :: temp2
    REAL*8 :: temp1
    REAL*8 :: temp0
    REAL*8 :: tempb6
    REAL*8 :: tempb5
    REAL*8 :: tempb4
    REAL*8 :: tempb3
    REAL*8 :: tempb2
    REAL*8 :: tempb1
    REAL*8 :: tempb0
    REAL*8 :: temp10
    REAL*8 :: tempb
    REAL*8 :: temp
    REAL*8 :: temp9
    REAL*8 :: temp8
    REAL*8 :: temp7
    REAL*8 :: temp6
    REAL*8 :: temp5
    REAL*8 :: temp4
    ad = (((xd*x+x*xd)*(1.27324d0+0.147d0*x*x)+x**2*0.147d0*(xd*x+x*xd))&
&     *(1d0+0.147d0*x*x)-x**2*(1.27324d0+0.147d0*x*x)*0.147d0*(xd*x+x*xd&
&     ))/(1d0+0.147d0*x*x)**2
    a = x*x*(1.27324d0+0.147d0*x*x)/(1d0+0.147d0*x*x)
    arg1d = ad*EXP(-a)
    arg1 = 1d0 - EXP(-a)
    IF (arg1 .EQ. 0.0) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (x .LT. 0.0) THEN
      erfappb = -erfappb
      erfapp_db = -erfapp_db
    END IF
    IF (arg1 .EQ. 0.0) THEN
      arg1b = 0.0
    ELSE
      arg1b = erfappb/(2.0*SQRT(arg1))
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      arg1db = 0.0_8
    ELSE
      temp10 = SQRT(arg1)
      tempb6 = erfapp_db/(2.0*temp10)
      arg1db = tempb6
      IF (.NOT.arg1 .EQ. 0.0) arg1b = arg1b - arg1d*tempb6/(2.0*temp10**&
&         2)
    END IF
    ab = EXP(-a)*arg1b - EXP(-a)*ad*arg1db
    adb = EXP(-a)*arg1db
    temp9 = 0.147d0*x**2 + 1d0
    tempb = ab/temp9
    temp8 = 0.147d0*x**2 + 1.27324d0
    temp7 = 0.147d0*x**2 + 1d0
    tempb3 = adb/temp7**2
    temp6 = 0.147d0*x**2 + 1d0
    tempb1 = temp6*tempb3
    temp5 = 0.147d0*x**2 + 1.27324d0
    tempb0 = temp5*tempb1
    temp0 = xd*x + x*xd
    temp1 = xd*x + x*xd
    tempb2 = 0.147d0*x**2*tempb1
    temp = temp0*temp5 + 0.147d0*x**2*temp1
    temp3 = xd*x + x*xd
    temp4 = 0.147d0*x**2 + 1.27324d0
    temp2 = x**2*temp4
    tempb4 = -(0.147d0*temp3*tempb3)
    tempb5 = -(0.147d0*temp2*tempb3)
    xb = xb + 2*xd*tempb0 + (temp1*0.147d0*2*x+0.147d0*temp0*2*x)*tempb1&
&     + 2*xd*tempb2 + (0.147d0*temp*2*x-0.147d0*2**2*(temp*temp6-0.147d0&
&     *(temp2*temp3))*x/temp7)*tempb3 + (2*(0.147d0*x**3)+temp4*2*x)*&
&     tempb4 + 2*xd*tempb5 + (2*(0.147d0*x**3)-0.147d0*x**3*temp8*2/&
&     temp9+temp8*2*x)*tempb
    xdb = xdb + 2*x*tempb5 + 2*x*tempb2 + 2*x*tempb0
  END SUBROUTINE ERFAPP_D_B
!  Differentiation of erfapp in forward (tangent) mode:
!   variations   of useful results: erfapp
!   with respect to varying inputs: x
!*************************************************************     
!Approximation to the error function
!*************************************************************
  REAL*8 FUNCTION ERFAPP_D(x, xd, erfapp)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: x
    REAL*8, INTENT(IN) :: xd
    REAL*8 :: a
    REAL*8 :: ad
    INTRINSIC EXP
    INTRINSIC SQRT
    REAL*8 :: arg1
    REAL*8 :: arg1d
    REAL*8 :: erfapp
    ad = (((xd*x+x*xd)*(1.27324d0+0.147d0*x*x)+x**2*0.147d0*(xd*x+x*xd))&
&     *(1d0+0.147d0*x*x)-x**2*(1.27324d0+0.147d0*x*x)*0.147d0*(xd*x+x*xd&
&     ))/(1d0+0.147d0*x*x)**2
    a = x*x*(1.27324d0+0.147d0*x*x)/(1d0+0.147d0*x*x)
    arg1d = ad*EXP(-a)
    arg1 = 1d0 - EXP(-a)
    IF (arg1 .EQ. 0.0) THEN
      erfapp_d = 0.0_8
    ELSE
      erfapp_d = arg1d/(2.0*SQRT(arg1))
    END IF
    erfapp = SQRT(arg1)
    IF (x .LT. 0.0) THEN
!bug removed 08/03/2011
      erfapp_d = -erfapp_d
      erfapp = -erfapp
    END IF
  END FUNCTION ERFAPP_D
!  Differentiation of jhet_d in reverse (adjoint) mode:
!   gradient     of useful results: dtnuc_dhf waux_ice dtnuc_dep
!                aimm dact_imm lmeff_ice vw_ice denice_ice vpresw_ice
!                vpresi_ice j fder fderd t_ice dtnucd si jd dtnuc
!                a
!   with respect to varying inputs: dtnuc_dhf waux_ice dtnuc_dep
!                aimm dact_imm lmeff_ice vw_ice denice_ice vpresw_ice
!                vpresi_ice t_ice si a
!  Differentiation of jhet in forward (tangent) mode:
!   variations   of useful results: j fder dtnuc
!   with respect to varying inputs: si
!*************************************************************
! Subroutine JHET
! Calculates the ice nucleation rate coefficient and the nucleation time scale according 
!Si is the saturation ratio w.r.t. ice
! mode=1-deposition, 2-immersion of water droplets, 3- immersion of solution drops (DHF)
! to Barahona 2011 ACPD, Barahona et al . 2012 (in prep) 
!************************************************************  
  SUBROUTINE JHET_D_B(j, jb, jd, jdb, dtnuc, dtnucb, dtnucd, dtnucdb, &
&   fder, fderb, fderd, fderdb, si, sib, sid, t_ice, t_iceb, theta, mode&
&   , a, ab)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: t_ice, theta, si, a
    REAL*8 :: t_iceb, sib, ab
    REAL*8, INTENT(IN) :: sid
    REAL*8 :: j, dtnuc, fder
    REAL*8 :: jb, dtnucb, fderb
    REAL*8 :: jd, dtnucd, fderd
    REAL*8 :: jdb, dtnucdb, fderdb
    REAL*8 :: dg, rgerm, dgo, fhet, m, sw, gct, aprime, ng, g, dgh
    REAL*8 :: dgb, rgermb, dgob, swb, gctb, aprimeb, ngb, gb, dghb
    REAL*8 :: dgd, rgermd, dgod, swd, aprimed, ngd, dghd
    REAL*8 :: dgdb, rgermdb, dgodb, swdb, aprimedb, ngdb, dghdb
    INTEGER :: mode
    INTRINSIC COS
    INTRINSIC LOG
    INTRINSIC SQRT
    INTRINSIC EXP
    REAL*8 :: result1
    REAL*8 :: result1b
    REAL*8 :: result1d
    REAL*8 :: result1db
    REAL*8 :: arg1
    REAL*8 :: arg1b
    REAL*8 :: arg1d
    REAL*8 :: arg1db
    REAL*8 :: pwr1
    REAL*8 :: pwr1b
    REAL*8 :: pwr1d
    REAL*8 :: pwr1db
    INTRINSIC INT
    INTEGER :: branch
    REAL*8 :: temp3
    REAL*8 :: temp29
    REAL*8 :: tempb52
    REAL*8 :: temp2
    REAL*8 :: temp28
    REAL*8 :: tempb51
    REAL*8 :: temp1
    REAL*8 :: temp27
    REAL*8 :: tempb50
    REAL*8 :: temp0
    REAL*8 :: temp26
    REAL*8 :: temp25
    REAL*8 :: temp24
    REAL*8 :: temp23
    REAL*8 :: temp22
    REAL*8 :: temp21
    REAL*8 :: temp20
    REAL*8 :: tempb9
    REAL*8 :: tempb8
    REAL*8 :: tempb7
    REAL*8 :: tempb6
    REAL*8 :: tempb5
    REAL*8 :: tempb4
    REAL*8 :: tempb19
    REAL*8 :: tempb3
    REAL*8 :: tempb18
    REAL*8 :: tempb2
    REAL*8 :: tempb17
    REAL*8 :: tempb1
    REAL*8 :: tempb16
    REAL*8 :: tempb0
    REAL*8 :: tempb15
    REAL*8 :: tempb14
    REAL*8 :: tempb13
    REAL*8 :: tempb12
    REAL*8 :: tempb49
    REAL*8 :: tempb11
    REAL*8 :: tempb48
    REAL*8 :: tempb10
    REAL*8 :: tempb47
    REAL*8 :: tempb46
    REAL*8 :: tempb45
    REAL*8 :: tempb44
    REAL*8 :: tempb43
    REAL*8 :: temp19
    REAL*8 :: tempb42
    REAL*8 :: temp18
    REAL*8 :: tempb41
    REAL*8 :: temp17
    REAL*8 :: tempb40
    REAL*8 :: tempb77
    REAL*8 :: temp16
    REAL*8 :: tempb76
    REAL*8 :: temp15
    REAL*8 :: tempb75
    REAL*8 :: temp14
    REAL*8 :: tempb74
    REAL*8 :: temp13
    REAL*8 :: tempb73
    REAL*8 :: temp12
    REAL*8 :: tempb72
    REAL*8 :: temp11
    REAL*8 :: tempb71
    REAL*8 :: temp10
    REAL*8 :: temp47
    REAL*8 :: tempb70
    REAL*8 :: temp46
    REAL*8 :: temp45
    REAL*8 :: temp44
    REAL*8 :: temp43
    REAL*8 :: temp42
    REAL*8 :: temp41
    REAL*8 :: temp40
    REAL*8 :: tempb
    REAL*8 :: tempb39
    REAL*8 :: tempb38
    REAL*8 :: tempb37
    REAL*8 :: tempb36
    REAL*8 :: tempb35
    REAL*8 :: tempb34
    REAL*8 :: tempb33
    REAL*8 :: tempb32
    REAL*8 :: tempb69
    REAL*8 :: tempb31
    REAL*8 :: tempb68
    REAL*8 :: tempb30
    REAL*8 :: tempb67
    REAL*8 :: tempb66
    REAL*8 :: tempb65
    REAL*8 :: tempb64
    REAL*8 :: tempb63
    REAL*8 :: temp39
    REAL*8 :: tempb62
    REAL*8 :: temp38
    REAL*8 :: tempb61
    REAL*8 :: tempb60
    REAL*8 :: temp37
    REAL*8 :: temp36
    REAL*8 :: temp35
    REAL*8 :: temp34
    REAL*8 :: temp33
    REAL*8 :: temp32
    REAL*8 :: temp31
    REAL*8 :: temp30
    REAL*8 :: tempb29
    REAL*8 :: tempb28
    REAL*8 :: tempb27
    REAL*8 :: tempb26
    REAL*8 :: tempb25
    REAL*8 :: temp
    REAL*8 :: tempb24
    REAL*8 :: tempb23
    REAL*8 :: tempb22
    REAL*8 :: tempb59
    REAL*8 :: temp9
    REAL*8 :: tempb21
    REAL*8 :: tempb58
    REAL*8 :: temp8
    REAL*8 :: tempb20
    REAL*8 :: tempb57
    REAL*8 :: temp7
    REAL*8 :: tempb56
    REAL*8 :: temp6
    REAL*8 :: tempb55
    REAL*8 :: temp5
    REAL*8 :: tempb54
    REAL*8 :: temp4
    REAL*8 :: tempb53
    m = COS(theta*pi_ice/180.0)
    fhet = (m*m*m-3.0*m+2.0)/4.0
    swd = vpresi_ice*sid/vpresw_ice
    sw = si*vpresi_ice/vpresw_ice
!assume dry lapse rate to calculate dtnuc in immersion. Not very sensitive to this
!K/m
    gct = 9.76e-2
!K/s
    CALL PUSHREAL8(gct)
    gct = gct*waux_ice
!value at saturation 
    sigiw_iced = -((-25.67+0.211*t_ice)*1.0e-3*1.8176*swd)
    sigiw_ice = (-25.67+0.211*t_ice)*(-(1.8176*sw)+2.7789)*1.0e-3
!new2
    rsc_iced = 2.0*sigiw_iced/denice_ice/lmeff_ice
    rsc_ice = 2.0*sigiw_ice/denice_ice/lmeff_ice
    IF (mode .EQ. 1) THEN
!deposition
      rgermd = -(2.0*vw_ice*sigiv_ice*sid/(kb_ice*t_ice*si)/LOG(si)**2)
      rgerm = 2.0*vw_ice*sigiv_ice/kb_ice/t_ice/LOG(si)
      dgod = 4.0*pi_ice*sigiv_ice*(rgermd*rgerm+rgerm*rgermd)/3.0
      dgo = 4.0*pi_ice*sigiv_ice*(rgerm*rgerm)/3.0
      dgd = fhet*dgod
      dg = dgo*fhet
      result1 = SQRT(fhet)
      aprimed = a*(sid*si+si*sid)/result1
      aprime = a*si*si/result1
      dgh = 0.0
      dghd = 0.0_8
      CALL PUSHCONTROL2B(0)
    ELSE IF (mode .EQ. 2) THEN
!immersion of water droplets
      rgermd = 2.0*vw_ice*sigiw_iced/kb_ice/t_ice/LOG(vpresw_ice/&
&       vpresi_ice)
      rgerm = 2.0*vw_ice*sigiw_ice/kb_ice/t_ice/LOG(vpresw_ice/&
&       vpresi_ice)
      dgod = 4.0*pi_ice*((sigiw_iced*rgerm+sigiw_ice*rgermd)*rgerm+&
&       sigiw_ice*rgerm*rgermd)/3.0
      dgo = 4.0*pi_ice*sigiw_ice*(rgerm*rgerm)/3.0
      dgd = fhet*dgod
      dg = dgo*fhet
      ngd = 4.0*pi_ice*((rgermd*rgerm+rgerm*rgermd)*rgerm+rgerm**2*&
&       rgermd)/3.0/vw_ice
      ng = 4.0*pi_ice*rgerm*rgerm*rgerm/3.0/vw_ice
      arg1d = dgod/fhet
      arg1 = dgo/fhet
      IF (arg1 .EQ. 0.0) THEN
        result1d = 0.0_8
        CALL PUSHCONTROL1B(0)
      ELSE
        result1d = arg1d/(2.0*SQRT(arg1))
        CALL PUSHCONTROL1B(1)
      END IF
      result1 = SQRT(arg1)
      aprimed = (aimm*result1d*ng-aimm*result1*ngd)/ng**2
      aprime = aimm*result1/ng
!
      dgh = (m+1.0)*dgh_ice*1.60217646e-19
      dghd = 0.0_8
      CALL PUSHCONTROL2B(1)
    ELSE
!DHF (Khvorostyanov and Curry, 2004)
      g = rv_ice*t_ice/lmeff_ice
      IF (sw .GT. 0.0 .OR. (sw .LT. 0.0 .AND. g .EQ. INT(g))) THEN
        pwr1d = g*sw**(g-1)*swd
        CALL PUSHCONTROL2B(0)
      ELSE IF (sw .EQ. 0.0 .AND. g .EQ. 1.0) THEN
        pwr1d = swd
        CALL PUSHCONTROL2B(1)
      ELSE
        pwr1d = 0.0
        CALL PUSHCONTROL2B(2)
      END IF
      pwr1 = sw**g
      arg1d = to_ice*pwr1d/t_ice
      arg1 = pwr1*to_ice/t_ice
      rgermd = (2.0*sigiw_iced*denice_ice*lmeff_ice*LOG(arg1)-2.0*&
&       sigiw_ice*denice_ice*lmeff_ice*arg1d/arg1)/(denice_ice*lmeff_ice&
&       *LOG(arg1))**2
      rgerm = 2.0*sigiw_ice/(denice_ice*lmeff_ice*LOG(arg1))
      dgod = 4.0*pi_ice*((sigiw_iced*rgerm+sigiw_ice*rgermd)*rgerm+&
&       sigiw_ice*rgerm*rgermd)/3.0
      dgo = 4.0*pi_ice*sigiw_ice*(rgerm*rgerm)/3.0
      dgd = fhet*dgod
      dg = dgo*fhet
      ngd = 4.0*pi_ice*((rgermd*rgerm+rgerm*rgermd)*rgerm+rgerm**2*&
&       rgermd)/3.0/vw_ice
      ng = 4.0*pi_ice*rgerm*rgerm*rgerm/3.0/vw_ice
      arg1d = dgod/fhet
      arg1 = dgo/fhet
      IF (arg1 .EQ. 0.0) THEN
        result1d = 0.0_8
        CALL PUSHCONTROL1B(0)
      ELSE
        result1d = arg1d/(2.0*SQRT(arg1))
        CALL PUSHCONTROL1B(1)
      END IF
      result1 = SQRT(arg1)
      aprimed = (aimm*result1d*ng-aimm*result1*ngd)/ng**2
      aprime = aimm*result1/ng
!new2
      dghd = dgh_ice*dgd
      dgh = dg*dgh_ice
      CALL PUSHCONTROL2B(2)
    END IF
    IF (rgerm .LE. 0.0) THEN
      aprime = 0.0
      aprimed = 0.0_8
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    arg1d = -((dgd+dghd)/kb_ice/t_ice)
    arg1 = -((dg+dgh)/kb_ice/t_ice)
    tempb75 = EXP(arg1)*jdb
    aprimeb = arg1d*tempb75 + EXP(arg1)*jb
    arg1b = (aprime*arg1d*EXP(arg1)+aprimed*EXP(arg1))*jdb + aprime*EXP(&
&     arg1)*jb
    aprimedb = EXP(arg1)*jdb
    arg1db = aprime*tempb75
    tempb76 = -(arg1b/(kb_ice*t_ice))
    dgb = tempb76
    dghb = tempb76
    tempb77 = -(arg1db/(kb_ice*t_ice))
    t_iceb = t_iceb - (dgd+dghd)*tempb77/t_ice - (dg+dgh)*tempb76/t_ice
    dgdb = tempb77
    dghdb = tempb77
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      aprimeb = 0.0_8
      aprimedb = 0.0_8
    END IF
    CALL POPCONTROL2B(branch)
    IF (branch .EQ. 0) THEN
      temp6 = si**2*kb_ice*t_ice
      tempb17 = fderdb/temp6
      temp10 = LOG(si)
      temp9 = temp10**2
      temp5 = si/temp9
      tempb6 = temp5*tempb17
      tempb7 = -(sid*2.0*tempb6/si)
      temp7 = LOG(si)
      tempb9 = -(sid*2.0*tempb17/temp7)
      temp13 = kb_ice*si*t_ice
      temp12 = LOG(si)
      temp11 = temp12*temp13
      tempb16 = 2.0*fderb/temp11
      tempb14 = -(dg*tempb16/temp11)
      dgb = dgb + tempb7 + tempb9 + tempb16
      temp8 = LOG(si)
      temp4 = 2.0*dgd*temp8 - 2.0*sid*dg/si
      tempb8 = temp4*tempb17/temp9
      tempb10 = -((temp4*temp5-sid*2.0*(dg/temp7))*tempb17/temp6)
      dgdb = dgdb + 2.0*temp8*tempb6
      dgob = fhet*dgb
      dgodb = fhet*dgdb
      tempb18 = pi_ice*4.0*sigiv_ice*dgodb/3.0
      rgermb = 2*rgermd*tempb18 + pi_ice*4.0*sigiv_ice*2*rgerm*dgob/3.0
      rgermdb = 2*rgerm*tempb18
      temp3 = LOG(si)
      temp2 = kb_ice*t_ice*temp3
      tempb19 = sigiv_ice*2.0*rgermb/temp2
      tempb13 = -(vw_ice*tempb19/temp2)
      temp1 = LOG(si)
      temp0 = kb_ice*t_ice*si
      temp = temp0*temp1**2
      tempb20 = -(sigiv_ice*2.0*sid*rgermdb/temp)
      tempb12 = -(vw_ice*tempb20/temp)
      tempb11 = temp1**2*tempb12
      sib = sib + 2*a*sid*aprimedb/result1 + dgd*2.0*tempb6/si - dg*&
&       tempb7/si + (1.0_8-2*temp10*temp5/si)*tempb8 - dg*tempb9/(temp7*&
&       si) + kb_ice*t_ice*2*si*tempb10 + kb_ice*t_ice*tempb11 + 2*temp1&
&       *temp0*tempb12/si + kb_ice*t_ice*tempb13/si + (t_ice*temp12*&
&       kb_ice+temp13/si)*tempb14 + a*2*si*aprimeb/result1
      ab = ab + 2*sid*si*aprimedb/result1 + si**2*aprimeb/result1
      tempb15 = dtnucb/(fhet*waux_ice)
      dtnuc_depb = dtnuc_depb + tempb15
      waux_iceb = waux_iceb - dtnuc_dep*tempb15/waux_ice
      t_iceb = t_iceb + si**2*kb_ice*tempb10 + si*kb_ice*tempb11 + temp3&
&       *kb_ice*tempb13 + temp12*kb_ice*si*tempb14
      vw_iceb = vw_iceb + tempb20 + tempb19
      sigiw_iceb = 0.0_8
      rsc_icedb = 0.0_8
      sigiw_icedb = 0.0_8
      rsc_iceb = 0.0_8
      swdb = 0.0_8
      gctb = 0.0_8
      swb = 0.0_8
    ELSE IF (branch .EQ. 1) THEN
      tempb40 = aprimedb/ng**2
      tempb39 = aprimeb/ng
      aimmb = aimmb + (ng*result1d-ngd*result1)*tempb40 + result1*&
&       tempb39
      result1b = aimm*tempb39 - ngd*aimm*tempb40
      ngb = (aimm*result1d-(aimm*result1d*ng-aimm*result1*ngd)*2/ng)*&
&       tempb40 - aimm*result1*tempb39/ng
      result1db = ng*aimm*tempb40
      ngdb = -(aimm*result1*tempb40)
      arg1 = dgo/fhet
      IF (arg1 .EQ. 0.0) THEN
        arg1b = 0.0
      ELSE
        arg1b = result1b/(2.0*SQRT(arg1))
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        arg1db = 0.0_8
      ELSE
        arg1d = dgod/fhet
        temp22 = SQRT(arg1)
        tempb38 = result1db/(2.0*temp22)
        arg1db = tempb38
        IF (.NOT.arg1 .EQ. 0.0) arg1b = arg1b - arg1d*tempb38/(2.0*&
&           temp22**2)
      END IF
      temp21 = (dact_imm+dg)**2
      tempb23 = -(kb_ice*dtnucdb/(gct*temp21))
      tempb26 = -(t_ice**2*dgd*tempb23/(gct*temp21))
      tempb27 = gct*2*(dact_imm+dg)*tempb26
      dgdb = dgdb + t_ice**2*tempb23
      tempb21 = kb_ice*dtnucb/(gct*(dact_imm+dg))
      tempb22 = -(t_ice**2*tempb21/(gct*(dact_imm+dg)))
      dgb = dgb + tempb27 + gct*tempb22
      dgob = fhet*dgb + arg1b/fhet
      dgodb = fhet*dgdb + arg1db/fhet
      gctb = temp21*tempb26 + (dact_imm+dg)*tempb22
      dact_immb = dact_immb + tempb27 + gct*tempb22
      tempb28 = pi_ice*4.0*ngb/(3.0*vw_ice)
      temp20 = rgermd*rgerm + rgerm*rgermd
      tempb30 = pi_ice*4.0*ngdb/(3.0*vw_ice)
      tempb29 = rgerm*tempb30
      tempb33 = pi_ice*4.0*dgob
      tempb32 = pi_ice*4.0*dgodb/3.0
      tempb31 = rgerm*tempb32
      rgermb = 2*rgermd*tempb29 + (rgermd*2*rgerm+temp20)*tempb30 + &
&       sigiw_iced*tempb31 + (rgermd*sigiw_ice+sigiw_iced*rgerm+&
&       sigiw_ice*rgermd)*tempb32 + sigiw_ice*2*rgerm*tempb33/3.0 + 3*&
&       rgerm**2*tempb28
      rgermdb = sigiw_ice*tempb31 + sigiw_ice*rgerm*tempb32 + rgerm**2*&
&       tempb30 + 2*rgerm*tempb29
      temp18 = vpresw_ice/vpresi_ice
      temp19 = LOG(temp18)
      temp17 = kb_ice*t_ice*temp19
      tempb35 = 2.0*rgermb/temp17
      sigiw_iceb = rgermd*tempb31 + rgermd*rgerm*tempb32 + vw_ice*&
&       tempb35 + rgerm**2*tempb33/3.0
      tempb25 = -(vw_ice*sigiw_ice*tempb35/temp17)
      tempb36 = kb_ice*t_ice*tempb25/(temp18*vpresi_ice)
      temp15 = vpresw_ice/vpresi_ice
      temp16 = LOG(temp15)
      temp14 = kb_ice*t_ice*temp16
      tempb34 = 2.0*rgermdb/temp14
      vw_iceb = vw_iceb + sigiw_iced*tempb34 - (temp20*rgerm+rgerm**2*&
&       rgermd)*tempb30/vw_ice + sigiw_ice*tempb35 - rgerm**3*tempb28/&
&       vw_ice
      sigiw_icedb = vw_ice*tempb34 + rgerm*tempb31
      tempb24 = -(vw_ice*sigiw_iced*tempb34/temp14)
      t_iceb = t_iceb + dgd*2*t_ice*tempb23 + temp16*kb_ice*tempb24 + &
&       temp19*kb_ice*tempb25 + 2*t_ice*tempb21
      tempb37 = kb_ice*t_ice*tempb24/(temp15*vpresi_ice)
      vpresw_iceb = vpresw_iceb + tempb37 + tempb36
      vpresi_iceb = vpresi_iceb - temp15*tempb37 - temp18*tempb36
      rsc_icedb = 0.0_8
      rsc_iceb = 0.0_8
      swdb = 0.0_8
      swb = 0.0_8
    ELSE
      tempb74 = aprimedb/ng**2
      tempb71 = fderdb/rsc_ice**2
      temp46 = si**2
      temp38 = rsc_ice/temp46
      tempb72 = temp38*tempb71
      temp45 = kb_ice*t_ice
      temp36 = g*si/temp45
      temp35 = rgermd*dg + rgerm*dgd
      tempb64 = 2.0*temp36*tempb72
      tempb68 = temp35*2.0*tempb72/temp45
      temp44 = kb_ice*t_ice
      temp43 = rgerm*g*dg
      temp37 = temp43/temp44
      tempb63 = -(sid*2.0*tempb72/temp44)
      temp34 = 2.0*temp35*temp36 - 2.0*sid*temp37
      tempb70 = temp34*tempb71/temp46
      temp41 = kb_ice*t_ice*si
      temp40 = dg*rsc_iced
      temp42 = rgerm*g*temp40
      temp39 = temp42/temp41
      tempb67 = -(2.0*tempb71/temp41)
      tempb62 = rgerm*g*tempb67
      tempb69 = -(temp39*tempb67)
      temp47 = kb_ice*t_ice*si*rsc_ice
      tempb61 = 2.0*fderb/temp47
      dgb = dgb + rgerm*g*tempb61 + rsc_iced*tempb62 + rgerm*g*tempb63 +&
&       rgermd*tempb64 + dgh_ice*dghb
      dgdb = dgdb + rgerm*tempb64 + dgh_ice*dghdb
      tempb65 = -(rgerm*g*dg*tempb61/temp47)
      tempb66 = kb_ice*t_ice*tempb65
      rgermb = dgd*tempb64 + dg*g*tempb63 + temp40*g*tempb67 + dg*g*&
&       tempb61
      gb = si*tempb68 + dg*rgerm*tempb63 + temp40*rgerm*tempb67 + dg*&
&       rgerm*tempb61
      t_iceb = t_iceb + si*kb_ice*tempb69 - temp37*kb_ice*tempb63 - &
&       temp36*kb_ice*tempb68 + si*rsc_ice*kb_ice*tempb65
      sib = sib + g*tempb68 - temp38*2*si*tempb70 + kb_ice*t_ice*tempb69&
&       + rsc_ice*tempb66
      rsc_iceb = tempb70 - (temp34*temp38-2.0*temp39)*2*tempb71/rsc_ice &
&       + si*tempb66
      rgermdb = dg*tempb64
      rsc_icedb = dg*tempb62
      tempb73 = aprimeb/ng
      aimmb = aimmb + (ng*result1d-ngd*result1)*tempb74 + result1*&
&       tempb73
      result1b = aimm*tempb73 - ngd*aimm*tempb74
      ngb = (aimm*result1d-(aimm*result1d*ng-aimm*result1*ngd)*2/ng)*&
&       tempb74 - aimm*result1*tempb73/ng
      result1db = ng*aimm*tempb74
      ngdb = -(aimm*result1*tempb74)
      arg1 = dgo/fhet
      IF (arg1 .EQ. 0.0) THEN
        arg1b = 0.0
      ELSE
        arg1b = result1b/(2.0*SQRT(arg1))
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        arg1db = 0.0_8
      ELSE
        arg1d = dgod/fhet
        temp33 = SQRT(arg1)
        tempb60 = result1db/(2.0*temp33)
        arg1db = tempb60
        IF (.NOT.arg1 .EQ. 0.0) arg1b = arg1b - arg1d*tempb60/(2.0*&
&           temp33**2)
      END IF
      tempb46 = pi_ice*4.0*ngdb/(3.0*vw_ice)
      temp32 = rgermd*rgerm + rgerm*rgermd
      dgob = fhet*dgb + arg1b/fhet
      dgodb = fhet*dgdb + arg1db/fhet
      tempb43 = dtnucb/(fhet*waux_ice)
      dtnuc_dhfb = dtnuc_dhfb + tempb43
      waux_iceb = waux_iceb - dtnuc_dhf*tempb43/waux_ice
      tempb44 = pi_ice*4.0*ngb/(3.0*vw_ice)
      vw_iceb = vw_iceb - (temp32*rgerm+rgerm**2*rgermd)*tempb46/vw_ice &
&       - rgerm**3*tempb44/vw_ice
      tempb45 = rgerm*tempb46
      tempb49 = pi_ice*4.0*dgob
      tempb48 = pi_ice*4.0*dgodb/3.0
      tempb47 = rgerm*tempb48
      rgermb = rgermb + 2*rgermd*tempb45 + (rgermd*2*rgerm+temp32)*&
&       tempb46 + sigiw_iced*tempb47 + (rgermd*sigiw_ice+sigiw_iced*&
&       rgerm+sigiw_ice*rgermd)*tempb48 + sigiw_ice*2*rgerm*tempb49/3.0 &
&       + 3*rgerm**2*tempb44
      rgermdb = rgermdb + sigiw_ice*tempb47 + sigiw_ice*rgerm*tempb48 + &
&       rgerm**2*tempb46 + 2*rgerm*tempb45
      arg1 = pwr1*to_ice/t_ice
      temp31 = LOG(arg1)
      temp30 = denice_ice*lmeff_ice*temp31
      tempb51 = 2.0*rgermb/temp30
      tempb53 = -(sigiw_ice*tempb51/temp30)
      arg1d = to_ice*pwr1d/t_ice
      temp29 = LOG(arg1)
      temp27 = denice_ice**2*lmeff_ice**2
      temp26 = temp27*temp29**2
      tempb56 = rgermdb/temp26
      temp28 = LOG(arg1)
      temp24 = sigiw_iced*denice_ice*lmeff_ice
      tempb52 = 2.0*temp28*tempb56
      sigiw_icedb = lmeff_ice*denice_ice*tempb52 + rgerm*tempb47
      temp25 = sigiw_ice*denice_ice/arg1
      tempb50 = -(lmeff_ice*arg1d*2.0*tempb56/arg1)
      sigiw_iceb = rgermd*tempb47 + rgermd*rgerm*tempb48 + denice_ice*&
&       tempb50 + tempb51 + rgerm**2*tempb49/3.0
      tempb55 = -(2.0*temp25*tempb56)
      tempb57 = -((2.0*(temp24*temp28)-2.0*(temp25*(lmeff_ice*arg1d)))*&
&       tempb56/temp26)
      arg1b = temp24*2.0*tempb56/arg1 - temp25*tempb50 + 2*temp29*temp27&
&       *tempb57/arg1 + denice_ice*lmeff_ice*tempb53/arg1
      tempb54 = temp29**2*tempb57
      denice_iceb = denice_iceb + lmeff_ice*sigiw_iced*tempb52 + &
&       sigiw_ice*tempb50 + lmeff_ice**2*2*denice_ice*tempb54 + temp31*&
&       lmeff_ice*tempb53
      lmeff_iceb = lmeff_iceb + sigiw_iced*denice_ice*tempb52 + arg1d*&
&       tempb55 + denice_ice**2*2*lmeff_ice*tempb54 + temp31*denice_ice*&
&       tempb53
      arg1db = lmeff_ice*tempb55
      tempb58 = to_ice*arg1b/t_ice
      pwr1b = tempb58
      tempb59 = to_ice*arg1db/t_ice
      t_iceb = t_iceb - pwr1d*tempb59/t_ice - pwr1*tempb58/t_ice
      pwr1db = tempb59
      IF (sw .LE. 0.0 .AND. (g .EQ. 0.0 .OR. g .NE. INT(g))) THEN
        swb = 0.0
      ELSE
        swb = g*sw**(g-1)*pwr1b
      END IF
      IF (.NOT.sw .LE. 0.0) gb = gb + sw**g*LOG(sw)*pwr1b
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        tempb42 = g*swd*pwr1db
        temp23 = sw**(g-1)
        IF (.NOT.(sw .LE. 0.0 .AND. (g - 1 .EQ. 0.0 .OR. g - 1 .NE. INT(&
&           g - 1)))) swb = swb + (g-1)*sw**(g-2)*tempb42
        IF (sw .LE. 0.0) THEN
          gb = gb + temp23*swd*pwr1db
        ELSE
          gb = gb + temp23*swd*pwr1db + temp23*LOG(sw)*tempb42
        END IF
        swdb = temp23*g*pwr1db
      ELSE IF (branch .EQ. 1) THEN
        swdb = pwr1db
      ELSE
        swdb = 0.0_8
      END IF
      tempb41 = rv_ice*gb/lmeff_ice
      t_iceb = t_iceb + tempb41
      lmeff_iceb = lmeff_iceb - t_ice*tempb41/lmeff_ice
      gctb = 0.0_8
    END IF
    tempb2 = 2.0*rsc_icedb/(denice_ice*lmeff_ice)
    tempb1 = -(sigiw_iced*tempb2/(denice_ice*lmeff_ice))
    tempb = 2.0*rsc_iceb/(denice_ice*lmeff_ice)
    tempb0 = -(sigiw_ice*tempb/(denice_ice*lmeff_ice))
    sigiw_iceb = sigiw_iceb + tempb
    denice_iceb = denice_iceb + lmeff_ice*tempb1 + lmeff_ice*tempb0
    lmeff_iceb = lmeff_iceb + denice_ice*tempb1 + denice_ice*tempb0
    sigiw_icedb = sigiw_icedb + tempb2
    swb = swb - (0.211*t_ice-25.67)*1.0e-3*1.8176*sigiw_iceb
    tempb3 = -(1.8176*1.0e-3*sigiw_icedb)
    t_iceb = t_iceb + swd*0.211*tempb3 + (2.7789-1.8176*sw)*1.0e-3*0.211&
&     *sigiw_iceb
    swdb = swdb + (0.211*t_ice-25.67)*tempb3
    CALL POPREAL8(gct)
    waux_iceb = waux_iceb + gct*gctb
    tempb4 = swb/vpresw_ice
    sib = sib + vpresi_ice*tempb4
    tempb5 = sid*swdb/vpresw_ice
    vpresi_iceb = vpresi_iceb + tempb5 + si*tempb4
    vpresw_iceb = vpresw_iceb - vpresi_ice*tempb5/vpresw_ice - si*&
&     vpresi_ice*tempb4/vpresw_ice
  END SUBROUTINE JHET_D_B
!  Differentiation of jhet in forward (tangent) mode:
!   variations   of useful results: j fder dtnuc
!   with respect to varying inputs: si
!*************************************************************
! Subroutine JHET
! Calculates the ice nucleation rate coefficient and the nucleation time scale according 
!Si is the saturation ratio w.r.t. ice
! mode=1-deposition, 2-immersion of water droplets, 3- immersion of solution drops (DHF)
! to Barahona 2011 ACPD, Barahona et al . 2012 (in prep) 
!************************************************************  
  SUBROUTINE JHET_D(j, jd, dtnuc, dtnucd, fder, fderd, si, sid, t_ice, &
&   theta, mode, a)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: t_ice, theta, si, a
    REAL*8, INTENT(IN) :: sid
    REAL*8, INTENT(OUT) :: j, dtnuc, fder
    REAL*8, INTENT(OUT) :: jd, dtnucd, fderd
    REAL*8 :: dg, rgerm, dgo, fhet, m, sw, gct, aprime, ng, g, dgh
    REAL*8 :: dgd, rgermd, dgod, swd, aprimed, ngd, dghd
    INTEGER :: mode
    INTRINSIC COS
    INTRINSIC LOG
    INTRINSIC SQRT
    INTRINSIC EXP
    REAL*8 :: result1
    REAL*8 :: result1d
    REAL*8 :: arg1
    REAL*8 :: arg1d
    REAL*8 :: pwr1
    REAL*8 :: pwr1d
    INTRINSIC INT
    m = COS(theta*pi_ice/180.0)
    fhet = (m*m*m-3.0*m+2.0)/4.0
    swd = vpresi_ice*sid/vpresw_ice
    sw = si*vpresi_ice/vpresw_ice
!assume dry lapse rate to calculate dtnuc in immersion. Not very sensitive to this
!K/m
    gct = 9.76e-2
!K/s
    gct = gct*waux_ice
!value at saturation 
    sigiw_iced = -((-25.67+0.211*t_ice)*1.0e-3*1.8176*swd)
    sigiw_ice = (-25.67+0.211*t_ice)*(-(1.8176*sw)+2.7789)*1.0e-3
!new2
    rsc_iced = 2.0*sigiw_iced/denice_ice/lmeff_ice
    rsc_ice = 2.0*sigiw_ice/denice_ice/lmeff_ice
    IF (mode .EQ. 1) THEN
!deposition
      rgermd = -(2.0*vw_ice*sigiv_ice*sid/(kb_ice*t_ice*si)/LOG(si)**2)
      rgerm = 2.0*vw_ice*sigiv_ice/kb_ice/t_ice/LOG(si)
      dgod = 4.0*pi_ice*sigiv_ice*(rgermd*rgerm+rgerm*rgermd)/3.0
      dgo = 4.0*pi_ice*sigiv_ice*(rgerm*rgerm)/3.0
      dgd = fhet*dgod
      dg = dgo*fhet
      fderd = ((2.0*dgd*LOG(si)-2.0*dg*sid/si)*si/LOG(si)**2-2.0*dg*sid/&
&       LOG(si))/si**2/kb_ice/t_ice
      fder = 2.0*dg/LOG(si)/si/kb_ice/t_ice
      dtnuc = dtnuc_dep/fhet/waux_ice
      result1 = SQRT(fhet)
      aprimed = a*(sid*si+si*sid)/result1
      aprime = a*si*si/result1
      dgh = 0.0
      dtnucd = 0.0_8
      dghd = 0.0_8
    ELSE IF (mode .EQ. 2) THEN
!immersion of water droplets
      rgermd = 2.0*vw_ice*sigiw_iced/kb_ice/t_ice/LOG(vpresw_ice/&
&       vpresi_ice)
      rgerm = 2.0*vw_ice*sigiw_ice/kb_ice/t_ice/LOG(vpresw_ice/&
&       vpresi_ice)
      dgod = 4.0*pi_ice*((sigiw_iced*rgerm+sigiw_ice*rgermd)*rgerm+&
&       sigiw_ice*rgerm*rgermd)/3.0
      dgo = 4.0*pi_ice*sigiw_ice*(rgerm*rgerm)/3.0
      dgd = fhet*dgod
      dg = dgo*fhet
      ngd = 4.0*pi_ice*((rgermd*rgerm+rgerm*rgermd)*rgerm+rgerm**2*&
&       rgermd)/3.0/vw_ice
      ng = 4.0*pi_ice*rgerm*rgerm*rgerm/3.0/vw_ice
      dtnucd = -(kb_ice*t_ice**2*gct*dgd/(gct*(dact_imm+dg))**2)
      dtnuc = kb_ice*t_ice*t_ice/(gct*(dact_imm+dg))
      arg1d = dgod/fhet
      arg1 = dgo/fhet
      IF (arg1 .EQ. 0.0) THEN
        result1d = 0.0_8
      ELSE
        result1d = arg1d/(2.0*SQRT(arg1))
      END IF
      result1 = SQRT(arg1)
      aprimed = (aimm*result1d*ng-aimm*result1*ngd)/ng**2
      aprime = aimm*result1/ng
!
      fder = 1.0
      dgh = (m+1.0)*dgh_ice*1.60217646e-19
      fderd = 0.0_8
      dghd = 0.0_8
    ELSE
!DHF (Khvorostyanov and Curry, 2004)
      g = rv_ice*t_ice/lmeff_ice
      IF (sw .GT. 0.0 .OR. (sw .LT. 0.0 .AND. g .EQ. INT(g))) THEN
        pwr1d = g*sw**(g-1)*swd
      ELSE IF (sw .EQ. 0.0 .AND. g .EQ. 1.0) THEN
        pwr1d = swd
      ELSE
        pwr1d = 0.0
      END IF
      pwr1 = sw**g
      arg1d = to_ice*pwr1d/t_ice
      arg1 = pwr1*to_ice/t_ice
      rgermd = (2.0*sigiw_iced*denice_ice*lmeff_ice*LOG(arg1)-2.0*&
&       sigiw_ice*denice_ice*lmeff_ice*arg1d/arg1)/(denice_ice*lmeff_ice&
&       *LOG(arg1))**2
      rgerm = 2.0*sigiw_ice/(denice_ice*lmeff_ice*LOG(arg1))
      dgod = 4.0*pi_ice*((sigiw_iced*rgerm+sigiw_ice*rgermd)*rgerm+&
&       sigiw_ice*rgerm*rgermd)/3.0
      dgo = 4.0*pi_ice*sigiw_ice*(rgerm*rgerm)/3.0
      dgd = fhet*dgod
      dg = dgo*fhet
      ngd = 4.0*pi_ice*((rgermd*rgerm+rgerm*rgermd)*rgerm+rgerm**2*&
&       rgermd)/3.0/vw_ice
      ng = 4.0*pi_ice*rgerm*rgerm*rgerm/3.0/vw_ice
      dtnuc = dtnuc_dhf/fhet/waux_ice
      arg1d = dgod/fhet
      arg1 = dgo/fhet
      IF (arg1 .EQ. 0.0) THEN
        result1d = 0.0_8
      ELSE
        result1d = arg1d/(2.0*SQRT(arg1))
      END IF
      result1 = SQRT(arg1)
      aprimed = (aimm*result1d*ng-aimm*result1*ngd)/ng**2
      aprime = aimm*result1/ng
!new2
      fderd = ((2.0*g*(rgermd*dg+rgerm*dgd)*si/(kb_ice*t_ice)-2.0*rgerm*&
&       g*dg*sid/(kb_ice*t_ice))*rsc_ice/si**2-2.0*rgerm*g*dg*rsc_iced/(&
&       kb_ice*t_ice*si))/rsc_ice**2
      fder = 2.0*rgerm*g*dg/kb_ice/t_ice/si/rsc_ice
      dghd = dgh_ice*dgd
      dgh = dg*dgh_ice
      dtnucd = 0.0_8
    END IF
    IF (rgerm .LE. 0.0) THEN
      aprime = 0.0
      aprimed = 0.0_8
    END IF
    arg1d = -((dgd+dghd)/kb_ice/t_ice)
    arg1 = -((dg+dgh)/kb_ice/t_ice)
    jd = aprimed*EXP(arg1) + aprime*arg1d*EXP(arg1)
    j = aprime*EXP(arg1)
  END SUBROUTINE JHET_D
!  Differentiation of inspec_ice in reverse (adjoint) mode:
!   gradient     of useful results: dtnuc_dhf waux_ice abc_dep
!                norg_ice del1bc_ice del1dust_ice dtnuc_dep aimm
!                dact_imm si0dust_ice si0bc_ice lmeff_ice vw_ice
!                kdust_ice ndust_ice dorg_ice adust_dep kbc_ice
!                denice_ice vpresw_ice vpresi_ice dbc_ice ddust_ice
!                nbc_ice n t dsh six
!   with respect to varying inputs: dtnuc_dhf waux_ice abc_dep
!                norg_ice del1bc_ice del1dust_ice dtnuc_dep aimm
!                dact_imm si0dust_ice si0bc_ice lmeff_ice vw_ice
!                kdust_ice ndust_ice dorg_ice adust_dep kbc_ice
!                denice_ice vpresw_ice vpresi_ice dbc_ice ddust_ice
!                nbc_ice t six
!*************************************************************
! Subroutine INSPEC_ice
!  Provides the Ice Nuclei concentration (m-3) 
! and the chracteristic freezing threeshold, DSh (Barahona & Nenes 2009), at given 
! si and T. The variable typeofspec_ice (integer) has the values
! 1 Meyers et. al. 1992
! 2  Phillips et. al. 2007
! 3  Barahona & Nenes 2009
! 4  Phillips et. al. 2008 
! 5  Barahona,        2012 
! si is supersaturation wrt ice and T is in K 
!      Written by Donifan Barahona 
!      donifan.o.barahona@nasa.gov
!************************************************************  
  SUBROUTINE INSPEC_ICE_B(six, sixb, t, tb, n, nb, dsh, dshb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: six, t
    REAL*8 :: sixb, tb
    REAL*8 :: n, dsh
    REAL*8 :: nb, dshb
    REAL*8 :: nd, nbc, aux, si_, sw, del0, ddel0, fc, delw0, ddelw0, sw0&
&   , hdust, hbc, nbase, dnd, dnbc, dnbase, dh, dfc, ndaux, dndaux, &
&   dnorg, norg, ndustaux, frac, aux2, dx2, fdep, ndep, ndhf, dndep, &
&   dndhf, si, dfrac, siw
    REAL*8 :: ndb, nbcb, auxb, si_b, swb, del0b, ddel0b, fcb, delw0b, &
&   ddelw0b, sw0b, hdustb, hbcb, nbaseb, dndb, dnbcb, dnbaseb, dhb, dfcb&
&   , ndauxb, dndauxb, dnorgb, norgb, ndustauxb, fracb, dx2b, fdepb, &
&   ndepb, ndhfb, dndepb, dndhfb, sib, dfracb, siwb
!variables for DM11
    REAL*8 :: a, b, c, d, nbig, nbigexp, other
    REAL*8 :: nbigb, nbigexpb, otherb
    REAL*8, DIMENSION(3) :: sig_array, the_array, frac_array
    REAL*8 :: n_iw, dsh_s, asolo
    REAL*8 :: n_iwb, dsh_sb, asolob
    REAL*8, DIMENSION(1) :: nbc_s, dbc_s, d_grid_bio, n_grid_bio
    REAL*8, DIMENSION(1) :: nbc_sb, dbc_sb
    REAL*8, DIMENSION(nbindust_ice) :: ndust_s, ddust_s
    REAL*8, DIMENSION(nbindust_ice) :: ndust_sb, ddust_sb
    INTEGER :: index, kindex, mode
    INTRINSIC EXP
    INTRINSIC LOG
    INTRINSIC SQRT
    INTRINSIC MIN
    INTRINSIC MAX
    REAL*8 :: arg1
    REAL*8 :: arg1b
    DOUBLE PRECISION :: result1
    REAL*8 :: result2
    REAL*8 :: result2b
    REAL*8 :: pwx1
    REAL*8 :: pwx1b
    REAL*8 :: pwr1
    REAL*8 :: pwr1b
    REAL*8 :: x2
    REAL*8 :: x2b
    REAL*8 :: x1
    REAL*8 :: x1b
    REAL*8 :: arg10
    REAL*8 :: arg10b
    INTEGER :: branch
    REAL*8 :: tempb9
    REAL*8 :: tempb8
    REAL*8 :: tempb7
    REAL*8 :: tempb6
    REAL*8 :: tempb5
    REAL*8 :: tempb4
    REAL*8 :: tempb19
    REAL*8 :: tempb3
    REAL*8 :: tempb18
    REAL*8 :: tempb2
    REAL*8 :: tempb17
    REAL*8 :: tempb1
    REAL*8 :: tempb16
    REAL*8 :: tempb0
    REAL*8 :: tempb15
    REAL*8 :: tempb14
    REAL*8 :: tempb13
    REAL*8 :: tempb12
    REAL*8 :: tempb11
    REAL*8 :: tempb10
    REAL*8 :: dummydiffb0
    REAL*8 :: tempb
    REAL*8 :: dummydiffb
    REAL*8 :: tempb25
    REAL*8 :: temp
    REAL*8 :: tempb24
    REAL*8 :: tempb23
    REAL*8 :: tempb22
    REAL*8 :: tempb21
    REAL*8 :: tempb20
    si = six
    si_ = si + 1d0
!new2
    sw = si_*vpresi_ice/vpresw_ice
    IF (sw .GE. 1.0) THEN
!limit to subsaturated conditions
      sw = 1.0
      si_ = vpresw_ice/vpresi_ice
      si = si_ - 1.0
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    siw = vpresw_ice/vpresi_ice
    sig_array = 0.0
    the_array = 0.0
    frac_array = 0.0
    SELECT CASE  (typeofspec_ice) 
    CASE (1) 
!Phillips2007
      IF (t .LE. 243d0) THEN
        CALL PUSHREAL8(dsh)
        dsh = 1d0/3.88d0
        CALL PUSHCONTROL4B(0)
      ELSE
        CALL PUSHREAL8(dsh)
        dsh = 1d0/12.96d0
        CALL PUSHCONTROL4B(1)
      END IF
    CASE (2) 
!Meyers1992 
      CALL PUSHREAL8(dsh)
      dsh = 1d0/12.96d0
      CALL PUSHCONTROL4B(2)
    CASE (3) 
!Barahona&Nenes CNT
!dust contribution
      ndustaux = 0.0d0
      DO index=1,nbindust_ice
        ndustaux = ndustaux + ndust_ice(index)
      END DO
      IF (si .LE. shdust_ice) THEN
        arg1 = -(kdust_ice*(shdust_ice-si))
        nd = si/shdust_ice*ndustaux*effdust_ice*EXP(arg1)
        dnd = nd*(1d0/si+kdust_ice)
        CALL PUSHCONTROL1B(0)
      ELSE
        nd = ndustaux*effdust_ice
        dnd = 0d0
        CALL PUSHCONTROL1B(1)
      END IF
!soot contribution
      IF (si .LE. shbc_ice) THEN
        arg1 = -(kbc_ice*(shbc_ice-si))
        nbc = si/shbc_ice*nbc_ice*effbc_ice*EXP(arg1)
        dnbc = nbc*(1d0/si+kbc_ice)
        CALL PUSHCONTROL1B(0)
      ELSE
        nbc = nbc_ice*effbc_ice
        dnbc = 0d0
        CALL PUSHCONTROL1B(1)
      END IF
      n = nd + nbc
      IF (dnd + dnbc .GT. 0d0) THEN
        CALL PUSHREAL8(dsh)
        dsh = n/(dnd+dnbc)
        CALL PUSHCONTROL4B(3)
      ELSE
        CALL PUSHREAL8(dsh)
        dsh = si
        CALL PUSHCONTROL4B(4)
      END IF
    CASE (4) 
!PDA2008. Allows multiple lognormal modes for dust. Single mode lognormal distributions are assumed for bc and organics
! Dust
      sw0 = 0.97d0
      delw0 = CUBICINT_ICE(sw, sw0, 1d0, 0d0, 1d0)
      ddelw0 = DCUBICINT_ICE(sw, sw0, 1d0, 0d0, 1d0)
      nbase = PDG07_ICE(si, t)
      IF (t .LE. 243d0) THEN
        dnbase = 3.88d0*nbase
        CALL PUSHCONTROL1B(0)
      ELSE
        dnbase = 12.96d0*nbase
        CALL PUSHCONTROL1B(1)
      END IF
!dust contribution
      arg10 = si0dust_ice + 0.1d0
      del0 = CUBICINT_ICE(si_, si0dust_ice, arg10, 0d0, 1d0)
      arg10 = si0dust_ice + 0.1d0
      ddel0 = DCUBICINT_ICE(si_, si0dust_ice, arg10, 0d0, 1d0)
      fc = 0.5d0*del1dust_ice*del0
      dfc = 0.5d0*del1dust_ice*ddel0
      hdust = fc + (1d0-fc)*delw0
      dh = dfc*(1d0-delw0) + ddelw0*(1d0-fc)
      IF (hdust .GT. 1d0) THEN
        hdust = 1d0
        dh = 0d0
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      aux = 2d0/3d0*hdust*(nbase/0.76d0)*pi_ice/5.0d-7/4d0
!The last 4d0 was introduced as recommnedation of V Phillips
      aux2 = 2d0/3d0*pi_ice/0.76d0/5.0d-7/4d0
      nd = 0d0
      dnd = 0d0
      DO index=1,nbindust_ice
!Dx2= ddust_ice(index)*ddust_ice(index)
!new 07/10/12
        CALL PUSHREAL8(dx2)
        dx2 = ddust_ice(index)*ddust_ice(index)*ddust_ice(index)*0.52*&
&         acorr_dust
!fraction above 0.1 microns
!sigma_dust=log(sigma_bc_g)
        CALL PUSHREAL8(result1)
        result1 = SQRT(2d0)
        CALL PUSHREAL8(arg10)
        arg10 = -(LOG(ddust_ice(index)/0.1e-6)/sigdust_ice(index)/&
&         result1)
        result2 = ERFAPP(arg10)
        CALL PUSHREAL8(frac)
        frac = 0.5d0*(1d0-result2)
        CALL PUSHREAL8(ndaux)
        ndaux = frac*ndust_ice(index)*(1d0-EXP(-(aux*dx2)))
        nd = nd + ndaux
        ndaux = frac*ndust_ice(index) - ndaux
        dndaux = ndaux*(dh*nbase+hdust*dnbase)*aux2*dx2
        dnd = dnd + dndaux
      END DO
!soot contribution
      CALL PUSHREAL8(arg10)
      arg10 = si0bc_ice + 0.1d0
      CALL PUSHREAL8(del0)
      del0 = CUBICINT_ICE(si_, si0bc_ice, arg10, 0d0, 1d0)
      arg10 = si0bc_ice + 0.1d0
      CALL PUSHREAL8(ddel0)
      ddel0 = DCUBICINT_ICE(si_, si0bc_ice, arg10, 0d0, 1d0)
      CALL PUSHREAL8(fc)
      fc = 0.5d0*del1bc_ice*del0
      hbc = fc + (1d0-fc)*delw0
      CALL PUSHREAL8(dfc)
      dfc = 0.5d0*del1bc_ice*ddel0
      CALL PUSHREAL8(dh)
      dh = dfc*(1d0-delw0) + ddelw0*(1d0-fc)
      IF (hbc .GT. 1d0) THEN
        hbc = 1d0
        dh = 0d0
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
!sigbc=log(sigma_bc_g)
      CALL PUSHREAL8(result1)
      result1 = SQRT(2d0)
      arg10 = -(LOG(dbc_ice/0.1e-6)/sigbc_ice/result1)
      result2 = ERFAPP(arg10)
      CALL PUSHREAL8(frac)
      frac = 0.5d0*(1d0-result2)
!Dx2=dbc_ice*dbc_ice	       
!new 07/10/12
      CALL PUSHREAL8(dx2)
      dx2 = dbc_ice*dbc_ice*dbc_ice*0.52*acorr_bc
      aux = (1d0/3d0-0.06d0)*hbc*(nbase/0.76d0)*pi_ice/2.7d-7
      aux2 = (1d0/3d0-0.06d0)*pi_ice/0.76d0/2.7d-7
      nbc = nbc_ice*frac*(1d0-EXP(-(aux*dx2)))
      dnbc = (nbc_ice*frac-nbc)*(dh*nbase+hbc*dnbase)*aux2*dx2
!Organics contribution
!sigorg=log(sigma_org_g)
      CALL PUSHREAL8(result1)
      result1 = SQRT(2d0)
      CALL PUSHREAL8(arg10)
      arg10 = -(LOG(dorg_ice/0.1e-6)/sigorg_ice/result1)
      result2 = ERFAPP(arg10)
      CALL PUSHREAL8(frac)
      frac = 0.5d0*(1d0-result2)
      dx2 = dorg_ice*dorg_ice
      aux = 0.06d0*hbc*(nbase/0.76d0)*pi_ice/9.1d-7
      aux2 = 0.06d0*pi_ice/0.76d0/9.1d-7
      norg = norg_ice*frac*(1d0-EXP(-(aux*dx2)))
      dnorg = (norg_ice*frac-norg)*(dh*nbase+hbc*dnbase)*aux2*dx2
      n = nd + nbc + norg
      IF (dnd + dnbc + dnorg .GT. 0d0) THEN
        CALL PUSHREAL8(dsh)
        dsh = n/(dnd+dnbc+dnorg)
        CALL PUSHCONTROL4B(5)
      ELSE
        CALL PUSHREAL8(dsh)
        dsh = si
        CALL PUSHCONTROL4B(6)
      END IF
    CASE (5) 
!Phillips et al 2013.
      d_grid_bio(1) = dbio_ice
      n_grid_bio(1) = nbio_ice
!dust
      DO index=1,nbindust_ice
!fraction above 0.1 microns
        CALL PUSHREAL8(result1)
        result1 = SQRT(2d0)
        CALL PUSHREAL8(arg10)
        arg10 = LOG(0.1e-6/ddust_ice(index))/sigdust_ice(index)/result1
        result2 = ERFAPP(arg10)
        CALL PUSHREAL8(frac)
        frac = 0.5d0*(1d0-result2)
        ndust_s(index) = frac*ndust_ice(index)
        ddust_s = ddust_ice(index)
      END DO
!black carbon
!fraction above 0.1 microns
      CALL PUSHREAL8(result1)
      result1 = SQRT(2d0)
      CALL PUSHREAL8(arg10)
      arg10 = LOG(0.1e-6/dbc_ice)/sigbc_ice/result1
      result2 = ERFAPP(arg10)
      CALL PUSHREAL8(frac)
      frac = 0.5d0*(1d0-result2)
      nbc_s(1) = frac*nbc_ice
      IF (dbc_ice .GT. 2.e-6) THEN
        CALL PUSHREAL8(dbc_ice)
        dbc_ice = 2.e-6
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHREAL8(dbc_ice)
        dbc_ice = dbc_ice
        CALL PUSHCONTROL1B(1)
      END IF
      dbc_s(1) = dbc_ice*1.0
!Soluble organics (spherical)
!sigorg=log(sigma_org_g) !20-30% of organics are soluble (Saxena and HIdeelman 1996). 
      CALL PUSHREAL8(result1)
      result1 = SQRT(2d0)
      CALL PUSHREAL8(arg10)
      arg10 = LOG(0.1e-6/dorg_ice)/sigorg_ice/result1
      result2 = ERFAPP(arg10)
      CALL PUSHREAL8(frac)
      frac = 0.25d0*0.5d0*(1d0-result2)
!
      asolo = frac*norg_ice*3.1415*dorg_ice*dorg_ice
      CALL EMPIRICAL_PARAM_PHILLIPS(t, pice, si_, siw, sw, ddust_s, &
&                             ndust_s, 2, dbc_s, nbc_s, 1, d_grid_bio, &
&                             n_grid_bio, 1, asolo, n_iw, dsh_s)
      CALL PUSHREAL8(dsh)
      dsh = dsh_s
      CALL PUSHCONTROL4B(7)
    CASE (6) 
!Barahona 2012. Spectrum based on NPDF-Theory and CNT (Unpublished)
!dust contribution*******************************************
!linear approx to decide DHF vs deposition, loosely based on Seisel 2005.
      fdep = (1.0-sw)/0.1
      IF (fdep .LT. 0.0) THEN
        x1 = 0.0
        CALL PUSHCONTROL1B(0)
      ELSE
        x1 = fdep
        CALL PUSHCONTROL1B(1)
      END IF
      IF (x1 .GT. 1.0) THEN
        fdep = 1.0
        CALL PUSHCONTROL1B(0)
      ELSE
        fdep = x1
        CALL PUSHCONTROL1B(1)
      END IF
!Deposition *******
!deposition             
      mode = 1
      sig_array(1) = 21.4
      sig_array(2) = 21.4
      sig_array(3) = 21.4
      the_array(1) = 9.9
      the_array(2) = 15.1
      the_array(3) = 19.8
      frac_array(1) = 0.20
      frac_array(2) = 0.25
      frac_array(3) = 0.55
      dgh_ice = 0.0
      ndep = 0.0
      dndep = 0.0
      DO index=1,nbindust_ice
!new 07/10/12    
        dx2 = ddust_ice(index)*ddust_ice(index)*ddust_ice(index)*0.52*&
&         acorr_dust
!Dx2= ddust_ice(index)*ddust_ice(index)*pi_ice*4.0 !Assume spheres by now
        CALL PUSHREAL8(dfrac)
        CALL PUSHREAL8(frac)
        CALL NUC_FRAC(frac, dfrac, sig_array, the_array, frac_array, t, &
&               si_, mode, dx2, adust_dep, 3)
        ndaux = frac*ndust_ice(index)*fdep
        ndep = ndep + ndaux
        dndaux = dfrac*ndust_ice(index)*fdep
        dndep = dndep + dndaux
      END DO
!immersion *******
      mode = 3
!sig_array=(/ 10.0, 10.0, 10.0 /)
!the_array=(/ 85.0, 85.0, 85.0 /)
!frac_array=(/ 1.0, 0.0, 0.0 /)      
      CALL PUSHREAL8(sig_array(1))
      sig_array(1) = 1.014
      CALL PUSHREAL8(sig_array(2))
      sig_array(2) = 1.014
      CALL PUSHREAL8(sig_array(3))
      sig_array(3) = 1.014
      CALL PUSHREAL8(the_array(1))
      the_array(1) = 53.44
      CALL PUSHREAL8(the_array(2))
      the_array(2) = 53.44
      CALL PUSHREAL8(the_array(3))
      the_array(3) = 53.44
      CALL PUSHREAL8(frac_array(1))
      frac_array(1) = 1.0
      CALL PUSHREAL8(frac_array(2))
      frac_array(2) = 0.0
      CALL PUSHREAL8(frac_array(3))
      frac_array(3) = 0.0
      dgh_ice = 0.5
      ndhf = 0.0
      dndhf = 0.0
      DO index=1,nbindust_ice
!new 07/10/12
        dx2 = ddust_ice(index)*ddust_ice(index)*ddust_ice(index)*0.52*&
&         acorr_dust
!Dx2= ddust_ice(index)*ddust_ice(index)*pi_ice*4.0 !Assume spheres by now
        CALL PUSHREAL8(dfrac)
        CALL PUSHREAL8(frac)
        CALL NUC_FRAC(frac, dfrac, sig_array, the_array, frac_array, t, &
&               si_, mode, dx2, aimm, 1)
        ndaux = frac*ndust_ice(index)*(1.0-fdep)
        ndhf = ndhf + ndaux
        dndaux = dfrac*ndust_ice(index)*(1.0-fdep)
        dndhf = dndhf + dndaux
      END DO
      nd = ndep + ndhf
      dnd = dndep + dndhf
!soot contribution*****************************************
!linear approx to decide DHF vs deposition, loosely based on Seisel 2005.
      CALL PUSHREAL8(fdep)
      fdep = (1.0-sw)/0.1
      IF (fdep .LT. 0.0) THEN
        x2 = 0.0
        CALL PUSHCONTROL1B(0)
      ELSE
        x2 = fdep
        CALL PUSHCONTROL1B(1)
      END IF
      IF (x2 .GT. 1.0) THEN
        fdep = 1.0
        CALL PUSHCONTROL1B(0)
      ELSE
        fdep = x2
        CALL PUSHCONTROL1B(1)
      END IF
!deposition***
      mode = 1
      CALL PUSHREAL8(sig_array(1))
      sig_array(1) = 28.3
      CALL PUSHREAL8(sig_array(2))
      sig_array(2) = 28.3
      CALL PUSHREAL8(sig_array(3))
      sig_array(3) = 28.3
      CALL PUSHREAL8(the_array(1))
      the_array(1) = 34.2
      CALL PUSHREAL8(the_array(2))
      the_array(2) = 34.2
      CALL PUSHREAL8(the_array(3))
      the_array(3) = 34.2
      CALL PUSHREAL8(frac_array(1))
      frac_array(1) = 1.0
      CALL PUSHREAL8(frac_array(2))
      frac_array(2) = 0.0
      CALL PUSHREAL8(frac_array(3))
      frac_array(3) = 0.0
      dgh_ice = 0.0
!new 07/10/12
      dx2 = dbc_ice*dbc_ice*dbc_ice*0.52*acorr_bc
!Dx2=100.0e-12  !Popovicheva 2006. Not safe assuming spheres      
      CALL PUSHREAL8(dfrac)
      CALL PUSHREAL8(frac)
      CALL NUC_FRAC(frac, dfrac, sig_array, the_array, frac_array, t, &
&             si_, mode, dx2, abc_dep, 1)
      ndep = frac*nbc_ice*fdep
      dndep = dfrac*nbc_ice*fdep
!Immersion***	 
      mode = 3
!sig_array=(/ 3.0, 3.0, 3.0 /)
!the_array=(/ 153.8, 153.8, 153.8/) !Barahona, in prep
      CALL PUSHREAL8(sig_array(1))
      sig_array(1) = 2.7988
      CALL PUSHREAL8(sig_array(2))
      sig_array(2) = 2.7
      CALL PUSHREAL8(sig_array(3))
      sig_array(3) = 2.7
      CALL PUSHREAL8(the_array(1))
      the_array(1) = 49.1769
      CALL PUSHREAL8(the_array(2))
      the_array(2) = 49.1769
      CALL PUSHREAL8(the_array(3))
      the_array(3) = 49.0
      CALL PUSHREAL8(frac_array(1))
      frac_array(1) = 1.0
      CALL PUSHREAL8(frac_array(2))
      frac_array(2) = 0.0
      CALL PUSHREAL8(frac_array(3))
      frac_array(3) = 0.0
      dgh_ice = 6.45
      CALL PUSHREAL8(dfrac)
      CALL PUSHREAL8(frac)
      CALL NUC_FRAC(frac, dfrac, sig_array, the_array, frac_array, t, &
&             si_, mode, dx2, aimm, 1)
      ndhf = frac*nbc_ice*(1.0-fdep)
      dndhf = dfrac*nbc_ice*(1.0-fdep)
      nbc = ndep + ndhf
      dnbc = dndep + dndhf
!Total   	 
      n = nd + nbc
      IF (dnd + dnbc .GT. 0d0) THEN
        CALL PUSHREAL8(dsh)
        dsh = n/(dnd+dnbc)
        CALL PUSHCONTROL4B(8)
      ELSE
        CALL PUSHREAL8(dsh)
        dsh = si
        CALL PUSHCONTROL4B(9)
      END IF
    CASE (7) 
!DeMott 2011
      nd = 0.0d0
      a = 0.0000594d0
      b = 3.33d0
      c = 0.0264d0
      d = 0.0033d0
!dust number with D > 0.5 um
      DO index=1,nbindust_ice
!fraction above 0.5 microns
        CALL PUSHREAL8(result1)
        result1 = SQRT(2d0)
        CALL PUSHREAL8(arg10)
        arg10 = -(LOG(ddust_ice(index)/0.5d-6)/sigdust_ice(index)/&
&         result1)
        result2 = ERFAPP(arg10)
        CALL PUSHREAL8(frac)
        frac = 0.5d0*(1d0-result2)
        nd = nd + frac*ndust_ice(index)
      END DO
!BC number with D > 0.5 um
!sigbc=log(sigma_bc_g)
      CALL PUSHREAL8(result1)
      result1 = SQRT(2d0)
      CALL PUSHREAL8(arg10)
      arg10 = -(LOG(dbc_ice/0.5d-6)/sigbc_ice/result1)
      result2 = ERFAPP(arg10)
      CALL PUSHREAL8(frac)
      frac = 0.5d0*(1d0-result2)
      nbc = frac*nbc_ice
!org number with D > 0.5 um
!sigorg=log(sigma_org_g)
      CALL PUSHREAL8(result1)
      result1 = SQRT(2d0)
      CALL PUSHREAL8(arg10)
      arg10 = -(LOG(dorg_ice/0.5d-6)/sigorg_ice/result1)
      result2 = ERFAPP(arg10)
      CALL PUSHREAL8(frac)
      frac = 0.5d0*(1d0-result2)
      norg = frac*norg_ice
      nbig = nd + nbc + norg
!nbig must be in cc-1
      nbig = nbig/10d6
      nbigexp = c*(273.16d0-t) + d
      pwx1 = 273.16d0 - t
      pwr1 = pwx1**b
      n = a*pwr1
      other = nbig**nbigexp
!N should be output in m-3
      CALL PUSHREAL8(dsh)
      dsh = si
      CALL PUSHCONTROL4B(10)
    CASE DEFAULT
      CALL PUSHREAL8(dsh)
      dsh = si
      CALL PUSHCONTROL4B(11)
    END SELECT
    IF (dsh .GE. si) THEN
      sib = dshb
      dshb = 0.0_8
    ELSE
      sib = 0.0_8
    END IF
    CALL POPCONTROL4B(branch)
    IF (branch .LT. 6) THEN
      IF (branch .LT. 3) THEN
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(dsh)
        ELSE IF (branch .EQ. 1) THEN
          CALL POPREAL8(dsh)
        ELSE
          CALL POPREAL8(dsh)
          sib = sib + EXP(12.96d0*si)*EXP(-0.639d0)*1000d0*12.96d0*nb
          si_b = 0.0_8
          swb = 0.0_8
          siwb = 0.0_8
          GOTO 110
        END IF
        CALL PDG07_ICE_B(si, sib, t, nb)
        si_b = 0.0_8
        swb = 0.0_8
        siwb = 0.0_8
      ELSE
        IF (branch .EQ. 3) THEN
          CALL POPREAL8(dsh)
          tempb2 = dshb/(dnd+dnbc)
          tempb3 = -(n*tempb2/(dnd+dnbc))
          nb = nb + tempb2
          dndb = tempb3
          dnbcb = tempb3
        ELSE IF (branch .EQ. 4) THEN
          CALL POPREAL8(dsh)
          sib = sib + dshb
          dndb = 0.0_8
          dnbcb = 0.0_8
        ELSE
          CALL POPREAL8(dsh)
          tempb21 = dshb/(dnd+dnbc+dnorg)
          tempb22 = -(n*tempb21/(dnd+dnbc+dnorg))
          nb = nb + tempb21
          dndb = tempb22
          dnbcb = tempb22
          dnorgb = tempb22
          GOTO 100
        END IF
        ndb = nb
        nbcb = nb
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          nbcb = nbcb + (1.0/si+kbc_ice)*dnbcb
          tempb1 = EXP(arg1)*effbc_ice*nbcb/shbc_ice
          nbc_iceb = nbc_iceb + si*tempb1
          arg1b = si*nbc_ice*effbc_ice*EXP(arg1)*nbcb/shbc_ice
          sib = sib + nbc_ice*tempb1 + kbc_ice*arg1b - nbc*dnbcb/si**2
          kbc_iceb = kbc_iceb + nbc*dnbcb - (shbc_ice-si)*arg1b
        ELSE
          nbc_iceb = nbc_iceb + effbc_ice*nbcb
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          ndb = ndb + (1.0/si+kdust_ice)*dndb
          arg1 = -(kdust_ice*(shdust_ice-si))
          tempb0 = EXP(arg1)*effdust_ice*ndb/shdust_ice
          ndustauxb = si*tempb0
          arg1b = si*ndustaux*effdust_ice*EXP(arg1)*ndb/shdust_ice
          sib = sib + ndustaux*tempb0 + kdust_ice*arg1b - nd*dndb/si**2
          kdust_iceb = kdust_iceb + nd*dndb - (shdust_ice-si)*arg1b
        ELSE
          ndustauxb = effdust_ice*ndb
        END IF
        DO index=nbindust_ice,1,-1
          ndust_iceb(index) = ndust_iceb(index) + ndustauxb
        END DO
        si_b = 0.0_8
        swb = 0.0_8
        siwb = 0.0_8
      END IF
    ELSE
      IF (branch .LT. 9) THEN
        IF (branch .EQ. 6) THEN
          CALL POPREAL8(dsh)
          sib = sib + dshb
          dndb = 0.0_8
          dnorgb = 0.0_8
          dnbcb = 0.0_8
          GOTO 100
        ELSE IF (branch .EQ. 7) THEN
          CALL POPREAL8(dsh)
          dsh_sb = dshb
          n_iwb = nb
          CALL EMPIRICAL_PARAM_PHILLIPS_B(t, tb, pice, si_, si_b, siw, &
&                                   siwb, sw, swb, ddust_s, ddust_sb, &
&                                   ndust_s, ndust_sb, 2, dbc_s, dbc_sb&
&                                   , nbc_s, nbc_sb, 1, d_grid_bio, &
&                                   n_grid_bio, 1, asolo, asolob, n_iw, &
&                                   n_iwb, dsh_s, dsh_sb)
          tempb23 = 3.1415*dorg_ice**2*asolob
          fracb = norg_ice*tempb23
          norg_iceb = norg_iceb + frac*tempb23
          dorg_iceb = dorg_iceb + frac*norg_ice*3.1415*2*dorg_ice*asolob
          CALL POPREAL8(frac)
          result2b = -(0.5d0*0.25d0*fracb)
          arg10b = 0.0_8
          CALL ERFAPP_B(arg10, arg10b, result2b)
          CALL POPREAL8(arg10)
          dorg_iceb = dorg_iceb - arg10b/(dorg_ice*sigorg_ice*result1)
          CALL POPREAL8(result1)
          dbc_iceb = dbc_iceb + dbc_sb(1)
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL8(dbc_ice)
            dbc_iceb = 0.0_8
          ELSE
            CALL POPREAL8(dbc_ice)
          END IF
          fracb = nbc_ice*nbc_sb(1)
          nbc_iceb = nbc_iceb + frac*nbc_sb(1)
          CALL POPREAL8(frac)
          result2b = -(0.5d0*fracb)
          arg10b = 0.0_8
          CALL ERFAPP_B(arg10, arg10b, result2b)
          CALL POPREAL8(arg10)
          dbc_iceb = dbc_iceb - arg10b/(dbc_ice*sigbc_ice*result1)
          CALL POPREAL8(result1)
          DO index=nbindust_ice,1,-1
            temp = 0.1e-6/ddust_ice(index)
            fracb = ndust_ice(index)*ndust_sb(index)
            ndust_iceb(index) = ndust_iceb(index) + frac*ndust_sb(index)
            CALL POPREAL8(frac)
            result2b = -(0.5d0*fracb)
            arg10b = 0.0_8
            CALL ERFAPP_B(arg10, arg10b, result2b)
            ddust_iceb(index) = ddust_iceb(index) + SUM(ddust_sb) - &
&             arg10b/(ddust_ice(index)*sigdust_ice(index)*result1)
            ndust_sb(index) = 0.0_8
            CALL POPREAL8(arg10)
            CALL POPREAL8(result1)
            ddust_sb = 0.0_8
          END DO
          GOTO 110
        ELSE
          CALL POPREAL8(dsh)
          tempb24 = dshb/(dnd+dnbc)
          tempb25 = -(n*tempb24/(dnd+dnbc))
          nb = nb + tempb24
          dndb = tempb25
          dnbcb = tempb25
        END IF
      ELSE IF (branch .EQ. 9) THEN
        CALL POPREAL8(dsh)
        sib = sib + dshb
        dndb = 0.0_8
        dnbcb = 0.0_8
      ELSE
        IF (branch .EQ. 10) THEN
          CALL POPREAL8(dsh)
          sib = sib + dshb
          nb = 1000d0*nb
          otherb = n*nb
          nb = other*nb
          IF (nbig .LE. 0.0 .AND. (nbigexp .EQ. 0.0 .OR. nbigexp .NE. &
&             INT(nbigexp))) THEN
            nbigb = 0.0
          ELSE
            nbigb = nbigexp*nbig**(nbigexp-1)*otherb
          END IF
          IF (nbig .LE. 0.0) THEN
            nbigexpb = 0.0
          ELSE
            nbigexpb = nbig**nbigexp*LOG(nbig)*otherb
          END IF
          pwr1b = a*nb
          IF (pwx1 .LE. 0.0 .AND. (b .EQ. 0.0 .OR. b .NE. INT(b))) THEN
            pwx1b = 0.0
          ELSE
            pwx1b = b*pwx1**(b-1)*pwr1b
          END IF
          tb = tb - c*nbigexpb - pwx1b
          nbigb = nbigb/10d6
          ndb = nbigb
          nbcb = nbigb
          norgb = nbigb
          fracb = norg_ice*norgb
          norg_iceb = norg_iceb + frac*norgb
          CALL POPREAL8(frac)
          result2b = -(0.5d0*fracb)
          arg10b = 0.0_8
          CALL ERFAPP_B(arg10, arg10b, result2b)
          CALL POPREAL8(arg10)
          dorg_iceb = dorg_iceb - arg10b/(dorg_ice*sigorg_ice*result1)
          CALL POPREAL8(result1)
          fracb = nbc_ice*nbcb
          nbc_iceb = nbc_iceb + frac*nbcb
          CALL POPREAL8(frac)
          result2b = -(0.5d0*fracb)
          arg10b = 0.0_8
          CALL ERFAPP_B(arg10, arg10b, result2b)
          CALL POPREAL8(arg10)
          dbc_iceb = dbc_iceb - arg10b/(dbc_ice*sigbc_ice*result1)
          CALL POPREAL8(result1)
          DO index=nbindust_ice,1,-1
            fracb = ndust_ice(index)*ndb
            ndust_iceb(index) = ndust_iceb(index) + frac*ndb
            CALL POPREAL8(frac)
            result2b = -(0.5d0*fracb)
            arg10b = 0.0_8
            CALL ERFAPP_B(arg10, arg10b, result2b)
            CALL POPREAL8(arg10)
            ddust_iceb(index) = ddust_iceb(index) - arg10b/(ddust_ice(&
&             index)*sigdust_ice(index)*result1)
            CALL POPREAL8(result1)
          END DO
          si_b = 0.0_8
          swb = 0.0_8
          siwb = 0.0_8
        ELSE
          CALL POPREAL8(dsh)
          sib = sib + dshb
          si_b = 0.0_8
          swb = 0.0_8
          siwb = 0.0_8
        END IF
        GOTO 110
      END IF
      ndb = nb
      nbcb = nb
      dndepb = dnbcb
      dndhfb = dnbcb
      ndepb = nbcb
      ndhfb = nbcb
      dfracb = (1.0-fdep)*nbc_ice*dndhfb
      nbc_iceb = nbc_iceb + (1.0-fdep)*frac*ndhfb + (1.0-fdep)*dfrac*&
&       dndhfb
      fdepb = -(frac*nbc_ice*ndhfb) - dfrac*nbc_ice*dndhfb
      fracb = (1.0-fdep)*nbc_ice*ndhfb
      CALL POPREAL8(frac)
      CALL POPREAL8(dfrac)
      si_b = 0.0_8
      dx2b = 0.0_8
      CALL NUC_FRAC_B(frac, fracb, dfrac, dfracb, sig_array, the_array, &
&               frac_array, t, tb, si_, si_b, mode, dx2, dx2b, aimm, &
&               aimmb, 1)
      CALL POPREAL8(frac_array(3))
      CALL POPREAL8(frac_array(2))
      CALL POPREAL8(frac_array(1))
      CALL POPREAL8(the_array(3))
      CALL POPREAL8(the_array(2))
      CALL POPREAL8(the_array(1))
      CALL POPREAL8(sig_array(3))
      CALL POPREAL8(sig_array(2))
      CALL POPREAL8(sig_array(1))
      dfracb = fdep*nbc_ice*dndepb
      nbc_iceb = nbc_iceb + fdep*frac*ndepb + fdep*dfrac*dndepb
      fdepb = fdepb + frac*nbc_ice*ndepb + dfrac*nbc_ice*dndepb
      fracb = fdep*nbc_ice*ndepb
      dgh_ice = 0.0
      mode = 1
      CALL POPREAL8(frac)
      CALL POPREAL8(dfrac)
      CALL NUC_FRAC_B(frac, fracb, dfrac, dfracb, sig_array, the_array, &
&               frac_array, t, tb, si_, si_b, mode, dx2, dx2b, abc_dep, &
&               abc_depb, 1)
      dbc_iceb = dbc_iceb + acorr_bc*0.52*3*dbc_ice**2*dx2b
      CALL POPREAL8(frac_array(3))
      CALL POPREAL8(frac_array(2))
      CALL POPREAL8(frac_array(1))
      CALL POPREAL8(the_array(3))
      CALL POPREAL8(the_array(2))
      CALL POPREAL8(the_array(1))
      CALL POPREAL8(sig_array(3))
      CALL POPREAL8(sig_array(2))
      CALL POPREAL8(sig_array(1))
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        x2b = 0.0_8
      ELSE
        x2b = fdepb
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        fdepb = 0.0_8
      ELSE
        fdepb = x2b
      END IF
      CALL POPREAL8(fdep)
      swb = -(fdepb/0.1)
      dndepb = dndb
      dndhfb = dndb
      ndepb = ndb
      ndhfb = ndb
      dgh_ice = 0.5
      mode = 3
      fdepb = 0.0_8
      DO index=nbindust_ice,1,-1
        ndauxb = ndhfb
        dndauxb = dndhfb
        ndust_iceb(index) = ndust_iceb(index) + frac*(1.0-fdep)*ndauxb +&
&         dfrac*(1.0-fdep)*dndauxb
        dfracb = ndust_ice(index)*(1.0-fdep)*dndauxb
        fdepb = fdepb - frac*ndust_ice(index)*ndauxb - dfrac*ndust_ice(&
&         index)*dndauxb
        fracb = ndust_ice(index)*(1.0-fdep)*ndauxb
        dx2 = ddust_ice(index)*ddust_ice(index)*ddust_ice(index)*0.52*&
&         acorr_dust
        CALL POPREAL8(frac)
        CALL POPREAL8(dfrac)
        dx2b = 0.0_8
        CALL NUC_FRAC_B(frac, fracb, dfrac, dfracb, sig_array, the_array&
&                 , frac_array, t, tb, si_, si_b, mode, dx2, dx2b, aimm&
&                 , aimmb, 1)
        ddust_iceb(index) = ddust_iceb(index) + acorr_dust*0.52*3*&
&         ddust_ice(index)**2*dx2b
      END DO
      CALL POPREAL8(frac_array(3))
      CALL POPREAL8(frac_array(2))
      CALL POPREAL8(frac_array(1))
      CALL POPREAL8(the_array(3))
      CALL POPREAL8(the_array(2))
      CALL POPREAL8(the_array(1))
      CALL POPREAL8(sig_array(3))
      CALL POPREAL8(sig_array(2))
      CALL POPREAL8(sig_array(1))
      dgh_ice = 0.0
      mode = 1
      DO index=nbindust_ice,1,-1
        ndauxb = ndepb
        dndauxb = dndepb
        ndust_iceb(index) = ndust_iceb(index) + frac*fdep*ndauxb + dfrac&
&         *fdep*dndauxb
        dfracb = ndust_ice(index)*fdep*dndauxb
        fdepb = fdepb + ndust_ice(index)*frac*ndauxb + ndust_ice(index)*&
&         dfrac*dndauxb
        fracb = ndust_ice(index)*fdep*ndauxb
        dx2 = ddust_ice(index)*ddust_ice(index)*ddust_ice(index)*0.52*&
&         acorr_dust
        CALL POPREAL8(frac)
        CALL POPREAL8(dfrac)
        dx2b = 0.0_8
        CALL NUC_FRAC_B(frac, fracb, dfrac, dfracb, sig_array, the_array&
&                 , frac_array, t, tb, si_, si_b, mode, dx2, dx2b, &
&                 adust_dep, adust_depb, 3)
        ddust_iceb(index) = ddust_iceb(index) + acorr_dust*0.52*3*&
&         ddust_ice(index)**2*dx2b
      END DO
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        x1b = 0.0_8
      ELSE
        x1b = fdepb
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        fdepb = 0.0_8
      ELSE
        fdepb = x1b
      END IF
      swb = swb - fdepb/0.1
      siwb = 0.0_8
    END IF
    GOTO 110
 100 tempb11 = aux2*(dh*nbase+hbc*dnbase)*dnorgb
    tempb10 = dx2*tempb11
    norgb = nb - tempb10
    tempb12 = aux2*(norg_ice*frac-norg)*dx2*dnorgb
    tempb13 = (1d0-EXP(-(aux*dx2)))*norgb
    tempb14 = -(norg_ice*frac*EXP(-(aux*dx2))*norgb)
    auxb = -(dx2*tempb14)
    aux2 = (1d0/3d0-0.06d0)*pi_ice/0.76d0/2.7d-7
    dx2 = dbc_ice*dbc_ice*dbc_ice*0.52*acorr_bc
    tempb18 = aux2*(dh*nbase+hbc*dnbase)*dnbcb
    tempb9 = dx2*tempb18
    ndb = nb
    nbcb = nb - tempb9
    norg_iceb = norg_iceb + frac*tempb13 + frac*tempb10
    fracb = norg_ice*tempb13 + norg_ice*tempb10
    dx2b = (norg_ice*frac-norg)*tempb11 - aux*tempb14
    tempb16 = pi_ice*0.06d0*auxb/(0.76d0*9.1d-7)
    CALL POPREAL8(frac)
    result2b = -(0.5d0*fracb)
    arg10b = 0.0_8
    CALL ERFAPP_B(arg10, arg10b, result2b)
    dorg_iceb = dorg_iceb + 2*dorg_ice*dx2b - arg10b/(dorg_ice*&
&     sigorg_ice*result1)
    CALL POPREAL8(arg10)
    CALL POPREAL8(result1)
    tempb15 = aux2*(nbc_ice*frac-nbc)*dx2*dnbcb
    dhb = nbase*tempb15 + nbase*tempb12
    dnbaseb = hbc*tempb15 + hbc*tempb12
    aux = (1d0/3d0-0.06d0)*hbc*(nbase/0.76d0)*pi_ice/2.7d-7
    tempb19 = (1d0-EXP(-(aux*dx2)))*nbcb
    nbc_iceb = nbc_iceb + frac*tempb19 + frac*tempb9
    fracb = nbc_ice*tempb19 + nbc_ice*tempb9
    tempb20 = -(nbc_ice*frac*EXP(-(aux*dx2))*nbcb)
    dx2b = (nbc_ice*frac-nbc)*tempb18 - aux*tempb20
    auxb = -(dx2*tempb20)
    tempb17 = (1.0/3d0-0.06d0)*pi_ice*auxb/(0.76d0*2.7d-7)
    nbaseb = hbc*tempb16 + hbc*tempb17 + dh*tempb15 + dh*tempb12
    hbcb = nbase*tempb16 + nbase*tempb17 + dnbase*tempb15 + dnbase*&
&     tempb12
    CALL POPREAL8(dx2)
    CALL POPREAL8(frac)
    result2b = -(0.5d0*fracb)
    arg10b = 0.0_8
    CALL ERFAPP_B(arg10, arg10b, result2b)
    dbc_iceb = dbc_iceb + acorr_bc*0.52*3*dbc_ice**2*dx2b - arg10b/(&
&     dbc_ice*sigbc_ice*result1)
    CALL POPREAL8(result1)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      dhb = 0.0_8
      hbcb = 0.0_8
    END IF
    CALL POPREAL8(dh)
    dfcb = (1d0-delw0)*dhb
    delw0b = (1d0-fc)*hbcb - dfc*dhb
    ddelw0b = (1d0-fc)*dhb
    fcb = (1.0_8-delw0)*hbcb - ddelw0*dhb
    CALL POPREAL8(dfc)
    del1bc_iceb = del1bc_iceb + 0.5d0*del0*fcb + 0.5d0*ddel0*dfcb
    ddel0b = 0.5d0*del1bc_ice*dfcb
    CALL POPREAL8(fc)
    del0b = 0.5d0*del1bc_ice*fcb
    arg10 = si0bc_ice + 0.1d0
    CALL POPREAL8(ddel0)
    si_b = 0.0_8
    CALL DCUBICINT_ICE_B(si_, si_b, si0bc_ice, si0bc_iceb, arg10, arg10b&
&                  , 0d0, 1d0, ddel0b)
    si0bc_iceb = si0bc_iceb + arg10b
    arg10 = si0bc_ice + 0.1d0
    CALL POPREAL8(del0)
    CALL CUBICINT_ICE_B(si_, si_b, si0bc_ice, si0bc_iceb, arg10, arg10b&
&                 , 0d0, 1d0, del0b)
    CALL POPREAL8(arg10)
    si0bc_iceb = si0bc_iceb + arg10b
    aux2 = 2d0/3d0*pi_ice/0.76d0/5.0d-7/4d0
    aux = 2d0/3d0*hdust*(nbase/0.76d0)*pi_ice/5.0d-7/4d0
    hdustb = 0.0_8
    dhb = 0.0_8
    auxb = 0.0_8
    DO index=nbindust_ice,1,-1
      dndauxb = dndb
      tempb5 = aux2*ndaux*dx2*dndauxb
      tempb6 = aux2*(dh*nbase+hdust*dnbase)*dndauxb
      dhb = dhb + nbase*tempb5
      nbaseb = nbaseb + dh*tempb5
      hdustb = hdustb + dnbase*tempb5
      dnbaseb = dnbaseb + hdust*tempb5
      ndauxb = dx2*tempb6
      fracb = ndust_ice(index)*ndauxb
      ndust_iceb(index) = ndust_iceb(index) + frac*ndauxb
      ndauxb = ndb - ndauxb
      tempb8 = (1d0-EXP(-(aux*dx2)))*ndauxb
      tempb7 = -(frac*ndust_ice(index)*EXP(-(aux*dx2))*ndauxb)
      dx2b = ndaux*tempb6 - aux*tempb7
      CALL POPREAL8(ndaux)
      fracb = fracb + ndust_ice(index)*tempb8
      ndust_iceb(index) = ndust_iceb(index) + frac*tempb8
      auxb = auxb - dx2*tempb7
      CALL POPREAL8(frac)
      result2b = -(0.5d0*fracb)
      arg10b = 0.0_8
      CALL ERFAPP_B(arg10, arg10b, result2b)
      CALL POPREAL8(arg10)
      ddust_iceb(index) = ddust_iceb(index) + acorr_dust*0.52*3*&
&       ddust_ice(index)**2*dx2b - arg10b/(ddust_ice(index)*sigdust_ice(&
&       index)*result1)
      CALL POPREAL8(result1)
      CALL POPREAL8(dx2)
    END DO
    tempb4 = pi_ice*2d0*auxb/(3d0*0.76d0*5.0d-7*4d0)
    hdustb = hdustb + nbase*tempb4
    nbaseb = nbaseb + hdust*tempb4
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      dfc = 0.5d0*del1dust_ice*ddel0
      fc = 0.5d0*del1dust_ice*del0
      hdustb = 0.0_8
      dhb = 0.0_8
    END IF
    dfcb = (1d0-delw0)*dhb
    delw0b = delw0b + (1d0-fc)*hdustb - dfc*dhb
    ddelw0b = ddelw0b + (1d0-fc)*dhb
    fcb = (1.0_8-delw0)*hdustb - ddelw0*dhb
    del1dust_iceb = del1dust_iceb + 0.5d0*del0*fcb + 0.5d0*ddel0*dfcb
    ddel0b = 0.5d0*del1dust_ice*dfcb
    del0b = 0.5d0*del1dust_ice*fcb
    arg10 = si0dust_ice + 0.1d0
    CALL DCUBICINT_ICE_B(si_, si_b, si0dust_ice, si0dust_iceb, arg10, &
&                  arg10b, 0d0, 1d0, ddel0b)
    si0dust_iceb = si0dust_iceb + arg10b
    arg10 = si0dust_ice + 0.1d0
    CALL CUBICINT_ICE_B(si_, si_b, si0dust_ice, si0dust_iceb, arg10, &
&                 arg10b, 0d0, 1d0, del0b)
    si0dust_iceb = si0dust_iceb + arg10b
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      nbaseb = nbaseb + 3.88d0*dnbaseb
    ELSE
      nbaseb = nbaseb + 12.96d0*dnbaseb
    END IF
    CALL PDG07_ICE_B(si, sib, t, nbaseb)
    swb = 0.0_8
    sw0b = 0.0_8
    CALL DCUBICINT_ICE_B(sw, swb, sw0, sw0b, 1d0, dummydiffb0, 0d0, 1d0&
&                  , ddelw0b)
    sw0b = 0.0_8
    CALL CUBICINT_ICE_B(sw, swb, sw0, sw0b, 1d0, dummydiffb, 0d0, 1d0, &
&                 delw0b)
    siwb = 0.0_8
 110 vpresw_iceb = vpresw_iceb + siwb/vpresi_ice
    vpresi_iceb = vpresi_iceb - vpresw_ice*siwb/vpresi_ice**2
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      si_b = si_b + sib
      vpresw_iceb = vpresw_iceb + si_b/vpresi_ice
      vpresi_iceb = vpresi_iceb - vpresw_ice*si_b/vpresi_ice**2
      si = six
      si_ = si + 1d0
      si_b = 0.0_8
      sib = 0.0_8
      swb = 0.0_8
    END IF
    tempb = swb/vpresw_ice
    si_b = si_b + vpresi_ice*tempb
    vpresi_iceb = vpresi_iceb + si_*tempb
    vpresw_iceb = vpresw_iceb - si_*vpresi_ice*tempb/vpresw_ice
    sib = sib + si_b
    sixb = sixb + sib
  END SUBROUTINE INSPEC_ICE_B
!*************************************************************
! Subroutine INSPEC_ice
!  Provides the Ice Nuclei concentration (m-3) 
! and the chracteristic freezing threeshold, DSh (Barahona & Nenes 2009), at given 
! si and T. The variable typeofspec_ice (integer) has the values
! 1 Meyers et. al. 1992
! 2  Phillips et. al. 2007
! 3  Barahona & Nenes 2009
! 4  Phillips et. al. 2008 
! 5  Barahona,        2012 
! si is supersaturation wrt ice and T is in K 
!      Written by Donifan Barahona 
!      donifan.o.barahona@nasa.gov
!************************************************************  
  SUBROUTINE INSPEC_ICE(six, t, n, dsh)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: six, t
    REAL*8, INTENT(OUT) :: n, dsh
    REAL*8 :: nd, nbc, aux, si_, sw, del0, ddel0, fc, delw0, ddelw0, sw0&
&   , hdust, hbc, nbase, dnd, dnbc, dnbase, dh, dfc, ndaux, dndaux, &
&   dnorg, norg, ndustaux, frac, aux2, dx2, fdep, ndep, ndhf, dndep, &
&   dndhf, si, dfrac, siw
!variables for DM11
    REAL*8 :: a, b, c, d, nbig, nbigexp, other
    REAL*8, DIMENSION(3) :: sig_array, the_array, frac_array
    REAL*8 :: n_iw, dsh_s, asolo
    REAL*8, DIMENSION(1) :: nbc_s, dbc_s, d_grid_bio, n_grid_bio
    REAL*8, DIMENSION(nbindust_ice) :: ndust_s, ddust_s
    INTEGER :: index, kindex, mode
    INTRINSIC EXP
    INTRINSIC LOG
    INTRINSIC SQRT
    INTRINSIC MIN
    INTRINSIC MAX
    REAL*8 :: arg1
    DOUBLE PRECISION :: result1
    REAL*8 :: result2
    REAL*8 :: pwx1
    REAL*8 :: pwr1
    REAL*8 :: x2
    REAL*8 :: x1
    REAL*8 :: arg10
    si = six
    si_ = si + 1d0
!new2
    sw = si_*vpresi_ice/vpresw_ice
    IF (sw .GE. 1.0) THEN
!limit to subsaturated conditions
      sw = 1.0
      si_ = vpresw_ice/vpresi_ice
      si = si_ - 1.0
    END IF
    siw = vpresw_ice/vpresi_ice
    sig_array = 0.0
    the_array = 0.0
    frac_array = 0.0
    fdep = 0.0
    SELECT CASE  (typeofspec_ice) 
    CASE (1) 
!Phillips2007
      n = PDG07_ICE(si, t)
      IF (t .LE. 243d0) THEN
        dsh = 1d0/3.88d0
      ELSE
        dsh = 1d0/12.96d0
      END IF
    CASE (2) 
!Meyers1992 
      n = 1000d0*EXP(-0.639d0)*(EXP(12.96d0*si)-1d0)
      dsh = 1d0/12.96d0
    CASE (3) 
!Barahona&Nenes CNT
!dust contribution
      ndustaux = 0.0d0
      DO index=1,nbindust_ice
        ndustaux = ndustaux + ndust_ice(index)
      END DO
      IF (si .LE. shdust_ice) THEN
        arg1 = -(kdust_ice*(shdust_ice-si))
        nd = si/shdust_ice*ndustaux*effdust_ice*EXP(arg1)
        dnd = nd*(1d0/si+kdust_ice)
      ELSE
        nd = ndustaux*effdust_ice
        dnd = 0d0
      END IF
!soot contribution
      IF (si .LE. shbc_ice) THEN
        arg1 = -(kbc_ice*(shbc_ice-si))
        nbc = si/shbc_ice*nbc_ice*effbc_ice*EXP(arg1)
        dnbc = nbc*(1d0/si+kbc_ice)
      ELSE
        nbc = nbc_ice*effbc_ice
        dnbc = 0d0
      END IF
      n = nd + nbc
      IF (dnd + dnbc .GT. 0d0) THEN
        dsh = n/(dnd+dnbc)
      ELSE
        dsh = si
      END IF
    CASE (4) 
!PDA2008. Allows multiple lognormal modes for dust. Single mode lognormal distributions are assumed for bc and organics
! Dust
      sw0 = 0.97d0
      delw0 = CUBICINT_ICE(sw, sw0, 1d0, 0d0, 1d0)
      ddelw0 = DCUBICINT_ICE(sw, sw0, 1d0, 0d0, 1d0)
      nbase = PDG07_ICE(si, t)
      IF (t .LE. 243d0) THEN
        dnbase = 3.88d0*nbase
      ELSE
        dnbase = 12.96d0*nbase
      END IF
!dust contribution
      arg10 = si0dust_ice + 0.1d0
      del0 = CUBICINT_ICE(si_, si0dust_ice, arg10, 0d0, 1d0)
      arg10 = si0dust_ice + 0.1d0
      ddel0 = DCUBICINT_ICE(si_, si0dust_ice, arg10, 0d0, 1d0)
      fc = 0.5d0*del1dust_ice*del0
      dfc = 0.5d0*del1dust_ice*ddel0
      hdust = fc + (1d0-fc)*delw0
      dh = dfc*(1d0-delw0) + ddelw0*(1d0-fc)
      IF (hdust .GT. 1d0) THEN
        hdust = 1d0
        dh = 0d0
      END IF
      aux = 2d0/3d0*hdust*(nbase/0.76d0)*pi_ice/5.0d-7/4d0
!The last 4d0 was introduced as recommnedation of V Phillips
      aux2 = 2d0/3d0*pi_ice/0.76d0/5.0d-7/4d0
      nd = 0d0
      dnd = 0d0
      DO index=1,nbindust_ice
!Dx2= ddust_ice(index)*ddust_ice(index)
!new 07/10/12
        dx2 = ddust_ice(index)*ddust_ice(index)*ddust_ice(index)*0.52*&
&         acorr_dust
!fraction above 0.1 microns
!sigma_dust=log(sigma_bc_g)
        result1 = SQRT(2d0)
        arg10 = -(LOG(ddust_ice(index)/0.1e-6)/sigdust_ice(index)/&
&         result1)
        result2 = ERFAPP(arg10)
        frac = 0.5d0*(1d0-result2)
        ndaux = frac*ndust_ice(index)*(1d0-EXP(-(aux*dx2)))
        nd = nd + ndaux
        ndaux = frac*ndust_ice(index) - ndaux
        dndaux = ndaux*(dh*nbase+hdust*dnbase)*aux2*dx2
        dnd = dnd + dndaux
      END DO
!soot contribution
      arg10 = si0bc_ice + 0.1d0
      del0 = CUBICINT_ICE(si_, si0bc_ice, arg10, 0d0, 1d0)
      arg10 = si0bc_ice + 0.1d0
      ddel0 = DCUBICINT_ICE(si_, si0bc_ice, arg10, 0d0, 1d0)
      fc = 0.5d0*del1bc_ice*del0
      hbc = fc + (1d0-fc)*delw0
      dfc = 0.5d0*del1bc_ice*ddel0
      dh = dfc*(1d0-delw0) + ddelw0*(1d0-fc)
      IF (hbc .GT. 1d0) THEN
        hbc = 1d0
        dh = 0d0
      END IF
!sigbc=log(sigma_bc_g)
      result1 = SQRT(2d0)
      arg10 = -(LOG(dbc_ice/0.1e-6)/sigbc_ice/result1)
      result2 = ERFAPP(arg10)
      frac = 0.5d0*(1d0-result2)
!Dx2=dbc_ice*dbc_ice	       
!new 07/10/12
      dx2 = dbc_ice*dbc_ice*dbc_ice*0.52*acorr_bc
      aux = (1d0/3d0-0.06d0)*hbc*(nbase/0.76d0)*pi_ice/2.7d-7
      aux2 = (1d0/3d0-0.06d0)*pi_ice/0.76d0/2.7d-7
      nbc = nbc_ice*frac*(1d0-EXP(-(aux*dx2)))
      dnbc = (nbc_ice*frac-nbc)*(dh*nbase+hbc*dnbase)*aux2*dx2
!Organics contribution
!sigorg=log(sigma_org_g)
      result1 = SQRT(2d0)
      arg10 = -(LOG(dorg_ice/0.1e-6)/sigorg_ice/result1)
      result2 = ERFAPP(arg10)
      frac = 0.5d0*(1d0-result2)
      dx2 = dorg_ice*dorg_ice
      aux = 0.06d0*hbc*(nbase/0.76d0)*pi_ice/9.1d-7
      aux2 = 0.06d0*pi_ice/0.76d0/9.1d-7
      norg = norg_ice*frac*(1d0-EXP(-(aux*dx2)))
      dnorg = (norg_ice*frac-norg)*(dh*nbase+hbc*dnbase)*aux2*dx2
      n = nd + nbc + norg
      IF (dnd + dnbc + dnorg .GT. 0d0) THEN
        dsh = n/(dnd+dnbc+dnorg)
      ELSE
        dsh = si
      END IF
    CASE (5) 
!Phillips et al 2013.
      d_grid_bio(1) = dbio_ice
      n_grid_bio(1) = nbio_ice
!dust
      DO index=1,nbindust_ice
!fraction above 0.1 microns
        result1 = SQRT(2d0)
        arg10 = LOG(0.1e-6/ddust_ice(index))/sigdust_ice(index)/result1
        result2 = ERFAPP(arg10)
        frac = 0.5d0*(1d0-result2)
        ndust_s(index) = frac*ndust_ice(index)
        ddust_s = ddust_ice(index)
      END DO
!black carbon
!fraction above 0.1 microns
      result1 = SQRT(2d0)
      arg10 = LOG(0.1e-6/dbc_ice)/sigbc_ice/result1
      result2 = ERFAPP(arg10)
      frac = 0.5d0*(1d0-result2)
      nbc_s(1) = frac*nbc_ice
      IF (dbc_ice .GT. 2.e-6) THEN
        dbc_ice = 2.e-6
      ELSE
        dbc_ice = dbc_ice
      END IF
      dbc_s(1) = dbc_ice*1.0
!Soluble organics (spherical)
!sigorg=log(sigma_org_g) !20-30% of organics are soluble (Saxena and HIdeelman 1996). 
      result1 = SQRT(2d0)
      arg10 = LOG(0.1e-6/dorg_ice)/sigorg_ice/result1
      result2 = ERFAPP(arg10)
      frac = 0.25d0*0.5d0*(1d0-result2)
!
      asolo = frac*norg_ice*3.1415*dorg_ice*dorg_ice
      CALL EMPIRICAL_PARAM_PHILLIPS(t, pice, si_, siw, sw, ddust_s, &
&                             ndust_s, 2, dbc_s, nbc_s, 1, d_grid_bio, &
&                             n_grid_bio, 1, asolo, n_iw, dsh_s)
      n = n_iw
      dsh = dsh_s
    CASE (6) 
!Barahona 2012. Spectrum based on NPDF-Theory and CNT (Unpublished)
!dust contribution*******************************************
!linear approx to decide DHF vs deposition, loosely based on Seisel 2005.
      fdep = (1.0-sw)/0.1
      IF (fdep .LT. 0.0) THEN
        x1 = 0.0
      ELSE
        x1 = fdep
      END IF
      IF (x1 .GT. 1.0) THEN
        fdep = 1.0
      ELSE
        fdep = x1
      END IF
      nd = 0.0
      dnd = 0.0
!Deposition *******
!deposition             
      mode = 1
      sig_array(1) = 21.4
      sig_array(2) = 21.4
      sig_array(3) = 21.4
      the_array(1) = 9.9
      the_array(2) = 15.1
      the_array(3) = 19.8
      frac_array(1) = 0.20
      frac_array(2) = 0.25
      frac_array(3) = 0.55
      dgh_ice = 0.0
      ndep = 0.0
      dndep = 0.0
      DO index=1,nbindust_ice
!new 07/10/12    
        dx2 = ddust_ice(index)*ddust_ice(index)*ddust_ice(index)*0.52*&
&         acorr_dust
!Dx2= ddust_ice(index)*ddust_ice(index)*pi_ice*4.0 !Assume spheres by now
        CALL NUC_FRAC(frac, dfrac, sig_array, the_array, frac_array, t, &
&               si_, mode, dx2, adust_dep, 3)
        ndaux = frac*ndust_ice(index)*fdep
        ndep = ndep + ndaux
        dndaux = dfrac*ndust_ice(index)*fdep
        dndep = dndep + dndaux
      END DO
!immersion *******
      mode = 3
!sig_array=(/ 10.0, 10.0, 10.0 /)
!the_array=(/ 85.0, 85.0, 85.0 /)
!frac_array=(/ 1.0, 0.0, 0.0 /)      
      sig_array(1) = 1.014
      sig_array(2) = 1.014
      sig_array(3) = 1.014
      the_array(1) = 53.44
      the_array(2) = 53.44
      the_array(3) = 53.44
      frac_array(1) = 1.0
      frac_array(2) = 0.0
      frac_array(3) = 0.0
      dgh_ice = 0.5
      ndhf = 0.0
      dndhf = 0.0
      DO index=1,nbindust_ice
!new 07/10/12
        dx2 = ddust_ice(index)*ddust_ice(index)*ddust_ice(index)*0.52*&
&         acorr_dust
!Dx2= ddust_ice(index)*ddust_ice(index)*pi_ice*4.0 !Assume spheres by now
        CALL NUC_FRAC(frac, dfrac, sig_array, the_array, frac_array, t, &
&               si_, mode, dx2, aimm, 1)
        ndaux = frac*ndust_ice(index)*(1.0-fdep)
        ndhf = ndhf + ndaux
        dndaux = dfrac*ndust_ice(index)*(1.0-fdep)
        dndhf = dndhf + dndaux
      END DO
      nd = ndep + ndhf
      dnd = dndep + dndhf
!soot contribution*****************************************
!linear approx to decide DHF vs deposition, loosely based on Seisel 2005.
      fdep = (1.0-sw)/0.1
      IF (fdep .LT. 0.0) THEN
        x2 = 0.0
      ELSE
        x2 = fdep
      END IF
      IF (x2 .GT. 1.0) THEN
        fdep = 1.0
      ELSE
        fdep = x2
      END IF
      nbc = 0.0
      dnbc = 0.0
!deposition***
      mode = 1
      sig_array(1) = 28.3
      sig_array(2) = 28.3
      sig_array(3) = 28.3
      the_array(1) = 34.2
      the_array(2) = 34.2
      the_array(3) = 34.2
      frac_array(1) = 1.0
      frac_array(2) = 0.0
      frac_array(3) = 0.0
      dgh_ice = 0.0
!new 07/10/12
      dx2 = dbc_ice*dbc_ice*dbc_ice*0.52*acorr_bc
!Dx2=100.0e-12  !Popovicheva 2006. Not safe assuming spheres      
      CALL NUC_FRAC(frac, dfrac, sig_array, the_array, frac_array, t, &
&             si_, mode, dx2, abc_dep, 1)
      ndep = frac*nbc_ice*fdep
      dndep = dfrac*nbc_ice*fdep
!Immersion***	 
      mode = 3
!sig_array=(/ 3.0, 3.0, 3.0 /)
!the_array=(/ 153.8, 153.8, 153.8/) !Barahona, in prep
      sig_array(1) = 2.7988
      sig_array(2) = 2.7
      sig_array(3) = 2.7
      the_array(1) = 49.1769
      the_array(2) = 49.1769
      the_array(3) = 49.0
      frac_array(1) = 1.0
      frac_array(2) = 0.0
      frac_array(3) = 0.0
      dgh_ice = 6.45
      CALL NUC_FRAC(frac, dfrac, sig_array, the_array, frac_array, t, &
&             si_, mode, dx2, aimm, 1)
      ndhf = frac*nbc_ice*(1.0-fdep)
      dndhf = dfrac*nbc_ice*(1.0-fdep)
      nbc = ndep + ndhf
      dnbc = dndep + dndhf
!Total   	 
      n = nd + nbc
      IF (dnd + dnbc .GT. 0d0) THEN
        dsh = n/(dnd+dnbc)
      ELSE
        dsh = si
      END IF
    CASE (7) 
!DeMott 2011
      frac = 0.0d0
      nd = 0.0d0
      nbc = 0.0d0
      norg = 0.0d0
      nbig = 0.0d0
      a = 0.0000594d0
      b = 3.33d0
      c = 0.0264d0
      d = 0.0033d0
!dust number with D > 0.5 um
      DO index=1,nbindust_ice
!fraction above 0.5 microns
        result1 = SQRT(2d0)
        arg10 = -(LOG(ddust_ice(index)/0.5d-6)/sigdust_ice(index)/&
&         result1)
        result2 = ERFAPP(arg10)
        frac = 0.5d0*(1d0-result2)
        nd = nd + frac*ndust_ice(index)
      END DO
!BC number with D > 0.5 um
!sigbc=log(sigma_bc_g)
      result1 = SQRT(2d0)
      arg10 = -(LOG(dbc_ice/0.5d-6)/sigbc_ice/result1)
      result2 = ERFAPP(arg10)
      frac = 0.5d0*(1d0-result2)
      nbc = frac*nbc_ice
!org number with D > 0.5 um
!sigorg=log(sigma_org_g)
      result1 = SQRT(2d0)
      arg10 = -(LOG(dorg_ice/0.5d-6)/sigorg_ice/result1)
      result2 = ERFAPP(arg10)
      frac = 0.5d0*(1d0-result2)
      norg = frac*norg_ice
      nbig = nd + nbc + norg
!nbig must be in cc-1
      nbig = nbig/10d6
      nbigexp = c*(273.16d0-t) + d
      pwx1 = 273.16d0 - t
      pwr1 = pwx1**b
      n = a*pwr1
      other = nbig**nbigexp
      n = n*other
!N should be output in m-3
      n = n*1000d0
      dsh = si
    CASE DEFAULT
      n = 0d0
      dsh = si
    END SELECT
    IF (dsh .GE. si) dsh = si
  END SUBROUTINE INSPEC_ICE
!  Differentiation of cubicint_ice in reverse (adjoint) mode:
!   gradient     of useful results: y1 y cubicint_ice
!   with respect to varying inputs: y1 y2 y
!*************************************************************
!   Function cubicint_ice (cubic interpolation between y1 and y2 within a and b).  
!************************************************************  
  SUBROUTINE CUBICINT_ICE_B(y, yb, y1, y1b, y2, y2b, a, b, cubicint_iceb&
& )
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: y, y1, y2, a, b
    REAL*8 :: yb, y1b, y2b
    REAL*8 :: a_, b_, a0, a1, a2, a3, d, aux
    REAL*8 :: a_b, b_b, a0b, a1b, a2b, a3b, db, auxb
    INTEGER :: branch
    REAL*8 :: cubicint_iceb
    REAL*8 :: cubicint_ice
    REAL*8 :: tempb0
    REAL*8 :: tempb
    REAL*8 :: temp
    IF (y .LE. y1) THEN
      CALL PUSHCONTROL2B(0)
    ELSE IF (y .GE. y2) THEN
      CALL PUSHCONTROL2B(1)
    ELSE
      aux = y2 - y1
      a_ = 6d0*(a-b)/(aux*aux*aux)
      a1 = a_*y1*y2
      a2 = -(a_*(y1+y2)*0.5d0)
      a3 = a_/3d0
      CALL PUSHCONTROL2B(2)
    END IF
    db = cubicint_iceb
    CALL POPCONTROL2B(branch)
    IF (branch .EQ. 0) THEN
      y2b = 0.0_8
    ELSE IF (branch .EQ. 1) THEN
      y2b = 0.0_8
    ELSE
      a0b = db
      a1b = y*db
      yb = yb + (a3*3*y**2+a2*2*y+a1)*db
      a2b = y**2*db
      a3b = y**3*db
      tempb0 = -(0.5d0*a_*a2b)
      b_b = a0b
      tempb = -(0.5d0*y1**2*b_b)
      a_b = y1**3*b_b/6d0 - 0.5d0*(y1+y2)*a2b + y2*tempb + y2*y1*a1b + &
&       a3b/3d0
      temp = aux**3
      auxb = -((a-b)*6d0*3*aux**2*a_b/temp**2)
      y1b = y1b + y2*a_*a1b - auxb + (a_*3*y1**2/6d0-a_*y2*0.5d0*2*y1)*&
&       b_b + tempb0
      y2b = a_*y1*a1b + auxb + a_*tempb + tempb0
    END IF
  END SUBROUTINE CUBICINT_ICE_B
!*************************************************************
!   Function cubicint_ice (cubic interpolation between y1 and y2 within a and b).  
!************************************************************  
  REAL*8 FUNCTION CUBICINT_ICE(y, y1, y2, a, b)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: y, y1, y2, a, b
    REAL*8 :: a_, b_, a0, a1, a2, a3, d, aux
    IF (y .LE. y1) THEN
      d = a
    ELSE IF (y .GE. y2) THEN
      d = b
    ELSE
      aux = y2 - y1
      a_ = 6d0*(a-b)/(aux*aux*aux)
      b_ = a + a_*(y1*y1*y1)/6d0 - a_*(y1*y1)*y2*0.5d0
      a0 = b_
      a1 = a_*y1*y2
      a2 = -(a_*(y1+y2)*0.5d0)
      a3 = a_/3d0
      d = a0 + a1*y + a2*y*y + a3*y*y*y
    END IF
    cubicint_ice = d
  END FUNCTION CUBICINT_ICE
!  Differentiation of dcubicint_ice in reverse (adjoint) mode:
!   gradient     of useful results: y1 y dcubicint_ice
!   with respect to varying inputs: y1 y2 y
!*************************************************************
!   Function dcubicint_ice (used in the PDA08 spectrum).  
!************************************************************  
  SUBROUTINE DCUBICINT_ICE_B(y, yb, y1, y1b, y2, y2b, a, b, &
&   dcubicint_iceb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: y, y1, y2, a, b
    REAL*8 :: yb, y1b, y2b
    REAL*8 :: a_, a0, a1, a2, a3, d, aux
    REAL*8 :: a_b, a1b, a2b, a3b, db, auxb
    INTEGER :: branch
    REAL*8 :: dcubicint_ice
    REAL*8 :: dcubicint_iceb
    REAL*8 :: tempb
    REAL*8 :: temp
    IF (y .LE. y1) THEN
      CALL PUSHCONTROL2B(0)
    ELSE IF (y .GE. y2) THEN
      CALL PUSHCONTROL2B(1)
    ELSE
      aux = y2 - y1
      a_ = 6d0*(a-b)/(aux*aux*aux)
      a2 = -(a_*(y1+y2)*0.5d0)
      a3 = a_/3d0
      CALL PUSHCONTROL2B(2)
    END IF
    db = dcubicint_iceb
    CALL POPCONTROL2B(branch)
    IF (branch .EQ. 0) THEN
      y2b = 0.0_8
    ELSE IF (branch .EQ. 1) THEN
      y2b = 0.0_8
    ELSE
      a1b = db
      a2b = 2d0*y*db
      yb = yb + (a3*3d0*2*y+2d0*a2)*db
      a3b = 3d0*y**2*db
      a_b = y2*y1*a1b - 0.5d0*(y1+y2)*a2b + a3b/3d0
      tempb = -(0.5d0*a_*a2b)
      temp = aux**3
      auxb = -((a-b)*6d0*3*aux**2*a_b/temp**2)
      y1b = y1b + y2*a_*a1b - auxb + tempb
      y2b = a_*y1*a1b + auxb + tempb
    END IF
  END SUBROUTINE DCUBICINT_ICE_B
!*************************************************************
!   Function dcubicint_ice (used in the PDA08 spectrum).  
!************************************************************  
  REAL*8 FUNCTION DCUBICINT_ICE(y, y1, y2, a, b)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: y, y1, y2, a, b
    REAL*8 :: a_, a0, a1, a2, a3, d, aux
    IF (y .LE. y1) THEN
      d = 0
    ELSE IF (y .GE. y2) THEN
      d = 0
    ELSE
      aux = y2 - y1
      a_ = 6d0*(a-b)/(aux*aux*aux)
      a1 = a_*y1*y2
      a2 = -(a_*(y1+y2)*0.5d0)
      a3 = a_/3d0
      d = a1 + 2d0*a2*y + 3d0*a3*y*y
    END IF
    dcubicint_ice = d
  END FUNCTION DCUBICINT_ICE
!  Differentiation of pdg07_ice in reverse (adjoint) mode:
!   gradient     of useful results: si pdg07_ice
!   with respect to varying inputs: si
!*************************************************************
! Function PDG07 (simplified ice nucleation 
!                     spectra according to Phillips et. al. 2007).  
! si is supersaturation wrt ice and T is in K 
!************************************************************  
  SUBROUTINE PDG07_ICE_B(si, sib, t, pdg07_iceb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: si, t
    REAL*8 :: sib
    REAL*8 :: n
    REAL*8 :: nb
    INTRINSIC EXP
    INTEGER :: branch
    REAL*8 :: pdg07_ice
    REAL*8 :: pdg07_iceb
    IF (t .LE. 243d0) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    nb = pdg07_iceb
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      sib = sib + EXP(3.88d0*si)*EXP(-0.388d0)*1000d0*3.88d0*nb
    ELSE
      sib = sib + EXP(12.96d0*si)*EXP(-0.639d0)*60d0*12.96d0*nb
    END IF
  END SUBROUTINE PDG07_ICE_B
!*************************************************************
! Function PDG07 (simplified ice nucleation 
!                     spectra according to Phillips et. al. 2007).  
! si is supersaturation wrt ice and T is in K 
!************************************************************  
  REAL*8 FUNCTION PDG07_ICE(si, t)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: si, t
    REAL*8 :: n
    INTRINSIC EXP
    IF (t .LE. 243d0) THEN
      n = 1000d0*EXP(-0.388d0)*(EXP(3.88d0*si)-1d0)
    ELSE
      n = 60d0*EXP(-0.639d0)*(EXP(12.96d0*si)-1d0)
    END IF
    pdg07_ice = n
  END FUNCTION PDG07_ICE
!
!*************************************************************
! Subroutine INimmersion
!  Provides the Immersion IN concentration at given T(K) according to Barahona et al. 2012 (in prep)
! fdust_coa== fraction of dust that is coated with soluble material
! fdrop dust === fraction  of dust in the droplets
! fdrop bc === fraction  of  black carbon in the droplets
!      Written by Donifan Barahona 
!      donifan.o.barahona@nasa.gov
!========================================
  SUBROUTINE INIMMERSION(inconc, t)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: t
    REAL*8, INTENT(OUT) :: inconc
    REAL*8 :: nd, nd_unc, nd_coa, nbc, ahet, frac, dfrac, naux
    REAL*8, DIMENSION(3) :: sig_array, the_array, frac_array
    INTEGER :: index, kindex, mode
    REAL*8 :: arg1
!Immersion in activated droplets
    mode = 2
!dust contribution*******************************************
    nd = 0.0
!uncoated************
    nd_unc = 0.0
!sig_array=(/ 6.0, 6.0, 6.0 /)
!the_array=(/ 112.2, 84.2, 178.0 /)
!frac_array=(/ 0.88, 0.12, 0.0 /)          
    sig_array(1) = 1.014
    sig_array(2) = 1.014
    sig_array(3) = 1.014
    the_array(1) = 53.44
    the_array(2) = 178.0
    the_array(3) = 178.0
    frac_array(1) = 1.0
    frac_array(2) = 0.0
    frac_array(3) = 0.0
    dgh_ice = 0.31
    naux = 0.0
    DO index=1,nbindust_ice
!ahet= ddust_ice(index)*ddust_ice(index)*pi_ice*4.0 !Assume spheres by now
!Assume spheres by now	  
      ahet = ddust_ice(index)*ddust_ice(index)*ddust_ice(index)*0.52*&
&       acorr_dust
      arg1 = vpresw_ice/vpresi_ice
      CALL NUC_FRAC(frac, dfrac, sig_array, the_array, frac_array, t, &
&             arg1, mode, ahet, aimm, 2)
      naux = frac*ndust_ice(index) + naux
    END DO
    nd_unc = naux*(1.-fcoa_dust)
!coated***************
    naux = 0.0
!sig_array=(/ 3.0, 3.0, 3.0 /)
!the_array=(/ 176.0, 89.3, 179.0 /)
!frac_array=(/ 0.8, 0.2, 0.0 /)          
    sig_array(1) = 1.014
    sig_array(2) = 1.014
    sig_array(3) = 1.014
    the_array(1) = 53.44
    the_array(2) = 90.0
    the_array(3) = 178.0
    frac_array(1) = 0.2
    frac_array(2) = 0.8
    frac_array(3) = 0.0
    dgh_ice = 0.31
    naux = 0.0
    DO index=1,nbindust_ice
!Assume spheres by now
      ahet = ddust_ice(index)*ddust_ice(index)*ddust_ice(index)*0.52*&
&       acorr_dust
!ahet= ddust_ice(index)*ddust_ice(index)*pi_ice*4.0 !Assume spheres by now
      arg1 = vpresw_ice/vpresi_ice
      CALL NUC_FRAC(frac, dfrac, sig_array, the_array, frac_array, t, &
&             arg1, mode, ahet, aimm, 2)
      naux = frac*ndust_ice(index) + naux
    END DO
    nd_coa = naux*fcoa_dust
    nd = (nd_unc+nd_coa)*fdrop_dust
!soot contribution*******************************************
    nbc = 0.0
!asusme all coated
!sig_array=(/ 3.0, 3.0, 3.0 /)
!the_array=(/ 153.75, 178.0, 178.0/)
!frac_array=(/ 1.0, 0.0, 0.0 /)          
    sig_array(1) = 2.7988
    sig_array(2) = 2.7
    sig_array(3) = 2.7
    the_array(1) = 49.1769
    the_array(2) = 49.1769
    the_array(3) = 49.0
    frac_array(1) = 1.0
    frac_array(2) = 0.0
    frac_array(3) = 0.0
    dgh_ice = 0.484
    ahet = 100.0e-12
    arg1 = vpresw_ice/vpresi_ice
    CALL NUC_FRAC(frac, dfrac, sig_array, the_array, frac_array, t, arg1&
&           , mode, ahet, aimm, 2)
    nbc = nbc_ice*frac*fdrop_bc
!Total =====================
    inconc = nbc + nd
  END SUBROUTINE INIMMERSION
!  Differentiation of nuc_frac in reverse (adjoint) mode:
!   gradient     of useful results: dtnuc_dhf waux_ice dtnuc_dep
!                aimm dact_imm lmeff_ice vw_ice denice_ice vpresw_ice
!                vpresi_ice t ahet dfrac frac si_ a
!   with respect to varying inputs: dtnuc_dhf waux_ice dtnuc_dep
!                aimm dact_imm lmeff_ice vw_ice denice_ice vpresw_ice
!                vpresi_ice t ahet si_ a
!*************************************************************
! Subroutine nucfrac
! Calculates the ice nucleation fraction according to Barahona et al . 2012 (in prep) 
!************************************************************  
  SUBROUTINE NUC_FRAC_B(frac, fracb, dfrac, dfracb, sig_array, the_array&
&   , frac_array, t, tb, si_, si_b, mode, ahet, ahetb, a, ab, nlogmodes)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: si_, ahet, a, t
    REAL*8 :: si_b, ahetb, ab, tb
    REAL*8, DIMENSION(:) :: the_array, frac_array, sig_array
    INTEGER, INTENT(IN) :: nlogmodes, mode
    REAL*8 :: frac, dfrac
    REAL*8 :: fracb, dfracb
    REAL*8 :: phi, j, dtnuc, fder, aux
    REAL*8 :: phib, jb, dtnucb, fderb, auxb
    INTEGER :: kindex
    INTRINSIC LOG
    INTRINSIC SQRT
    INTRINSIC EXP
    REAL*8 :: result1
    REAL*8 :: result1b
    REAL*8 :: arg1
    REAL*8 :: arg1b
    INTEGER :: branch
    DO kindex=1,nlogmodes
      CALL PUSHREAL8(fder)
      CALL PUSHREAL8(dtnuc)
      CALL PUSHREAL8(j)
      CALL JHET(j, dtnuc, fder, si_, t, the_array(kindex), mode, a)
      phi = dtnuc*j*ahet
      IF (phi .GT. 0.0) THEN
        CALL PUSHREAL8(result1)
        result1 = SQRT(pi_ice)
        CALL PUSHREAL8(aux)
        aux = LOG(phi)/sig_array(kindex)/result1
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    fracb = -fracb
    DO kindex=nlogmodes,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        dfracb = 0.0_8
        fracb = 0.0_8
        fderb = 0.0_8
        phib = 0.0_8
      ELSE
        arg1 = -(aux**2)
        arg1b = fder*frac_array(kindex)*EXP(arg1)*dfracb/(sig_array(&
&         kindex)*pi_ice)
        fderb = EXP(arg1)*frac_array(kindex)*dfracb/(sig_array(kindex)*&
&         pi_ice)
        auxb = -(2*aux*arg1b)
        result1b = -(0.5*frac_array(kindex)*fracb)
        CALL ERFAPP_B(aux, auxb, result1b)
        phi = dtnuc*j*ahet
        CALL POPREAL8(aux)
        phib = auxb/(sig_array(kindex)*result1*phi)
        CALL POPREAL8(result1)
      END IF
      dtnucb = ahet*j*phib
      jb = ahet*dtnuc*phib
      ahetb = ahetb + dtnuc*j*phib
      CALL POPREAL8(j)
      CALL POPREAL8(dtnuc)
      CALL POPREAL8(fder)
      CALL JHET_B(j, jb, dtnuc, dtnucb, fder, fderb, si_, si_b, t, tb, &
&           the_array(kindex), mode, a, ab)
    END DO
  END SUBROUTINE NUC_FRAC_B
!*************************************************************
! Subroutine nucfrac
! Calculates the ice nucleation fraction according to Barahona et al . 2012 (in prep) 
!************************************************************  
  SUBROUTINE NUC_FRAC(frac, dfrac, sig_array, the_array, frac_array, t, &
&   si_, mode, ahet, a, nlogmodes)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: si_, ahet, a, t
    REAL*8, DIMENSION(:) :: the_array, frac_array, sig_array
    INTEGER, INTENT(IN) :: nlogmodes, mode
    REAL*8, INTENT(OUT) :: frac, dfrac
    REAL*8 :: phi, j, dtnuc, fder, aux
    INTEGER :: kindex
    INTRINSIC LOG
    INTRINSIC SQRT
    INTRINSIC EXP
    REAL*8 :: result1
    REAL*8 :: arg1
    frac = 0.0
    dfrac = 0.0
    DO kindex=1,nlogmodes
      CALL JHET(j, dtnuc, fder, si_, t, the_array(kindex), mode, a)
      phi = dtnuc*j*ahet
      IF (phi .GT. 0.0) THEN
        result1 = SQRT(pi_ice)
        aux = LOG(phi)/sig_array(kindex)/result1
        result1 = ERFAPP(aux)
        frac = 0.5*(1.0-result1)*frac_array(kindex) + frac
        arg1 = -(aux**2)
        dfrac = frac_array(kindex)*EXP(arg1)*fder/sig_array(kindex)/&
&         pi_ice + dfrac
      ELSE
        frac = 1.0
        dfrac = 0.0
      END IF
    END DO
    frac = 1.0 - frac
  END SUBROUTINE NUC_FRAC
!  Differentiation of erfapp in reverse (adjoint) mode:
!   gradient     of useful results: x erfapp
!   with respect to varying inputs: x
!*************************************************************     
!Approximation to the error function
!*************************************************************
  SUBROUTINE ERFAPP_B(x, xb, erfappb)
    IMPLICIT NONE
!bug removed 08/03/2011
    REAL*8, INTENT(IN) :: x
    REAL*8 :: xb
    REAL*8 :: a
    REAL*8 :: ab
    INTRINSIC EXP
    INTRINSIC SQRT
    REAL*8 :: arg1
    REAL*8 :: arg1b
    REAL*8 :: erfapp
    REAL*8 :: erfappb
    REAL*8 :: temp0
    REAL*8 :: tempb
    REAL*8 :: temp
    a = x*x*(1.27324d0+0.147d0*x*x)/(1d0+0.147d0*x*x)
    arg1 = 1d0 - EXP(-a)
    IF (x .LT. 0.0) erfappb = -erfappb
    IF (arg1 .EQ. 0.0) THEN
      arg1b = 0.0
    ELSE
      arg1b = erfappb/(2.0*SQRT(arg1))
    END IF
    ab = EXP(-a)*arg1b
    temp0 = 0.147d0*x**2 + 1d0
    tempb = ab/temp0
    temp = 0.147d0*x**2 + 1.27324d0
    xb = xb + (2*(0.147d0*x**3)-0.147d0*x**3*temp*2/temp0+temp*2*x)*&
&     tempb
  END SUBROUTINE ERFAPP_B
!*************************************************************     
!Approximation to the error function
!*************************************************************
  REAL*8 FUNCTION ERFAPP(x)
    IMPLICIT NONE
!bug removed 08/03/2011
    REAL*8, INTENT(IN) :: x
    REAL*8 :: a
    INTRINSIC EXP
    INTRINSIC SQRT
    REAL*8 :: arg1
    a = x*x*(1.27324d0+0.147d0*x*x)/(1d0+0.147d0*x*x)
    arg1 = 1d0 - EXP(-a)
    erfapp = SQRT(arg1)
    IF (x .LT. 0.0) erfapp = -erfapp
  END FUNCTION ERFAPP
!  Differentiation of jhet in reverse (adjoint) mode:
!   gradient     of useful results: dtnuc_dhf waux_ice dtnuc_dep
!                aimm dact_imm lmeff_ice vw_ice denice_ice vpresw_ice
!                vpresi_ice j fder t_ice si dtnuc a
!   with respect to varying inputs: dtnuc_dhf waux_ice dtnuc_dep
!                aimm dact_imm lmeff_ice vw_ice denice_ice vpresw_ice
!                vpresi_ice t_ice si a
!*************************************************************
! Subroutine JHET
! Calculates the ice nucleation rate coefficient and the nucleation time scale according 
!Si is the saturation ratio w.r.t. ice
! mode=1-deposition, 2-immersion of water droplets, 3- immersion of solution drops (DHF)
! to Barahona 2011 ACPD, Barahona et al . 2012 (in prep) 
!************************************************************  
  SUBROUTINE JHET_B(j, jb, dtnuc, dtnucb, fder, fderb, si, sib, t_ice, &
&   t_iceb, theta, mode, a, ab)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: t_ice, theta, si, a
    REAL*8 :: t_iceb, sib, ab
    REAL*8 :: j, dtnuc, fder
    REAL*8 :: jb, dtnucb, fderb
    REAL*8 :: dg, rgerm, dgo, fhet, m, sw, gct, aprime, ng, g, dgh
    REAL*8 :: dgb, rgermb, dgob, swb, gctb, aprimeb, ngb, gb, dghb
    INTEGER :: mode
    INTRINSIC COS
    INTRINSIC LOG
    INTRINSIC SQRT
    INTRINSIC EXP
    REAL*8 :: result1
    REAL*8 :: result1b
    REAL*8 :: arg1
    REAL*8 :: arg1b
    REAL*8 :: pwr1
    REAL*8 :: pwr1b
    INTEGER :: branch
    REAL*8 :: temp3
    REAL*8 :: temp2
    REAL*8 :: temp1
    REAL*8 :: temp0
    REAL*8 :: tempb9
    REAL*8 :: tempb8
    REAL*8 :: tempb7
    REAL*8 :: tempb6
    REAL*8 :: tempb5
    REAL*8 :: tempb4
    REAL*8 :: tempb19
    REAL*8 :: tempb3
    REAL*8 :: tempb18
    REAL*8 :: tempb2
    REAL*8 :: tempb17
    REAL*8 :: tempb1
    REAL*8 :: tempb16
    REAL*8 :: tempb0
    REAL*8 :: tempb15
    REAL*8 :: tempb14
    REAL*8 :: tempb13
    REAL*8 :: tempb12
    REAL*8 :: tempb11
    REAL*8 :: tempb10
    REAL*8 :: tempb
    REAL*8 :: tempb26
    REAL*8 :: tempb25
    REAL*8 :: temp
    REAL*8 :: tempb24
    REAL*8 :: tempb23
    REAL*8 :: tempb22
    REAL*8 :: temp9
    REAL*8 :: tempb21
    REAL*8 :: temp8
    REAL*8 :: tempb20
    REAL*8 :: temp7
    REAL*8 :: temp6
    REAL*8 :: temp5
    REAL*8 :: temp4
    m = COS(theta*pi_ice/180.0)
    fhet = (m*m*m-3.0*m+2.0)/4.0
    sw = si*vpresi_ice/vpresw_ice
!assume dry lapse rate to calculate dtnuc in immersion. Not very sensitive to this
!K/m
    gct = 9.76e-2
!K/s
    CALL PUSHREAL8(gct)
    gct = gct*waux_ice
!value at saturation 
    sigiw_ice = (-25.67+0.211*t_ice)*(-(1.8176*sw)+2.7789)*1.0e-3
!new2
    rsc_ice = 2.0*sigiw_ice/denice_ice/lmeff_ice
    IF (mode .EQ. 1) THEN
!deposition
      rgerm = 2.0*vw_ice*sigiv_ice/kb_ice/t_ice/LOG(si)
      dgo = 4.0*pi_ice*sigiv_ice*(rgerm*rgerm)/3.0
      dg = dgo*fhet
      result1 = SQRT(fhet)
      aprime = a*si*si/result1
      dgh = 0.0
      CALL PUSHCONTROL2B(0)
    ELSE IF (mode .EQ. 2) THEN
!immersion of water droplets
      rgerm = 2.0*vw_ice*sigiw_ice/kb_ice/t_ice/LOG(vpresw_ice/&
&       vpresi_ice)
      dgo = 4.0*pi_ice*sigiw_ice*(rgerm*rgerm)/3.0
      dg = dgo*fhet
      ng = 4.0*pi_ice*rgerm*rgerm*rgerm/3.0/vw_ice
      arg1 = dgo/fhet
      result1 = SQRT(arg1)
      aprime = aimm*result1/ng
!
      dgh = (m+1.0)*dgh_ice*1.60217646e-19
      CALL PUSHCONTROL2B(1)
    ELSE
!DHF (Khvorostyanov and Curry, 2004)
      g = rv_ice*t_ice/lmeff_ice
      pwr1 = sw**g
      arg1 = pwr1*to_ice/t_ice
      rgerm = 2.0*sigiw_ice/(denice_ice*lmeff_ice*LOG(arg1))
      dgo = 4.0*pi_ice*sigiw_ice*(rgerm*rgerm)/3.0
      dg = dgo*fhet
      ng = 4.0*pi_ice*rgerm*rgerm*rgerm/3.0/vw_ice
      arg1 = dgo/fhet
      result1 = SQRT(arg1)
      aprime = aimm*result1/ng
!new2
      dgh = dg*dgh_ice
      CALL PUSHCONTROL2B(2)
    END IF
    IF (rgerm .LE. 0.0) THEN
      aprime = 0.0
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    arg1 = -((dg+dgh)/kb_ice/t_ice)
    aprimeb = EXP(arg1)*jb
    arg1b = aprime*EXP(arg1)*jb
    tempb26 = -(arg1b/(kb_ice*t_ice))
    dgb = tempb26
    dghb = tempb26
    t_iceb = t_iceb - (dg+dgh)*tempb26/t_ice
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) aprimeb = 0.0_8
    CALL POPCONTROL2B(branch)
    IF (branch .EQ. 0) THEN
      temp3 = kb_ice*si*t_ice
      temp2 = LOG(si)
      temp1 = temp2*temp3
      tempb5 = 2.0*fderb/temp1
      tempb2 = -(dg*tempb5/temp1)
      dgb = dgb + tempb5
      dgob = fhet*dgb
      rgermb = pi_ice*4.0*sigiv_ice*2*rgerm*dgob/3.0
      temp0 = LOG(si)
      temp = kb_ice*t_ice*temp0
      tempb6 = sigiv_ice*2.0*rgermb/temp
      tempb3 = -(vw_ice*tempb6/temp)
      sib = sib + (t_ice*temp2*kb_ice+temp3/si)*tempb2 + kb_ice*t_ice*&
&       tempb3/si + a*2*si*aprimeb/result1
      ab = ab + si**2*aprimeb/result1
      tempb4 = dtnucb/(fhet*waux_ice)
      dtnuc_depb = dtnuc_depb + tempb4
      waux_iceb = waux_iceb - dtnuc_dep*tempb4/waux_ice
      t_iceb = t_iceb + temp0*kb_ice*tempb3 + temp2*kb_ice*si*tempb2
      vw_iceb = vw_iceb + tempb6
      sigiw_iceb = 0.0_8
      rsc_iceb = 0.0_8
      gctb = 0.0_8
      swb = 0.0_8
    ELSE IF (branch .EQ. 1) THEN
      tempb8 = kb_ice*dtnucb/(gct*(dact_imm+dg))
      tempb9 = -(t_ice**2*tempb8/(gct*(dact_imm+dg)))
      dgb = dgb + gct*tempb9
      tempb7 = aprimeb/ng
      aimmb = aimmb + result1*tempb7
      result1b = aimm*tempb7
      ngb = -(aimm*result1*tempb7/ng)
      arg1 = dgo/fhet
      IF (arg1 .EQ. 0.0) THEN
        arg1b = 0.0
      ELSE
        arg1b = result1b/(2.0*SQRT(arg1))
      END IF
      dgob = fhet*dgb + arg1b/fhet
      gctb = (dact_imm+dg)*tempb9
      dact_immb = dact_immb + gct*tempb9
      tempb11 = pi_ice*4.0*ngb/(3.0*vw_ice)
      tempb12 = pi_ice*4.0*dgob
      rgermb = sigiw_ice*2*rgerm*tempb12/3.0 + 3*rgerm**2*tempb11
      temp5 = vpresw_ice/vpresi_ice
      temp6 = LOG(temp5)
      temp4 = kb_ice*t_ice*temp6
      tempb13 = 2.0*rgermb/temp4
      vw_iceb = vw_iceb + sigiw_ice*tempb13 - rgerm**3*tempb11/vw_ice
      sigiw_iceb = vw_ice*tempb13 + rgerm**2*tempb12/3.0
      tempb10 = -(vw_ice*sigiw_ice*tempb13/temp4)
      t_iceb = t_iceb + temp6*kb_ice*tempb10 + 2*t_ice*tempb8
      tempb14 = kb_ice*t_ice*tempb10/(temp5*vpresi_ice)
      vpresw_iceb = vpresw_iceb + tempb14
      vpresi_iceb = vpresi_iceb - temp5*tempb14
      rsc_iceb = 0.0_8
      swb = 0.0_8
    ELSE
      temp9 = kb_ice*t_ice*si*rsc_ice
      tempb15 = 2.0*fderb/temp9
      dgb = dgb + rgerm*g*tempb15 + dgh_ice*dghb
      tempb16 = -(rgerm*g*dg*tempb15/temp9)
      tempb17 = kb_ice*t_ice*tempb16
      sib = sib + rsc_ice*tempb17
      rsc_iceb = si*tempb17
      tempb22 = aprimeb/ng
      aimmb = aimmb + result1*tempb22
      result1b = aimm*tempb22
      ngb = -(aimm*result1*tempb22/ng)
      arg1 = dgo/fhet
      IF (arg1 .EQ. 0.0) THEN
        arg1b = 0.0
      ELSE
        arg1b = result1b/(2.0*SQRT(arg1))
      END IF
      dgob = fhet*dgb + arg1b/fhet
      tempb23 = dtnucb/(fhet*waux_ice)
      dtnuc_dhfb = dtnuc_dhfb + tempb23
      waux_iceb = waux_iceb - dtnuc_dhf*tempb23/waux_ice
      tempb18 = pi_ice*4.0*ngb/(3.0*vw_ice)
      vw_iceb = vw_iceb - rgerm**3*tempb18/vw_ice
      tempb19 = pi_ice*4.0*dgob
      rgermb = 3*rgerm**2*tempb18 + sigiw_ice*2*rgerm*tempb19/3.0 + dg*g&
&       *tempb15
      arg1 = pwr1*to_ice/t_ice
      temp8 = LOG(arg1)
      temp7 = denice_ice*lmeff_ice*temp8
      tempb24 = 2.0*rgermb/temp7
      sigiw_iceb = tempb24 + rgerm**2*tempb19/3.0
      tempb25 = -(sigiw_ice*tempb24/temp7)
      denice_iceb = denice_iceb + temp8*lmeff_ice*tempb25
      arg1b = denice_ice*lmeff_ice*tempb25/arg1
      tempb20 = to_ice*arg1b/t_ice
      pwr1b = tempb20
      IF (sw .LE. 0.0) THEN
        gb = dg*rgerm*tempb15
      ELSE
        gb = sw**g*LOG(sw)*pwr1b + dg*rgerm*tempb15
      END IF
      IF (sw .LE. 0.0 .AND. (g .EQ. 0.0 .OR. g .NE. INT(g))) THEN
        swb = 0.0
      ELSE
        swb = g*sw**(g-1)*pwr1b
      END IF
      tempb21 = rv_ice*gb/lmeff_ice
      t_iceb = t_iceb + tempb21 - pwr1*tempb20/t_ice + si*rsc_ice*kb_ice&
&       *tempb16
      lmeff_iceb = lmeff_iceb + temp8*denice_ice*tempb25 - t_ice*tempb21&
&       /lmeff_ice
      gctb = 0.0_8
    END IF
    tempb = 2.0*rsc_iceb/(denice_ice*lmeff_ice)
    tempb0 = -(sigiw_ice*tempb/(denice_ice*lmeff_ice))
    sigiw_iceb = sigiw_iceb + tempb
    denice_iceb = denice_iceb + lmeff_ice*tempb0
    lmeff_iceb = lmeff_iceb + denice_ice*tempb0
    t_iceb = t_iceb + (2.7789-1.8176*sw)*1.0e-3*0.211*sigiw_iceb
    swb = swb - (0.211*t_ice-25.67)*1.0e-3*1.8176*sigiw_iceb
    CALL POPREAL8(gct)
    waux_iceb = waux_iceb + gct*gctb
    tempb1 = swb/vpresw_ice
    sib = sib + vpresi_ice*tempb1
    vpresi_iceb = vpresi_iceb + si*tempb1
    vpresw_iceb = vpresw_iceb - si*vpresi_ice*tempb1/vpresw_ice
  END SUBROUTINE JHET_B
!*************************************************************
! Subroutine JHET
! Calculates the ice nucleation rate coefficient and the nucleation time scale according 
!Si is the saturation ratio w.r.t. ice
! mode=1-deposition, 2-immersion of water droplets, 3- immersion of solution drops (DHF)
! to Barahona 2011 ACPD, Barahona et al . 2012 (in prep) 
!************************************************************  
  SUBROUTINE JHET(j, dtnuc, fder, si, t_ice, theta, mode, a)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: t_ice, theta, si, a
    REAL*8, INTENT(OUT) :: j, dtnuc, fder
    REAL*8 :: dg, rgerm, dgo, fhet, m, sw, gct, aprime, ng, g, dgh
    INTEGER :: mode
    INTRINSIC COS
    INTRINSIC LOG
    INTRINSIC SQRT
    INTRINSIC EXP
    REAL*8 :: result1
    REAL*8 :: arg1
    REAL*8 :: pwr1
    m = COS(theta*pi_ice/180.0)
    fhet = (m*m*m-3.0*m+2.0)/4.0
    sw = si*vpresi_ice/vpresw_ice
!assume dry lapse rate to calculate dtnuc in immersion. Not very sensitive to this
!K/m
    gct = 9.76e-2
!K/s
    gct = gct*waux_ice
!value at saturation 
    sigiw_ice = (-25.67+0.211*t_ice)*(-(1.8176*sw)+2.7789)*1.0e-3
!new2
    rsc_ice = 2.0*sigiw_ice/denice_ice/lmeff_ice
    IF (mode .EQ. 1) THEN
!deposition
      rgerm = 2.0*vw_ice*sigiv_ice/kb_ice/t_ice/LOG(si)
      dgo = 4.0*pi_ice*sigiv_ice*(rgerm*rgerm)/3.0
      dg = dgo*fhet
      fder = 2.0*dg/LOG(si)/si/kb_ice/t_ice
      dtnuc = dtnuc_dep/fhet/waux_ice
      result1 = SQRT(fhet)
      aprime = a*si*si/result1
      dgh = 0.0
    ELSE IF (mode .EQ. 2) THEN
!immersion of water droplets
      rgerm = 2.0*vw_ice*sigiw_ice/kb_ice/t_ice/LOG(vpresw_ice/&
&       vpresi_ice)
      dgo = 4.0*pi_ice*sigiw_ice*(rgerm*rgerm)/3.0
      dg = dgo*fhet
      ng = 4.0*pi_ice*rgerm*rgerm*rgerm/3.0/vw_ice
      dtnuc = kb_ice*t_ice*t_ice/(gct*(dact_imm+dg))
      arg1 = dgo/fhet
      result1 = SQRT(arg1)
      aprime = aimm*result1/ng
!
      fder = 1.0
      dgh = (m+1.0)*dgh_ice*1.60217646e-19
    ELSE
!DHF (Khvorostyanov and Curry, 2004)
      g = rv_ice*t_ice/lmeff_ice
      pwr1 = sw**g
      arg1 = pwr1*to_ice/t_ice
      rgerm = 2.0*sigiw_ice/(denice_ice*lmeff_ice*LOG(arg1))
      dgo = 4.0*pi_ice*sigiw_ice*(rgerm*rgerm)/3.0
      dg = dgo*fhet
      ng = 4.0*pi_ice*rgerm*rgerm*rgerm/3.0/vw_ice
      dtnuc = dtnuc_dhf/fhet/waux_ice
      arg1 = dgo/fhet
      result1 = SQRT(arg1)
      aprime = aimm*result1/ng
!new2
      fder = 2.0*rgerm*g*dg/kb_ice/t_ice/si/rsc_ice
      dgh = dg*dgh_ice
    END IF
    IF (rgerm .LE. 0.0) aprime = 0.0
    arg1 = -((dg+dgh)/kb_ice/t_ice)
    j = aprime*EXP(arg1)
  END SUBROUTINE JHET
!  Differentiation of empirical_param_phillips_d in reverse (adjoint) mode:
!   gradient     of useful results: temperature_k dshd n_iwd dsh
!                n_iw
!   with respect to varying inputs: swd n_grid_soot d_grid_soot
!                temperature_k a_solo n_grid_dust d_grid_dust si
!                sw siw
!  Differentiation of empirical_param_phillips in forward (tangent) mode:
!   variations   of useful results: dsh n_iw
!   with respect to varying inputs: si sw
!=======================================================================================
!=======================================================================================
!=======================================================================================
!!====================================================================================
!		EMPIRICAL PARAMETERISATION (Phillips et al. 2013, JAS)
!		contributed by Vaughan Phillips, 2012
!		University of Leeds
! Implementation:   Donifan Barahona donifan.o.barahona@nasa.gov 
!====================================================================================
  SUBROUTINE EMPIRICAL_PARAM_PHILLIPS_D_B(temperature_k, temperature_kb&
&   , p_sat, si, sib, sid, siw, siwb, sw, swb, swd, swdb, d_grid_dust, &
&   d_grid_dustb, n_grid_dust, n_grid_dustb, ijstop_dust, d_grid_soot, &
&   d_grid_sootb, n_grid_soot, n_grid_sootb, ijstop_soot, d_grid_bio, &
&   n_grid_bio, ijstop_bio, a_solo, a_solob, n_iw, n_iwb, n_iwd, n_iwdb&
&   , dsh, dshb, dshd, dshdb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: temperature_k, p_sat, si, siw, sw, a_solo
    REAL*8 :: temperature_kb, sib, siwb, swb, a_solob
    REAL*8, INTENT(IN) :: sid, swd
    REAL*8 :: swdb
    REAL*8, DIMENSION(2), INTENT(IN) :: d_grid_dust, n_grid_dust
    REAL*8, DIMENSION(2) :: d_grid_dustb, n_grid_dustb
    REAL*8, DIMENSION(1), INTENT(IN) :: d_grid_soot, n_grid_soot, &
&   d_grid_bio, n_grid_bio
    REAL*8, DIMENSION(1) :: d_grid_sootb, n_grid_sootb
    INTEGER, INTENT(IN) :: ijstop_dust, ijstop_soot, ijstop_bio
    REAL*8 :: nin_a_nuc_dust, nin_a_nuc_soot, nin_a_nuc_bio, &
&   nin_a_nuc_solo, num_ic_dust_imm, num_ic_soot_imm, num_ic_bio_imm, &
&   num_ic_solo_imm
!DONIF
    REAL*8, INTENT(INOUT) :: dsh, n_iw
    REAL*8 :: dshb, n_iwb
    REAL*8, INTENT(INOUT) :: dshd, n_iwd
    REAL*8 :: dshdb, n_iwdb
!DONIF
    REAL*8 :: dn_in_dust, dn_in_soot, dn_in_bio, dn_in_solo, dnall, &
&   dnaux, naux, ss_w, dh_frac_dust, dh_frac_soot, dh_frac_solo, aux, &
&   dfdep
    REAL*8 :: dn_in_dustb, dn_in_biob, dnallb, nauxb, ss_wb, &
&   dh_frac_dustb, auxb, dfdepb
    REAL*8 :: dn_in_dustd, dn_in_biod, dnalld, nauxd, ss_wd, &
&   dh_frac_dustd, auxd, dfdepd
    REAL*8 :: dn_in_dustdb, dn_in_biodb, dnalldb, nauxdb, ss_wdb, &
&   dh_frac_dustdb, auxdb, dfdepdb
    REAL*8 :: rho_cfdc, base_dust_omega, base_soot_philic_omega, &
&   base_bio_omega, alpha_dust, alpha_soot, alpha_bio, &
&   fraction_depnucl_warm_dust, pie, base_solo_omega, temp_max_dust_degc&
&   , temp_max_soot_degc, temp_max_bio_degc, glass_frac
    PARAMETER (base_dust_omega=2.0d-6, base_soot_philic_omega=1.0d-7, &
&   base_bio_omega=0.89d-6, base_solo_omega=5.6d-5, glass_frac=0.5d0, &
&   alpha_dust=2d0/3d0, alpha_soot=1d0/3d0-0.03d0, alpha_bio=0.03d0, &
&   rho_cfdc=50000d0/(287d0*228.15d0), fraction_depnucl_warm_dust=0.15d0&
&   , pie=3.1415926d0, temp_max_dust_degc=-10d0, temp_max_soot_degc=-&
&     15d0, temp_max_bio_degc=-2d0)
    REAL*8, SAVE :: fac_correct_rh=2d0, rho_aida
    REAL*8 :: h_frac_dust, n_in, n_in_dust, n_in_ultra, n_in_dust_ultra&
&   , cihenc_dust, esw, esi, ss_i, n_in_soot_ultra, h_frac_soot, &
&   h_frac_bio, n_in_soot, n_in_bio, n_in_bio_ultra, cihenc_soot, &
&   cihenc_bio, delta_si, delta_t, delta_sw, n_in_max, ss_iw, rho
    REAL*8 :: h_frac_dustb, n_inb, n_in_dustb, n_in_ultrab, &
&   n_in_dust_ultrab, cihenc_dustb, ss_ib, n_in_soot_ultrab, &
&   h_frac_sootb, h_frac_biob, n_in_sootb, n_in_biob, n_in_bio_ultrab, &
&   cihenc_sootb, cihenc_biob, delta_sib, delta_tb, delta_swb, n_in_maxb&
&   , ss_iwb
    REAL*8 :: h_frac_dustd, n_ind, n_in_dustd, n_in_ultrad, &
&   n_in_dust_ultrad, cihenc_dustd, ss_id, n_in_soot_ultrad, &
&   h_frac_sootd, h_frac_biod, n_in_sootd, n_in_biod, n_in_bio_ultrad, &
&   cihenc_sootd, cihenc_biod
    REAL*8 :: h_frac_dustdb, n_indb, n_in_dustdb, n_in_ultradb, &
&   n_in_dust_ultradb, cihenc_dustdb, ss_idb, n_in_soot_ultradb, &
&   h_frac_sootdb, h_frac_biodb, n_in_sootdb, n_in_biodb, &
&   n_in_bio_ultradb, cihenc_sootdb, cihenc_biodb
    REAL*8 :: h_frac_solo, rhi, n_in_solo, n_in_solo_star, cihenc_solo, &
&   psi_solo
    REAL*8 :: h_frac_solob, rhib, n_in_solob, n_in_solo_starb, &
&   cihenc_solob, psi_solob
    REAL*8 :: h_frac_solod, rhid, n_in_solod, n_in_solo_stard, &
&   cihenc_solod
    REAL*8 :: h_frac_solodb, n_in_solodb, cihenc_solodb
    REAL*8 :: mu, s_i_0, rh_crit, s_i_w_warm, s_i_w_cold, s_i_w, &
&   tc_hm_degc
    REAL*8 :: mub, s_i_0b, tc_hm_degcb
    REAL*8 :: mud
    REAL*8 :: mudb
    REAL*8 :: s_w_0, dep_frac, n_in_hat, n_in_tilde
    REAL*8 :: s_w_0b, dep_fracb, n_in_hatb, n_in_tildeb
    REAL*8 :: dep_fracd, n_in_hatd, n_in_tilded
    REAL*8 :: dep_fracdb, n_in_hatdb, n_in_tildedb
    REAL*8, SAVE :: eps=0.622d0
    INTEGER :: ij
    INTRINSIC SIZE
    INTRINSIC EXP
    INTRINSIC MAX
    INTRINSIC MIN
    REAL*8 :: pwy1
    REAL*8 :: pwy1b
    REAL*8 :: pwr1
    REAL*8 :: pwr1b
    REAL*8 :: pwr1d
    REAL*8 :: pwr1db
    REAL*8 :: result1
    REAL*8 :: result1b
    REAL*8 :: result1d
    REAL*8 :: result1db
    REAL*8 :: arg1
    REAL*8 :: arg1b
    REAL*8 :: arg1d
    REAL*8 :: pwx1
    REAL*8 :: pwx1b
    REAL*8 :: pwx1d
    REAL*8 :: pwx1db
    REAL*8 :: x2
    REAL*8 :: x2b
    REAL*8 :: x2d
    REAL*8 :: x2db
    REAL*8 :: x1
    REAL*8 :: max1d
    REAL*8 :: max1db
    REAL*8 :: max4d
    REAL*8 :: max4db
    REAL*8 :: dumm
    REAL*8 :: dumm2
    REAL*8 :: dumm1
    REAL*8 :: dumm0
    REAL*8 :: max3d
    REAL*8 :: max3db
    REAL*8 :: max6
    REAL*8 :: max6b
    REAL*8 :: max6d
    REAL*8 :: max6db
    REAL*8 :: max5
    REAL*8 :: max4
    REAL*8 :: max4b
    REAL*8 :: max3
    REAL*8 :: max3b
    REAL*8 :: max2
    REAL*8 :: max1
    REAL*8 :: max1b
    INTRINSIC INT
    REAL*8 :: arg10
    REAL*8 :: arg10b
    REAL*8 :: arg2
    REAL*8 :: arg2b
    REAL*8 :: res
    REAL*8 :: res0
    REAL*8 :: res1
    REAL*8 :: res2
    REAL*8 :: arg11
    REAL*8 :: arg12
    REAL*8 :: arg13
    INTEGER :: branch
    REAL*8 :: resb
    REAL*8 :: temp1
    REAL*8 :: temp0
    REAL*8 :: arg1b2
    REAL*8 :: arg1b1
    REAL*8 :: arg1b0
    REAL*8 :: resb2
    REAL*8 :: resb1
    REAL*8 :: tempb9
    REAL*8 :: resb0
    REAL*8 :: tempb8
    REAL*8 :: tempb7
    REAL*8 :: tempb6
    REAL*8 :: tempb5
    REAL*8 :: tempb4
    REAL*8 :: tempb19
    REAL*8 :: tempb3
    REAL*8 :: tempb18
    REAL*8 :: tempb2
    REAL*8 :: tempb17
    REAL*8 :: tempb1
    REAL*8 :: tempb16
    REAL*8 :: tempb0
    REAL*8 :: tempb15
    REAL*8 :: tempb14
    REAL*8 :: dummydiffb9
    REAL*8 :: tempb13
    REAL*8 :: dummydiffb8
    REAL*8 :: tempb12
    REAL*8 :: dummydiffb7
    REAL*8 :: tempb11
    REAL*8 :: dummydiffb6
    REAL*8 :: tempb10
    REAL*8 :: dummydiffb5
    REAL*8 :: dummydiffb4
    REAL*8 :: dummydiffb3
    REAL*8 :: dummydiffb2
    REAL*8 :: dummydiffb1
    REAL*8 :: dummydiffb0
    REAL*8 :: tempb40
    REAL*8 :: dummydiffb18
    REAL*8 :: dummydiffb17
    REAL*8 :: tempb
    REAL*8 :: dummydiffb16
    REAL*8 :: dummydiffb15
    REAL*8 :: dummydiffb14
    REAL*8 :: tempb39
    REAL*8 :: dummydiffb13
    REAL*8 :: tempb38
    REAL*8 :: dummydiffb12
    REAL*8 :: tempb37
    REAL*8 :: dummydiffb11
    REAL*8 :: tempb36
    REAL*8 :: dummydiffb10
    REAL*8 :: tempb35
    REAL*8 :: tempb34
    REAL*8 :: tempb33
    REAL*8 :: dummydiffb
    REAL*8 :: tempb32
    REAL*8 :: tempb31
    REAL*8 :: tempb30
    REAL*8 :: tempb29
    REAL*8 :: tempb28
    REAL*8 :: tempb27
    REAL*8 :: tempb26
    REAL*8 :: tempb25
    REAL*8 :: temp
    REAL*8 :: tempb24
    REAL*8 :: tempb23
    REAL*8 :: tempb22
    REAL*8 :: tempb21
    REAL*8 :: tempb20
!intrinsic :: exp, DEXP, SIZE, DBLE
!print *, SIZE(n_grid_dust(:))
    IF (ijstop_dust .NE. SIZE(n_grid_dust)) THEN
      STOP
    ELSE IF (ijstop_soot .NE. SIZE(n_grid_soot)) THEN
      STOP
    ELSE IF (ijstop_bio .NE. SIZE(n_grid_bio)) THEN
      STOP
    ELSE
!default
      n_iw = 0.0
      nin_a_nuc_dust = 0.0
      nin_a_nuc_soot = 0.0
      nin_a_nuc_bio = 0.0
      nin_a_nuc_solo = 0.0
      dn_in_dust = 0.0
      dn_in_bio = 0.0
      dh1smooth = 0.0
!====================================================================================
!		COMPUTATION BLOCK 
!
!====================================================================================
!
      rho_aida = 90000./(287.*205.)
      psi_solo = a_solo/base_solo_omega
!everything is based on supersaturation 
      ss_id = sid
      ss_i = si - 1.0
      ss_wd = swd
      ss_w = sw - 1.0
      ss_iw = siw - 1.0
      IF (ss_i .GT. 0.0d0) THEN
        IF (temperature_k .LT. 273.15d0 .AND. temperature_k .GT. 273.15 &
&           - 90.) THEN
!SS_iw = QSW/QSI - 1.
          IF (ss_w .GT. 0.) THEN
            ss_i = ss_iw
            ss_w = 0.0
            ss_id = 0.0_8
            ss_wd = 0.0_8
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
!				S_i_zero = 1.15 !this is taken care of
          dh1smoothd = 0.0_8
          arg10 = ss_i + 1d0
          CALL PUSHREAL8(dh1smooth)
          res = H_1_SMOOTH_D(arg10, ss_id, 1.1d0, 1.2d0, 0.0d0, 1d0, &
&           delta_si)
          arg10 = -(temperature_k-273.15)
          CALL PUSHREAL8(dh1smooth)
          res0 = H_1_SMOOTH_D(arg10, 0.0_8, 35d0, 40d0, &
&           fraction_depnucl_warm_dust, 1d0, delta_t)
          arg10 = ss_w + 1.0d0
          CALL PUSHREAL8(dh1smooth)
          res1 = H_1_SMOOTH_D(arg10, ss_wd, 0.97d0, 1d0, 0d0, 1d0, &
&           delta_sw)
          tc_hm_degc = temperature_k - 273.15d0
          pwy1 = 8.2584e-6*tc_hm_degc*tc_hm_degc*tc_hm_degc + 5.3938e-4*&
&           tc_hm_degc*tc_hm_degc + 3.1656e-3*tc_hm_degc - 1.0261d0
          pwr1 = 10.**pwy1
          s_i_0 = 1d0 + pwr1
          s_w_0 = 0.97d0
          arg10 = -(temperature_k-273.15d0)
          CALL PUSHREAL8(dh1smooth)
          res2 = H_1_SMOOTH_D(arg10, 0.0_8, 35d0, 40d0, &
&           fraction_depnucl_warm_dust, 1d0, result1)
          aux = result1/fac_correct_rh
          arg10 = ss_i + 1d0
          arg2 = s_i_0 + 0.1d0
          CALL PUSHREAL8(dh1smooth)
          result1d = H_1_SMOOTH_D(arg10, ss_id, s_i_0, arg2, 0d0, 1d0, &
&           result1)
          dep_fracd = aux*result1d
          dep_frac = result1*aux
          dfdepd = aux*dh1smoothd
          dfdep = dh1smooth*aux
          arg10 = ss_w + 1.0d0
          CALL PUSHREAL8(dh1smooth)
          CALL PUSHREAL8(dh1smoothd)
          CALL PUSHREAL8(aux)
          auxd = H_1_SMOOTH_D(arg10, ss_wd, s_w_0, 1.d0, 0.d0, 1.d0, aux&
&           )
          h_frac_dustd = dep_fracd + (1.d0-dep_frac)*auxd - dep_fracd*&
&           aux
          h_frac_dust = dep_frac + (1.d0-dep_frac)*aux
          dh_frac_dustd = dfdepd + siw*((1.d0-dep_frac)*dh1smoothd-&
&           dep_fracd*dh1smooth) - auxd*dfdep - aux*dfdepd
          dh_frac_dust = dfdep + siw*(1.d0-dep_frac)*dh1smooth - aux*&
&           dfdep
          IF (h_frac_dust .GT. 1.d0) THEN
            h_frac_dust = 1.d0
            h_frac_dustd = 0.0_8
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          IF (h_frac_dust .GT. 1.0e-6 .AND. h_frac_dust .LT. 1.d0) THEN
            CALL PUSHREAL8(dh_frac_dustd)
            dh_frac_dustd = (dh_frac_dustd*h_frac_dust-dh_frac_dust*&
&             h_frac_dustd)/h_frac_dust**2
            CALL PUSHREAL8(dh_frac_dust)
            dh_frac_dust = dh_frac_dust/h_frac_dust
            CALL PUSHCONTROL1B(0)
          ELSE
            dh_frac_dust = 0.0d0
            dh_frac_dustd = 0.0_8
            CALL PUSHCONTROL1B(1)
          END IF
!soluble organics
          s_i_0 = 1.2d0
          arg10 = -(temperature_k-273.15d0)
          CALL PUSHREAL8(dh1smooth)
          CALL PUSHREAL8(aux)
          aux = H_1_SMOOTH(arg10, 65d0, 75d0, 0d0, 1d0)
          arg10 = ss_i + 1d0
          arg2 = s_i_0 + 0.1d0
          CALL PUSHREAL8(dh1smooth)
          CALL PUSHREAL8(dh1smoothd)
          CALL PUSHREAL8(result1d)
          CALL PUSHREAL8(result1)
          result1d = H_1_SMOOTH_D(arg10, ss_id, s_i_0, arg2, 0d0, 1d0, &
&           result1)
          CALL PUSHREAL8(dep_fracd)
          dep_fracd = aux*result1d
          CALL PUSHREAL8(dep_frac)
          dep_frac = result1*aux
          h_frac_solod = dep_fracd
          h_frac_solo = dep_frac
          IF (h_frac_solo .GT. 1.d0) THEN
            h_frac_solo = 1.d0
            h_frac_solod = 0.0_8
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          s_w_0 = 0.97d0
          s_i_0 = 1.3d0
          arg10 = -(temperature_k-273.15d0)
          CALL PUSHREAL8(dh1smooth)
          CALL PUSHREAL8(result1)
          result1 = H_1_SMOOTH(arg10, 40.d0, 50.d0, 0.d0, 1.d0)
          CALL PUSHREAL8(aux)
          aux = result1/fac_correct_rh
          arg10 = ss_i + 1d0
          arg2 = s_i_0 + 0.1d0
          CALL PUSHREAL8(dh1smooth)
          CALL PUSHREAL8(result1d)
          result1d = H_1_SMOOTH_D(arg10, ss_id, s_i_0, arg2, 0.d0, 1.d0&
&           , result1)
          dep_fracd = aux*result1d
          dep_frac = result1*aux
          arg10 = ss_w + 1.0d0
          CALL PUSHREAL8(dh1smooth)
          CALL PUSHREAL8(auxd)
          CALL PUSHREAL8(aux)
          auxd = H_1_SMOOTH_D(arg10, ss_wd, s_w_0, 1.d0, 0.d0, 1.d0, aux&
&           )
          h_frac_sootd = dep_fracd + (1.d0-dep_frac)*auxd - dep_fracd*&
&           aux
          h_frac_soot = dep_frac + (1.d0-dep_frac)*aux
          IF (h_frac_soot .GT. 1.d0) THEN
            h_frac_soot = 1.d0
            h_frac_sootd = 0.0_8
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          h_frac_biod = h_frac_sootd
          h_frac_bio = h_frac_soot
          IF (temperature_k .LT. 273.15d0 .AND. temperature_k .GE. &
&             273.15d0 - 35.d0) THEN
            n_ind = 1.e3*0.0587*fac_correct_rh*12.96d0*ss_id*EXP(12.96d0&
&             *ss_i-0.639)/rho_cfdc
            n_in = 1.e3*(EXP(12.96d0*ss_i-0.639)/rho_cfdc)*0.0587*&
&             fac_correct_rh
            IF (temperature_k .GT. 273.15 - 5. .AND. temperature_k .LT. &
&               273.15 - 2.) THEN
              arg10 = -(temperature_k-273.15d0)
              CALL PUSHREAL8(dh1smooth)
              CALL PUSHREAL8(result1)
              result1 = H_1_SMOOTH(arg10, 2.d0, 5.d0, 0.d0, 1.d0)
              CALL PUSHREAL8(n_ind)
              n_ind = result1*n_ind
              CALL PUSHREAL8(n_in)
              n_in = n_in*result1
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
            IF (temperature_k .GE. 273.15 - 2.d0) THEN
              n_in = 0.d0
              n_ind = 0.0_8
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
            IF (temperature_k .LT. 273.15d0 - 25.d0) THEN
              arg1d = 0.1296*100.*ss_id
              arg1 = 0.1296*(ss_i*100.-10.)
              n_in_tilded = 1000.*fac_correct_rh*0.3*EXP(arg1)**(-0.7)*&
&               arg1d*EXP(arg1)/rho_cfdc
              n_in_tilde = 1000.*EXP(arg1)**0.3*fac_correct_rh/rho_cfdc
              n_in_hatd = n_ind
              n_in_hat = n_in
              IF (temperature_k .GE. 273.15 - 30.) THEN
                n_in_max = 1.e3*(EXP(12.96*ss_iw-0.639)/rho_cfdc)*0.0587&
&                 *fac_correct_rh
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
              IF (temperature_k .LT. 273.15 - 30.) THEN
                arg1 = 0.1296*(ss_iw*100.-10.)
                n_in_max = 1000.*EXP(arg1)**0.3*fac_correct_rh/rho_cfdc
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
              IF (n_in_hat .GT. n_in_max) THEN
                n_in_hat = n_in_max
                n_in_hatd = 0.0_8
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
              IF (n_in_tilde .GT. n_in_max) THEN
                n_in_tilde = n_in_max
                n_in_tilded = 0.0_8
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
              pwx1d = (n_in_tilded*n_in_hat-n_in_tilde*n_in_hatd)/&
&               n_in_hat**2
              pwx1 = n_in_tilde/n_in_hat
              arg10 = -(temperature_k-273.15d0)
              CALL PUSHREAL8(dh1smooth)
              CALL PUSHREAL8(result1)
              result1 = H_1_SMOOTH(arg10, 25d0, 35d0, 0d0, 1d0)
              IF (pwx1 .GT. 0.0 .OR. (pwx1 .LT. 0.0 .AND. result1 .EQ. &
&                 INT(result1))) THEN
                pwr1d = result1*pwx1**(result1-1)*pwx1d
                CALL PUSHCONTROL2B(0)
              ELSE IF (pwx1 .EQ. 0.0 .AND. result1 .EQ. 1.0) THEN
                pwr1d = pwx1d
                CALL PUSHCONTROL2B(1)
              ELSE
                pwr1d = 0.0
                CALL PUSHCONTROL2B(2)
              END IF
              pwr1 = pwx1**result1
              n_ind = n_in_hatd*pwr1 + n_in_hat*pwr1d
              n_in = n_in_hat*pwr1
              IF (n_in .GT. n_in_max) THEN
                n_in = n_in_max
                n_ind = 0.0_8
                CALL PUSHCONTROL2B(0)
              ELSE
                CALL PUSHCONTROL2B(1)
              END IF
            ELSE
              CALL PUSHCONTROL2B(2)
            END IF
            n_in_dust = 0.
            dn_in_dust = 0.
            IF (temperature_k .LT. 273.15 - 30.) THEN
!DONIF
!this is a simplified derivative of dNds
              dnaux = 3.88
            ELSE
              dnaux = 12.96
            END IF
            dn_in_dustd = 0.0_8
            n_in_dustd = 0.0_8
            DO ij=1,ijstop_dust
              CALL PUSHREAL8(mud)
              mud = alpha_dust*pie*d_grid_dust(ij)**2*(n_ind*h_frac_dust&
&               +n_in*h_frac_dustd)/base_dust_omega
              CALL PUSHREAL8(mu)
              mu = n_in*alpha_dust*h_frac_dust*pie*d_grid_dust(ij)*&
&               d_grid_dust(ij)/base_dust_omega
              CALL PUSHREAL8(nauxd)
              nauxd = n_grid_dust(ij)*mud*EXP(-mu)
              CALL PUSHREAL8(naux)
              naux = (1.-EXP(-mu))*n_grid_dust(ij)
              n_in_dustd = n_in_dustd + nauxd
              n_in_dust = n_in_dust + naux
              IF (mu*(n_grid_dust(ij)-naux)*(dnaux+dh_frac_dust) .LT. &
&                 0.0) THEN
                max1 = 0.0
                max1d = 0.0_8
                CALL PUSHCONTROL1B(0)
              ELSE
                max1d = (mud*(dnaux+dh_frac_dust)+mu*dh_frac_dustd)*(&
&                 n_grid_dust(ij)-naux) - mu*(dnaux+dh_frac_dust)*nauxd
                max1 = mu*(n_grid_dust(ij)-naux)*(dnaux+dh_frac_dust)
                CALL PUSHCONTROL1B(1)
              END IF
              dn_in_dustd = max1d + dn_in_dustd
              dn_in_dust = max1 + dn_in_dust
            END DO
            IF (temperature_k .GT. 273.15 + temp_max_dust_degc - 20. &
&               .AND. temperature_k .LT. 273.15 + temp_max_dust_degc) &
&           THEN
              arg10 = -(temperature_k-273.15d0)
              arg2 = -temp_max_dust_degc + 20d0
              arg11 = -temp_max_dust_degc
              CALL PUSHREAL8(dh1smooth)
              CALL PUSHREAL8(result1)
              result1 = H_1_SMOOTH(arg10, arg11, arg2, 0d0, 1d0)
              CALL PUSHREAL8(n_in_dustd)
              n_in_dustd = result1*n_in_dustd
              CALL PUSHREAL8(n_in_dust)
              n_in_dust = n_in_dust*result1
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
            IF (temperature_k .GE. 273.15 + temp_max_dust_degc) THEN
              n_in_dust = 0.
              n_in_dustd = 0.0_8
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
            n_in_soot = 0.
            n_in_sootd = 0.0_8
            DO ij=1,ijstop_soot
              CALL PUSHREAL8(mud)
              mud = alpha_soot*pie*d_grid_soot(ij)**2.*(n_ind*&
&               h_frac_soot+n_in*h_frac_sootd)/base_soot_philic_omega
              CALL PUSHREAL8(mu)
              mu = n_in*alpha_soot*h_frac_soot*pie*d_grid_soot(ij)**2./&
&               base_soot_philic_omega
              CALL PUSHREAL8(nauxd)
              nauxd = n_grid_soot(ij)*mud*EXP(-mu)
              CALL PUSHREAL8(naux)
              naux = (1.-EXP(-mu))*n_grid_soot(ij)
              n_in_sootd = n_in_sootd + nauxd
              n_in_soot = n_in_soot + naux
            END DO
            IF (temperature_k .GT. 273.15 + temp_max_soot_degc - 10. &
&               .AND. temperature_k .LT. 273.15 + temp_max_soot_degc) &
&           THEN
              arg10 = -(temperature_k-273.15d0)
              arg2 = -temp_max_soot_degc + 10d0
              arg12 = -temp_max_soot_degc
              CALL PUSHREAL8(dh1smooth)
              CALL PUSHREAL8(result1)
              result1 = H_1_SMOOTH(arg10, arg12, arg2, 0d0, 1d0)
              CALL PUSHREAL8(n_in_sootd)
              n_in_sootd = result1*n_in_sootd
              CALL PUSHREAL8(n_in_soot)
              n_in_soot = n_in_soot*result1
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
            IF (temperature_k .GE. 273.15 + temp_max_soot_degc) THEN
              n_in_soot = 0.
              n_in_sootd = 0.0_8
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
            n_in_bio = 0.
            dn_in_bio = 0.
            n_in_biod = 0.0_8
            dn_in_biod = 0.0_8
            DO ij=1,ijstop_bio
              CALL PUSHREAL8(mud)
              mud = alpha_bio*(n_ind*h_frac_bio+n_in*h_frac_biod)
              CALL PUSHREAL8(mu)
              mu = n_in*alpha_bio*h_frac_bio
              CALL PUSHREAL8(nauxd)
              nauxd = n_grid_bio(ij)*mud*EXP(-mu)
              CALL PUSHREAL8(naux)
              naux = (1.-EXP(-mu))*n_grid_bio(ij)
!!!!!!!!!!!!!!remember!!!!!!!!!!!!!!!!
!naux =  n_in*ALPHA_bio*H_frac_bio
!!!!!!!!!!!!!!remember!!!!!!!!!!!!!!!!
              n_in_biod = n_in_biod + nauxd
              n_in_bio = n_in_bio + naux
              IF (mu*(n_grid_bio(ij)-naux)*dnaux .LT. 0.0) THEN
                max3 = 0.0
                max3d = 0.0_8
                CALL PUSHCONTROL1B(0)
              ELSE
                max3d = dnaux*(mud*(n_grid_bio(ij)-naux)-mu*nauxd)
                max3 = mu*(n_grid_bio(ij)-naux)*dnaux
                CALL PUSHCONTROL1B(1)
              END IF
              dn_in_biod = max3d + dn_in_biod
              dn_in_bio = max3 + dn_in_bio
            END DO
            IF (temperature_k .GT. 273.15 + temp_max_bio_degc - 3. .AND.&
&               temperature_k .LT. 273.15 + temp_max_bio_degc) THEN
              arg10 = -(temperature_k-273.15d0)
              arg2 = -temp_max_bio_degc + 3d0
              arg13 = -temp_max_bio_degc
              CALL PUSHREAL8(dh1smooth)
              CALL PUSHREAL8(result1)
              result1 = H_1_SMOOTH(arg10, arg13, arg2, 0d0, 1d0)
              CALL PUSHREAL8(n_in_biod)
              n_in_biod = result1*n_in_biod
              CALL PUSHREAL8(n_in_bio)
              n_in_bio = n_in_bio*result1
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
            IF (temperature_k .GE. 273.15 + temp_max_bio_degc) THEN
              n_in_bio = 0d0
              n_in_biod = 0.0_8
              CALL PUSHCONTROL2B(0)
            ELSE
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE
            n_in_dust = 0.
            n_in_soot = 0.
            n_in_bio = 0.
            n_in_sootd = 0.0_8
            n_in_biod = 0.0_8
            dn_in_dustd = 0.0_8
            n_in_dustd = 0.0_8
            dn_in_biod = 0.0_8
            CALL PUSHCONTROL2B(2)
          END IF
          IF (temperature_k .LT. 273.15 - 35.) THEN
            arg1d = 0.1296*100.*ss_id
            arg1 = 0.1296*(ss_i*100.-10.)
            n_in_ultrad = 1000.*fac_correct_rh*0.3*EXP(arg1)**(-0.7)*&
&             arg1d*EXP(arg1)/rho_cfdc
            n_in_ultra = 1000.*EXP(arg1)**0.3*fac_correct_rh/rho_cfdc
!DONIF simplified treatment of derivative asusming dH small 
            CALL PUSHREAL8(dnaux)
            dnaux = 3.88
            rhid = 100.*ss_id
            rhi = (ss_i+1.)*100.
            IF (rhi .LT. 0.) THEN
              rhi = 0.
              rhid = 0.0_8
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
            n_in_solo_stard = 1000.e6*7.7211e-5*rhid/rho_aida
            n_in_solo_star = 1000.e6*(7.7211e-5*rhi-9.2688e-3)/rho_aida
            n_in_dust_ultra = 0.
            dn_in_dust = 0.0
            n_in_dust_ultrad = 0.0_8
            dn_in_dustd = 0.0_8
            DO ij=1,ijstop_dust
              CALL PUSHREAL8(mud)
              mud = alpha_dust*pie*d_grid_dust(ij)**2.*(n_in_ultrad*&
&               h_frac_dust+n_in_ultra*h_frac_dustd)/base_dust_omega
              CALL PUSHREAL8(mu)
              mu = n_in_ultra*alpha_dust*h_frac_dust*pie*d_grid_dust(ij)&
&               **2./base_dust_omega
              CALL PUSHREAL8(nauxd)
              nauxd = n_grid_dust(ij)*mud*EXP(-mu)
              CALL PUSHREAL8(naux)
              naux = (1.-EXP(-mu))*n_grid_dust(ij)
              n_in_dust_ultrad = n_in_dust_ultrad + nauxd
              n_in_dust_ultra = n_in_dust_ultra + naux
              IF (mu*(n_grid_dust(ij)-naux)*(dnaux+dh_frac_dust) .LT. &
&                 0.0) THEN
                max4 = 0.0
                max4d = 0.0_8
                CALL PUSHCONTROL1B(0)
              ELSE
                max4d = (mud*(dnaux+dh_frac_dust)+mu*dh_frac_dustd)*(&
&                 n_grid_dust(ij)-naux) - mu*(dnaux+dh_frac_dust)*nauxd
                max4 = mu*(n_grid_dust(ij)-naux)*(dnaux+dh_frac_dust)
                CALL PUSHCONTROL1B(1)
              END IF
              dn_in_dustd = max4d + dn_in_dustd
              dn_in_dust = max4 + dn_in_dust
            END DO
            n_in_soot_ultra = 0.0
            n_in_soot_ultrad = 0.0_8
            DO ij=1,ijstop_soot
              CALL PUSHREAL8(mud)
              mud = alpha_soot*pie*d_grid_soot(ij)**2.*(n_in_ultrad*&
&               h_frac_soot+n_in_ultra*h_frac_sootd)/&
&               base_soot_philic_omega
              CALL PUSHREAL8(mu)
              mu = n_in_ultra*alpha_soot*h_frac_soot*pie*d_grid_soot(ij)&
&               **2./base_soot_philic_omega
              CALL PUSHREAL8(nauxd)
              nauxd = n_grid_soot(ij)*mud*EXP(-mu)
              CALL PUSHREAL8(naux)
              naux = (1.-EXP(-mu))*n_grid_soot(ij)
              n_in_soot_ultrad = n_in_soot_ultrad + nauxd
              n_in_soot_ultra = n_in_soot_ultra + naux
            END DO
            n_in_bio_ultra = 0.
            dn_in_bio = 0.0
            n_in_bio_ultrad = 0.0_8
            dn_in_biod = 0.0_8
            DO ij=1,ijstop_bio
              CALL PUSHREAL8(mud)
              mud = alpha_bio*pie*d_grid_bio(ij)**2.*(n_in_ultrad*&
&               h_frac_bio+n_in_ultra*h_frac_biod)/base_bio_omega
              CALL PUSHREAL8(mu)
              mu = n_in_ultra*alpha_bio*h_frac_bio*pie*d_grid_bio(ij)**&
&               2./base_bio_omega
              CALL PUSHREAL8(nauxd)
              nauxd = n_grid_bio(ij)*mud*EXP(-mu)
              CALL PUSHREAL8(naux)
              naux = (1.-EXP(-mu))*n_grid_bio(ij)
              n_in_bio_ultrad = n_in_bio_ultrad + nauxd
              n_in_bio_ultra = n_in_bio_ultra + naux
              IF (mu*(n_grid_bio(ij)-naux)*dnaux .LT. 0.0) THEN
                max6 = 0.0
                max6d = 0.0_8
                CALL PUSHCONTROL1B(0)
              ELSE
                max6d = dnaux*(mud*(n_grid_bio(ij)-naux)-mu*nauxd)
                max6 = mu*(n_grid_bio(ij)-naux)*dnaux
                CALL PUSHCONTROL1B(1)
              END IF
              dn_in_biod = max6d + dn_in_biod
              dn_in_bio = max6 + dn_in_bio
            END DO
            n_in_solod = psi_solo*glass_frac*(h_frac_solod*&
&             n_in_solo_star+h_frac_solo*n_in_solo_stard)
            n_in_solo = psi_solo*glass_frac*h_frac_solo*n_in_solo_star
            CALL PUSHCONTROL1B(0)
          ELSE
            n_in_dust_ultra = 0.
            n_in_soot_ultra = 0.
            n_in_solo = 0.
            n_in_bio_ultra = 0.
            n_in_soot_ultrad = 0.0_8
            n_in_dust_ultrad = 0.0_8
            n_in_solod = 0.0_8
            n_in_bio_ultrad = 0.0_8
            CALL PUSHCONTROL1B(1)
          END IF
          n_in_dustd = n_in_dustd + n_in_dust_ultrad
          n_in_dust = n_in_dust + n_in_dust_ultra
          n_in_sootd = n_in_sootd + n_in_soot_ultrad
          n_in_soot = n_in_soot + n_in_soot_ultra
          n_in_biod = n_in_biod + n_in_bio_ultrad
          n_in_bio = n_in_bio + n_in_bio_ultra
! PROBLEM:  how to ensure that the frozen fraction does not exceed 1 ?
          IF (n_in_dust + n_in_bio + n_in_soot + n_in_solo .GT. 0.) THEN
            cihenc_dustd = n_in_dustd
            cihenc_dust = n_in_dust - nin_a_nuc_dust
            IF (cihenc_dust .LT. 0.) THEN
              cihenc_dust = 0.
              cihenc_dustd = 0.0_8
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
            cihenc_sootd = n_in_sootd
            cihenc_soot = n_in_soot - nin_a_nuc_soot
            IF (cihenc_soot .LT. 0.) THEN
              cihenc_soot = 0.
              cihenc_sootd = 0.0_8
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
            cihenc_biod = n_in_biod
            cihenc_bio = n_in_bio - nin_a_nuc_bio
            IF (cihenc_bio .LT. 0.) THEN
              cihenc_bio = 0.
              cihenc_biod = 0.0_8
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
            cihenc_solod = n_in_solod
            cihenc_solo = n_in_solo - nin_a_nuc_solo
            IF (cihenc_solo .LT. 0.) THEN
              cihenc_solo = 0.
              cihenc_solod = 0.0_8
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
            n_iwd = cihenc_dustd
            n_iw = n_iw + cihenc_dust
            n_iwd = n_iwd + cihenc_sootd
            n_iw = n_iw + cihenc_soot
            n_iwd = n_iwd + cihenc_biod
            n_iw = n_iw + cihenc_bio
            n_iwd = n_iwd + cihenc_solod
            n_iw = n_iw + cihenc_solo
            CALL PUSHCONTROL2B(0)
          ELSE
            n_iwd = 0.0_8
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          n_iwd = 0.0_8
          n_in_sootd = 0.0_8
          n_in_solod = 0.0_8
          dn_in_dustd = 0.0_8
          dn_in_biod = 0.0_8
          CALL PUSHCONTROL2B(2)
        END IF
      ELSE
        n_iwd = 0.0_8
        n_in_sootd = 0.0_8
        n_in_solod = 0.0_8
        dn_in_dustd = 0.0_8
        dn_in_biod = 0.0_8
        CALL PUSHCONTROL2B(3)
      END IF
!DONIF
      dnalld = dn_in_dustd + dn_in_biod + n_in_sootd + n_in_solod
      dnall = dn_in_dust + dn_in_bio + n_in_soot + n_in_solo
      IF (dnall .GT. 0. .AND. n_iw .GT. 0.0) THEN
        IF (n_iw/dnall .GT. ss_i) THEN
          x2 = ss_i
          CALL PUSHCONTROL1B(0)
        ELSE
          x2 = n_iw/dnall
          CALL PUSHCONTROL1B(1)
        END IF
        IF (x2 .LT. 0.005) THEN
          x2db = 0.0_8
          x2b = 0.0_8
        ELSE
          x2b = dshb
          x2db = dshdb
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          ss_ib = x2b
          dnalldb = 0.0_8
          dnallb = 0.0_8
        ELSE
          tempb40 = x2db/dnall**2
          n_iwb = n_iwb + x2b/dnall - dnalld*tempb40
          dnallb = (n_iwd-(n_iwd*dnall-n_iw*dnalld)*2/dnall)*tempb40 - &
&           n_iw*x2b/dnall**2
          n_iwdb = n_iwdb + dnall*tempb40
          dnalldb = -(n_iw*tempb40)
          ss_ib = 0.0_8
        END IF
      ELSE
        ss_ib = 0.0_8
        dnalldb = 0.0_8
        dnallb = 0.0_8
      END IF
      dn_in_dustb = dnallb
      dn_in_biob = dnallb
      n_in_sootb = dnallb
      n_in_solob = dnallb
      dn_in_dustdb = dnalldb
      dn_in_biodb = dnalldb
      n_in_sootdb = dnalldb
      n_in_solodb = dnalldb
      CALL POPCONTROL2B(branch)
      IF (branch .LT. 2) THEN
        IF (branch .EQ. 0) THEN
          cihenc_solob = n_iwb
          cihenc_solodb = n_iwdb
          cihenc_biob = n_iwb
          cihenc_biodb = n_iwdb
          cihenc_sootb = n_iwb
          cihenc_sootdb = n_iwdb
          cihenc_dustb = n_iwb
          cihenc_dustdb = n_iwdb
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            cihenc_solob = 0.0_8
            cihenc_solodb = 0.0_8
          END IF
          n_in_solob = n_in_solob + cihenc_solob
          n_in_solodb = n_in_solodb + cihenc_solodb
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            cihenc_biodb = 0.0_8
            cihenc_biob = 0.0_8
          END IF
          n_in_biob = cihenc_biob
          n_in_biodb = cihenc_biodb
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            cihenc_sootdb = 0.0_8
            cihenc_sootb = 0.0_8
          END IF
          n_in_sootb = n_in_sootb + cihenc_sootb
          n_in_sootdb = n_in_sootdb + cihenc_sootdb
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            cihenc_dustb = 0.0_8
            cihenc_dustdb = 0.0_8
          END IF
          n_in_dustb = cihenc_dustb
          n_in_dustdb = cihenc_dustdb
        ELSE
          n_in_biodb = 0.0_8
          n_in_dustdb = 0.0_8
          n_in_biob = 0.0_8
          n_in_dustb = 0.0_8
        END IF
        n_in_bio_ultrab = n_in_biob
        n_in_bio_ultradb = n_in_biodb
        n_in_soot_ultrab = n_in_sootb
        n_in_soot_ultradb = n_in_sootdb
        n_in_dust_ultrab = n_in_dustb
        n_in_dust_ultradb = n_in_dustdb
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          tempb39 = glass_frac*psi_solo*n_in_solodb
          tempb38 = glass_frac*n_in_solob
          psi_solob = glass_frac*(h_frac_solod*n_in_solo_star+&
&           n_in_solo_stard*h_frac_solo)*n_in_solodb + n_in_solo_star*&
&           h_frac_solo*tempb38
          h_frac_solob = n_in_solo_stard*tempb39 + n_in_solo_star*&
&           psi_solo*tempb38
          n_in_solo_starb = h_frac_solod*tempb39 + psi_solo*h_frac_solo*&
&           tempb38
          h_frac_solodb = n_in_solo_star*tempb39
          n_in_ultradb = 0.0_8
          h_frac_biodb = 0.0_8
          n_in_ultrab = 0.0_8
          h_frac_biob = 0.0_8
          DO ij=ijstop_bio,1,-1
            max6b = dn_in_biob
            max6db = dn_in_biodb
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              mu = n_in_ultra*alpha_bio*h_frac_bio*pie*d_grid_bio(ij)**&
&               2./base_bio_omega
              nauxb = 0.0_8
              mudb = 0.0_8
              nauxdb = 0.0_8
              mub = 0.0_8
            ELSE
              tempb37 = dnaux*max6db
              mub = dnaux*(n_grid_bio(ij)-naux)*max6b - nauxd*tempb37
              nauxb = -(mud*tempb37) - mu*dnaux*max6b
              mudb = (n_grid_bio(ij)-naux)*tempb37
              nauxdb = -(mu*tempb37)
            END IF
            nauxb = nauxb + n_in_bio_ultrab
            nauxdb = nauxdb + n_in_bio_ultradb
            CALL POPREAL8(naux)
            mub = mub + EXP(-mu)*n_grid_bio(ij)*nauxb - EXP(-mu)*mud*&
&             n_grid_bio(ij)*nauxdb
            CALL POPREAL8(nauxd)
            mudb = mudb + n_grid_bio(ij)*EXP(-mu)*nauxdb
            CALL POPREAL8(mu)
            tempb35 = alpha_bio*pie*d_grid_bio(ij)**2.*mub/&
&             base_bio_omega
            CALL POPREAL8(mud)
            tempb36 = alpha_bio*pie*d_grid_bio(ij)**2.*mudb/&
&             base_bio_omega
            n_in_ultrab = n_in_ultrab + h_frac_biod*tempb36 + h_frac_bio&
&             *tempb35
            h_frac_biob = h_frac_biob + n_in_ultrad*tempb36 + n_in_ultra&
&             *tempb35
            n_in_ultradb = n_in_ultradb + h_frac_bio*tempb36
            h_frac_biodb = h_frac_biodb + n_in_ultra*tempb36
          END DO
          n_grid_sootb = 0.0_8
          d_grid_sootb = 0.0_8
          h_frac_sootdb = 0.0_8
          h_frac_sootb = 0.0_8
          DO ij=ijstop_soot,1,-1
            nauxb = n_in_soot_ultrab
            nauxdb = n_in_soot_ultradb
            mu = n_in_ultra*alpha_soot*h_frac_soot*pie*d_grid_soot(ij)**&
&             2./base_soot_philic_omega
            CALL POPREAL8(naux)
            mub = EXP(-mu)*n_grid_soot(ij)*nauxb - EXP(-mu)*n_grid_soot(&
&             ij)*mud*nauxdb
            CALL POPREAL8(nauxd)
            tempb30 = EXP(-mu)*nauxdb
            n_grid_sootb(ij) = n_grid_sootb(ij) + mud*tempb30 + (1.-EXP(&
&             -mu))*nauxb
            mudb = n_grid_soot(ij)*tempb30
            CALL POPREAL8(mu)
            tempb31 = alpha_soot*pie*mub
            tempb32 = d_grid_soot(ij)**2.*tempb31/base_soot_philic_omega
            CALL POPREAL8(mud)
            tempb34 = alpha_soot*pie*mudb
            d_grid_sootb(ij) = d_grid_sootb(ij) + (n_in_ultrad*&
&             h_frac_soot+n_in_ultra*h_frac_sootd)*2.*d_grid_soot(ij)*&
&             tempb34/base_soot_philic_omega + n_in_ultra*h_frac_soot*2.&
&             *d_grid_soot(ij)*tempb31/base_soot_philic_omega
            tempb33 = d_grid_soot(ij)**2.*tempb34/base_soot_philic_omega
            n_in_ultrab = n_in_ultrab + h_frac_sootd*tempb33 + &
&             h_frac_soot*tempb32
            h_frac_sootb = h_frac_sootb + n_in_ultrad*tempb33 + &
&             n_in_ultra*tempb32
            n_in_ultradb = n_in_ultradb + h_frac_soot*tempb33
            h_frac_sootdb = h_frac_sootdb + n_in_ultra*tempb33
          END DO
          n_grid_dustb = 0.0_8
          d_grid_dustb = 0.0_8
          dh_frac_dustdb = 0.0_8
          h_frac_dustb = 0.0_8
          h_frac_dustdb = 0.0_8
          dh_frac_dustb = 0.0_8
          DO ij=ijstop_dust,1,-1
            max4b = dn_in_dustb
            max4db = dn_in_dustdb
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              mu = n_in_ultra*alpha_dust*h_frac_dust*pie*d_grid_dust(ij)&
&               **2./base_dust_omega
              nauxb = 0.0_8
              mudb = 0.0_8
              nauxdb = 0.0_8
              mub = 0.0_8
            ELSE
              tempb28 = (mud*(dnaux+dh_frac_dust)+mu*dh_frac_dustd)*&
&               max4db
              tempb29 = (n_grid_dust(ij)-naux)*max4db
              tempb26 = mu*(dnaux+dh_frac_dust)*max4b
              tempb27 = (n_grid_dust(ij)-naux)*max4b
              n_grid_dustb(ij) = n_grid_dustb(ij) + tempb28 + tempb26
              nauxb = -tempb28 - tempb26
              mub = dh_frac_dustd*tempb29 - (dnaux+dh_frac_dust)*nauxd*&
&               max4db + (dnaux+dh_frac_dust)*tempb27
              dh_frac_dustb = dh_frac_dustb + mud*tempb29 - mu*nauxd*&
&               max4db + mu*tempb27
              mudb = (dnaux+dh_frac_dust)*tempb29
              dh_frac_dustdb = dh_frac_dustdb + mu*tempb29
              nauxdb = -((dnaux+dh_frac_dust)*mu*max4db)
            END IF
            nauxb = nauxb + n_in_dust_ultrab
            nauxdb = nauxdb + n_in_dust_ultradb
            CALL POPREAL8(naux)
            mub = mub + EXP(-mu)*n_grid_dust(ij)*nauxb - EXP(-mu)*&
&             n_grid_dust(ij)*mud*nauxdb
            CALL POPREAL8(nauxd)
            tempb21 = EXP(-mu)*nauxdb
            n_grid_dustb(ij) = n_grid_dustb(ij) + mud*tempb21 + (1.-EXP(&
&             -mu))*nauxb
            mudb = mudb + n_grid_dust(ij)*tempb21
            CALL POPREAL8(mu)
            tempb22 = alpha_dust*pie*mub
            tempb23 = d_grid_dust(ij)**2.*tempb22/base_dust_omega
            CALL POPREAL8(mud)
            tempb25 = alpha_dust*pie*mudb
            d_grid_dustb(ij) = d_grid_dustb(ij) + (n_in_ultrad*&
&             h_frac_dust+n_in_ultra*h_frac_dustd)*2.*d_grid_dust(ij)*&
&             tempb25/base_dust_omega + n_in_ultra*h_frac_dust*2.*&
&             d_grid_dust(ij)*tempb22/base_dust_omega
            tempb24 = d_grid_dust(ij)**2.*tempb25/base_dust_omega
            n_in_ultrab = n_in_ultrab + h_frac_dustd*tempb24 + &
&             h_frac_dust*tempb23
            h_frac_dustb = h_frac_dustb + n_in_ultrad*tempb24 + &
&             n_in_ultra*tempb23
            n_in_ultradb = n_in_ultradb + h_frac_dust*tempb24
            h_frac_dustdb = h_frac_dustdb + n_in_ultra*tempb24
          END DO
          rhib = 1000.e6*7.7211e-5*n_in_solo_starb/rho_aida
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) rhib = 0.0_8
          tempb20 = fac_correct_rh*arg1d*0.3*1000.*n_in_ultradb
          temp1 = EXP(arg1)
          arg1b = (temp1**(-0.7)*EXP(arg1)/rho_cfdc-0.7*temp1**(-1.7)*&
&           EXP(arg1)**2/rho_cfdc)*tempb20 + 0.3*EXP(arg1)**(-0.7)*&
&           fac_correct_rh*1000.*EXP(arg1)*n_in_ultrab/rho_cfdc
          ss_ib = ss_ib + 0.1296*100.*arg1b + 100.*rhib
          CALL POPREAL8(dnaux)
          dn_in_biodb = 0.0_8
          dn_in_dustb = 0.0_8
          dn_in_dustdb = 0.0_8
          dn_in_biob = 0.0_8
        ELSE
          n_grid_sootb = 0.0_8
          d_grid_sootb = 0.0_8
          n_grid_dustb = 0.0_8
          d_grid_dustb = 0.0_8
          h_frac_sootdb = 0.0_8
          h_frac_biodb = 0.0_8
          h_frac_sootb = 0.0_8
          dh_frac_dustdb = 0.0_8
          h_frac_solob = 0.0_8
          psi_solob = 0.0_8
          h_frac_solodb = 0.0_8
          h_frac_dustb = 0.0_8
          h_frac_dustdb = 0.0_8
          dh_frac_dustb = 0.0_8
          h_frac_biob = 0.0_8
        END IF
        CALL POPCONTROL2B(branch)
        IF (branch .EQ. 0) THEN
          n_in_biodb = 0.0_8
          n_in_biob = 0.0_8
        ELSE IF (branch .NE. 1) THEN
          ss_iwb = 0.0_8
          GOTO 110
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(n_in_bio)
          CALL POPREAL8(n_in_biod)
          result1b = n_in_biod*n_in_biodb + n_in_bio*n_in_biob
          n_in_biob = result1*n_in_biob
          n_in_biodb = result1*n_in_biodb
          CALL POPREAL8(result1)
          CALL POPREAL8(dh1smooth)
          dh1smoothb = 0.0_8
          CALL H_1_SMOOTH_B(arg10, arg10b, arg13, arg1b2, arg2, arg2b, &
&                     0d0, 1d0, result1b)
          temperature_kb = temperature_kb - arg10b
        END IF
        n_indb = 0.0_8
        n_inb = 0.0_8
        DO ij=ijstop_bio,1,-1
          max3b = dn_in_biob
          max3db = dn_in_biodb
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            mud = alpha_bio*(n_ind*h_frac_bio+n_in*h_frac_biod)
            mu = n_in*alpha_bio*h_frac_bio
            nauxb = 0.0_8
            mudb = 0.0_8
            nauxdb = 0.0_8
            mub = 0.0_8
          ELSE
            tempb19 = dnaux*max3db
            mub = dnaux*(n_grid_bio(ij)-naux)*max3b - nauxd*tempb19
            nauxb = -(mud*tempb19) - mu*dnaux*max3b
            mudb = (n_grid_bio(ij)-naux)*tempb19
            nauxdb = -(mu*tempb19)
          END IF
          nauxb = nauxb + n_in_biob
          nauxdb = nauxdb + n_in_biodb
          CALL POPREAL8(naux)
          mub = mub + EXP(-mu)*n_grid_bio(ij)*nauxb - EXP(-mu)*mud*&
&           n_grid_bio(ij)*nauxdb
          CALL POPREAL8(nauxd)
          mudb = mudb + n_grid_bio(ij)*EXP(-mu)*nauxdb
          CALL POPREAL8(mu)
          CALL POPREAL8(mud)
          tempb18 = alpha_bio*mudb
          n_inb = n_inb + h_frac_biod*tempb18 + alpha_bio*h_frac_bio*mub
          h_frac_biob = h_frac_biob + n_ind*tempb18 + alpha_bio*n_in*mub
          n_indb = n_indb + h_frac_bio*tempb18
          h_frac_biodb = h_frac_biodb + n_in*tempb18
        END DO
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          n_in_sootb = 0.0_8
          n_in_sootdb = 0.0_8
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(n_in_soot)
          CALL POPREAL8(n_in_sootd)
          result1b = n_in_sootd*n_in_sootdb + n_in_soot*n_in_sootb
          n_in_sootb = result1*n_in_sootb
          n_in_sootdb = result1*n_in_sootdb
          arg2 = -temp_max_soot_degc + 10d0
          arg10 = -(temperature_k-273.15d0)
          CALL POPREAL8(result1)
          CALL POPREAL8(dh1smooth)
          dh1smoothb = 0.0_8
          CALL H_1_SMOOTH_B(arg10, arg10b, arg12, arg1b1, arg2, arg2b, &
&                     0d0, 1d0, result1b)
          temperature_kb = temperature_kb - arg10b
        END IF
        DO ij=ijstop_soot,1,-1
          nauxb = n_in_sootb
          nauxdb = n_in_sootdb
          mu = n_in*alpha_soot*h_frac_soot*pie*d_grid_soot(ij)**2./&
&           base_soot_philic_omega
          CALL POPREAL8(naux)
          mub = EXP(-mu)*n_grid_soot(ij)*nauxb - EXP(-mu)*n_grid_soot(ij&
&           )*mud*nauxdb
          CALL POPREAL8(nauxd)
          tempb13 = EXP(-mu)*nauxdb
          n_grid_sootb(ij) = n_grid_sootb(ij) + mud*tempb13 + (1.-EXP(-&
&           mu))*nauxb
          mudb = n_grid_soot(ij)*tempb13
          CALL POPREAL8(mu)
          tempb14 = alpha_soot*pie*mub
          tempb15 = d_grid_soot(ij)**2.*tempb14/base_soot_philic_omega
          CALL POPREAL8(mud)
          tempb17 = alpha_soot*pie*mudb
          d_grid_sootb(ij) = d_grid_sootb(ij) + (n_ind*h_frac_soot+n_in*&
&           h_frac_sootd)*2.*d_grid_soot(ij)*tempb17/&
&           base_soot_philic_omega + n_in*h_frac_soot*2.*d_grid_soot(ij)&
&           *tempb14/base_soot_philic_omega
          tempb16 = d_grid_soot(ij)**2.*tempb17/base_soot_philic_omega
          n_inb = n_inb + h_frac_sootd*tempb16 + h_frac_soot*tempb15
          h_frac_sootb = h_frac_sootb + n_ind*tempb16 + n_in*tempb15
          n_indb = n_indb + h_frac_soot*tempb16
          h_frac_sootdb = h_frac_sootdb + n_in*tempb16
        END DO
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          n_in_dustdb = 0.0_8
          n_in_dustb = 0.0_8
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(n_in_dust)
          CALL POPREAL8(n_in_dustd)
          result1b = n_in_dustd*n_in_dustdb + n_in_dust*n_in_dustb
          n_in_dustb = result1*n_in_dustb
          n_in_dustdb = result1*n_in_dustdb
          arg2 = -temp_max_dust_degc + 20d0
          arg10 = -(temperature_k-273.15d0)
          CALL POPREAL8(result1)
          CALL POPREAL8(dh1smooth)
          dh1smoothb = 0.0_8
          CALL H_1_SMOOTH_B(arg10, arg10b, arg11, arg1b0, arg2, arg2b, &
&                     0d0, 1d0, result1b)
          temperature_kb = temperature_kb - arg10b
        END IF
        DO ij=ijstop_dust,1,-1
          max1b = dn_in_dustb
          max1db = dn_in_dustdb
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            mu = n_in*alpha_dust*h_frac_dust*pie*d_grid_dust(ij)*&
&             d_grid_dust(ij)/base_dust_omega
            nauxb = 0.0_8
            mudb = 0.0_8
            nauxdb = 0.0_8
            mub = 0.0_8
          ELSE
            tempb11 = (mud*(dnaux+dh_frac_dust)+mu*dh_frac_dustd)*max1db
            tempb12 = (n_grid_dust(ij)-naux)*max1db
            tempb9 = mu*(dnaux+dh_frac_dust)*max1b
            tempb10 = (n_grid_dust(ij)-naux)*max1b
            n_grid_dustb(ij) = n_grid_dustb(ij) + tempb11 + tempb9
            nauxb = -tempb11 - tempb9
            mub = dh_frac_dustd*tempb12 - (dnaux+dh_frac_dust)*nauxd*&
&             max1db + (dnaux+dh_frac_dust)*tempb10
            dh_frac_dustb = dh_frac_dustb + mud*tempb12 - mu*nauxd*&
&             max1db + mu*tempb10
            mudb = (dnaux+dh_frac_dust)*tempb12
            dh_frac_dustdb = dh_frac_dustdb + mu*tempb12
            nauxdb = -((dnaux+dh_frac_dust)*mu*max1db)
          END IF
          nauxb = nauxb + n_in_dustb
          nauxdb = nauxdb + n_in_dustdb
          CALL POPREAL8(naux)
          mub = mub + EXP(-mu)*n_grid_dust(ij)*nauxb - EXP(-mu)*&
&           n_grid_dust(ij)*mud*nauxdb
          CALL POPREAL8(nauxd)
          tempb4 = EXP(-mu)*nauxdb
          n_grid_dustb(ij) = n_grid_dustb(ij) + mud*tempb4 + (1.-EXP(-mu&
&           ))*nauxb
          mudb = mudb + n_grid_dust(ij)*tempb4
          CALL POPREAL8(mu)
          tempb5 = alpha_dust*pie*mub
          tempb6 = d_grid_dust(ij)**2*tempb5/base_dust_omega
          CALL POPREAL8(mud)
          tempb8 = alpha_dust*pie*mudb
          d_grid_dustb(ij) = d_grid_dustb(ij) + (n_ind*h_frac_dust+n_in*&
&           h_frac_dustd)*2*d_grid_dust(ij)*tempb8/base_dust_omega + &
&           n_in*h_frac_dust*2*d_grid_dust(ij)*tempb5/base_dust_omega
          tempb7 = d_grid_dust(ij)**2*tempb8/base_dust_omega
          n_inb = n_inb + h_frac_dustd*tempb7 + h_frac_dust*tempb6
          h_frac_dustb = h_frac_dustb + n_ind*tempb7 + n_in*tempb6
          n_indb = n_indb + h_frac_dust*tempb7
          h_frac_dustdb = h_frac_dustdb + n_in*tempb7
        END DO
        CALL POPCONTROL2B(branch)
        IF (branch .EQ. 0) THEN
          n_in_maxb = n_inb
          n_indb = 0.0_8
          n_inb = 0.0_8
        ELSE IF (branch .EQ. 1) THEN
          n_in_maxb = 0.0_8
        ELSE
          ss_iwb = 0.0_8
          GOTO 100
        END IF
        n_in_hatb = pwr1d*n_indb + pwr1*n_inb
        pwr1b = n_in_hatd*n_indb + n_in_hat*n_inb
        n_in_hatdb = pwr1*n_indb
        pwr1db = n_in_hat*n_indb
        IF (pwx1 .LE. 0.0 .AND. (result1 .EQ. 0.0 .OR. result1 .NE. INT(&
&           result1))) THEN
          pwx1b = 0.0
        ELSE
          pwx1b = result1*pwx1**(result1-1)*pwr1b
        END IF
        IF (pwx1 .LE. 0.0) THEN
          result1b = 0.0
        ELSE
          result1b = pwx1**result1*LOG(pwx1)*pwr1b
        END IF
        CALL POPCONTROL2B(branch)
        IF (branch .EQ. 0) THEN
          tempb3 = result1*pwx1d*pwr1db
          temp0 = pwx1**(result1-1)
          IF (.NOT.(pwx1 .LE. 0.0 .AND. (result1 - 1 .EQ. 0.0 .OR. &
&             result1 - 1 .NE. INT(result1 - 1)))) pwx1b = pwx1b + (&
&             result1-1)*pwx1**(result1-2)*tempb3
          IF (pwx1 .LE. 0.0) THEN
            result1b = result1b + temp0*pwx1d*pwr1db
          ELSE
            result1b = result1b + temp0*pwx1d*pwr1db + temp0*LOG(pwx1)*&
&             tempb3
          END IF
          pwx1db = temp0*result1*pwr1db
        ELSE IF (branch .EQ. 1) THEN
          pwx1db = pwr1db
        ELSE
          pwx1db = 0.0_8
        END IF
        tempb2 = pwx1db/n_in_hat**2
        arg10 = -(temperature_k-273.15d0)
        CALL POPREAL8(result1)
        CALL POPREAL8(dh1smooth)
        dh1smoothb = 0.0_8
        CALL H_1_SMOOTH_B(arg10, arg10b, 25d0, dummydiffb17, 35d0, &
&                   dummydiffb18, 0d0, 1d0, result1b)
        temperature_kb = temperature_kb - arg10b
        n_in_tildeb = pwx1b/n_in_hat - n_in_hatd*tempb2
        n_in_hatb = n_in_hatb + (n_in_tilded-(n_in_tilded*n_in_hat-&
&         n_in_tilde*n_in_hatd)*2/n_in_hat)*tempb2 - n_in_tilde*pwx1b/&
&         n_in_hat**2
        n_in_tildedb = n_in_hat*tempb2
        n_in_hatdb = n_in_hatdb - n_in_tilde*tempb2
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          n_in_maxb = n_in_maxb + n_in_tildeb
          n_in_tildedb = 0.0_8
          n_in_tildeb = 0.0_8
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          n_in_maxb = n_in_maxb + n_in_hatb
          n_in_hatdb = 0.0_8
          n_in_hatb = 0.0_8
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          arg1 = 0.1296*(ss_iw*100.-10.)
          arg1b = 0.3*EXP(arg1)**(-0.7)*fac_correct_rh*1000.*EXP(arg1)*&
&           n_in_maxb/rho_cfdc
          ss_iwb = 0.1296*100.*arg1b
          n_in_maxb = 0.0_8
        ELSE
          ss_iwb = 0.0_8
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) ss_iwb = ss_iwb + EXP(12.96*ss_iw-0.639)*&
&           fac_correct_rh*0.0587*1.e3*12.96*n_in_maxb/rho_cfdc
        n_inb = n_in_hatb
        n_indb = n_in_hatdb
        arg1 = 0.1296*(ss_i*100.-10.)
        arg1d = 0.1296*100.*ss_id
        temp = EXP(arg1)
        tempb1 = fac_correct_rh*arg1d*0.3*1000.*n_in_tildedb
        arg1b = (temp**(-0.7)*EXP(arg1)/rho_cfdc-0.7*temp**(-1.7)*EXP(&
&         arg1)**2/rho_cfdc)*tempb1 + 0.3*EXP(arg1)**(-0.7)*&
&         fac_correct_rh*1000.*EXP(arg1)*n_in_tildeb/rho_cfdc
        ss_ib = ss_ib + 0.1296*100.*arg1b
 100    CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          n_indb = 0.0_8
          n_inb = 0.0_8
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(n_in)
          CALL POPREAL8(n_ind)
          result1b = n_ind*n_indb + n_in*n_inb
          n_inb = result1*n_inb
          n_indb = result1*n_indb
          arg10 = -(temperature_k-273.15d0)
          CALL POPREAL8(result1)
          CALL POPREAL8(dh1smooth)
          dh1smoothb = 0.0_8
          CALL H_1_SMOOTH_B(arg10, arg10b, 2.d0, dummydiffb15, 5.d0, &
&                     dummydiffb16, 0.d0, 1.d0, result1b)
          temperature_kb = temperature_kb - arg10b
        END IF
        ss_ib = ss_ib + EXP(12.96d0*ss_i-0.639)*fac_correct_rh*1.e3*&
&         0.0587*12.96d0**2*ss_id*n_indb/rho_cfdc + EXP(12.96d0*ss_i-&
&         0.639)*fac_correct_rh*0.0587*1.e3*12.96d0*n_inb/rho_cfdc
 110    h_frac_sootb = h_frac_sootb + h_frac_biob
        h_frac_sootdb = h_frac_sootdb + h_frac_biodb
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          h_frac_sootdb = 0.0_8
          h_frac_sootb = 0.0_8
        END IF
        dep_fracb = (1.0_8-aux)*h_frac_sootb - auxd*h_frac_sootdb
        auxb = (1.d0-dep_frac)*h_frac_sootb - dep_fracd*h_frac_sootdb
        dep_fracdb = (1.0_8-aux)*h_frac_sootdb
        auxdb = (1.d0-dep_frac)*h_frac_sootdb
        arg10 = ss_w + 1.0d0
        CALL POPREAL8(aux)
        CALL POPREAL8(auxd)
        CALL POPREAL8(dh1smooth)
        ss_wdb = 0.0_8
        dh1smoothb = 0.0_8
        dh1smoothdb = 0.0_8
        CALL H_1_SMOOTH_D_B(arg10, arg10b, ss_wd, ss_wdb, s_w_0, s_w_0b&
&                     , 1.d0, dummydiffb14, 0.d0, 1.d0, aux, auxb, auxdb&
&                    )
        ss_wb = arg10b
        result1b = aux*dep_fracb
        auxb = auxb + result1d*dep_fracdb + result1*dep_fracb
        result1db = aux*dep_fracdb
        arg2 = s_i_0 + 0.1d0
        arg10 = ss_i + 1d0
        CALL POPREAL8(result1d)
        CALL POPREAL8(dh1smooth)
        ss_idb = 0.0_8
        dh1smoothb = 0.0_8
        dh1smoothdb = 0.0_8
        CALL H_1_SMOOTH_D_B(arg10, arg10b, ss_id, ss_idb, s_i_0, s_i_0b&
&                     , arg2, arg2b, 0.d0, 1.d0, result1, result1b, &
&                     result1db)
        ss_ib = ss_ib + arg10b
        CALL POPREAL8(aux)
        result1b = result1b + auxb/fac_correct_rh
        arg10 = -(temperature_k-273.15d0)
        CALL POPREAL8(result1)
        CALL POPREAL8(dh1smooth)
        dh1smoothb = 0.0_8
        CALL H_1_SMOOTH_B(arg10, arg10b, 40.d0, dummydiffb12, 50.d0, &
&                   dummydiffb13, 0.d0, 1.d0, result1b)
        temperature_kb = temperature_kb - arg10b
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          h_frac_solob = 0.0_8
          h_frac_solodb = 0.0_8
        END IF
        dep_fracb = h_frac_solob
        dep_fracdb = h_frac_solodb
        CALL POPREAL8(dep_frac)
        result1b = aux*dep_fracb
        auxb = result1d*dep_fracdb + result1*dep_fracb
        CALL POPREAL8(dep_fracd)
        result1db = aux*dep_fracdb
        s_i_0 = 1.2d0
        arg2 = s_i_0 + 0.1d0
        arg10 = ss_i + 1d0
        CALL POPREAL8(result1)
        CALL POPREAL8(result1d)
        CALL POPREAL8(dh1smoothd)
        CALL POPREAL8(dh1smooth)
        ss_idb = 0.0_8
        dh1smoothb = 0.0_8
        dh1smoothdb = 0.0_8
        CALL H_1_SMOOTH_D_B(arg10, arg10b, ss_id, ss_idb, s_i_0, s_i_0b&
&                     , arg2, arg2b, 0d0, 1d0, result1, result1b, &
&                     result1db)
        ss_ib = ss_ib + arg10b
        arg10 = -(temperature_k-273.15d0)
        CALL POPREAL8(aux)
        CALL POPREAL8(dh1smooth)
        dh1smoothb = 0.0_8
        CALL H_1_SMOOTH_B(arg10, arg10b, 65d0, dummydiffb10, 75d0, &
&                   dummydiffb11, 0d0, 1d0, auxb)
        temperature_kb = temperature_kb - arg10b
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          tempb0 = dh_frac_dustdb/h_frac_dust**2
          CALL POPREAL8(dh_frac_dust)
          CALL POPREAL8(dh_frac_dustd)
          h_frac_dustb = h_frac_dustb + (dh_frac_dustd-(dh_frac_dustd*&
&           h_frac_dust-dh_frac_dust*h_frac_dustd)*2/h_frac_dust)*tempb0&
&           - dh_frac_dust*dh_frac_dustb/h_frac_dust**2
          dh_frac_dustb = dh_frac_dustb/h_frac_dust - h_frac_dustd*&
&           tempb0
          h_frac_dustdb = h_frac_dustdb - dh_frac_dust*tempb0
          dh_frac_dustdb = h_frac_dust*tempb0
        ELSE
          dh_frac_dustdb = 0.0_8
          dh_frac_dustb = 0.0_8
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          h_frac_dustb = 0.0_8
          h_frac_dustdb = 0.0_8
        END IF
        tempb = siw*dh_frac_dustdb
        dfdepb = (1.0_8-aux)*dh_frac_dustb - auxd*dh_frac_dustdb
        dep_fracb = (1.0_8-aux)*h_frac_dustb - auxd*h_frac_dustdb - &
&         dh1smoothd*tempb - siw*dh1smooth*dh_frac_dustb
        siwb = ((1.d0-dep_frac)*dh1smoothd-dep_fracd*dh1smooth)*&
&         dh_frac_dustdb + (1.d0-dep_frac)*dh1smooth*dh_frac_dustb
        auxb = (1.d0-dep_frac)*h_frac_dustb - dep_fracd*h_frac_dustdb - &
&         dfdepd*dh_frac_dustdb - dfdep*dh_frac_dustb
        dfdepdb = (1.0_8-aux)*dh_frac_dustdb
        dep_fracdb = (1.0_8-aux)*h_frac_dustdb - dh1smooth*tempb
        auxdb = (1.d0-dep_frac)*h_frac_dustdb - dfdep*dh_frac_dustdb
        s_w_0 = 0.97d0
        arg10 = ss_w + 1.0d0
        CALL POPREAL8(aux)
        CALL POPREAL8(dh1smoothd)
        CALL POPREAL8(dh1smooth)
        CALL H_1_SMOOTH_D_B(arg10, arg10b, ss_wd, ss_wdb, s_w_0, s_w_0b&
&                     , 1.d0, dummydiffb9, 0.d0, 1.d0, aux, auxb, auxdb)
        dh1smoothb = aux*dfdepb - dep_fracd*tempb + (1.d0-dep_frac)*siw*&
&         dh_frac_dustb
        dh1smoothdb = aux*dfdepdb + (1.d0-dep_frac)*tempb
        ss_wb = ss_wb + arg10b
        auxb = auxb + dh1smoothd*dfdepdb + result1d*dep_fracdb + result1&
&         *dep_fracb + dh1smooth*dfdepb
        result1b = result1b + aux*dep_fracb
        result1db = aux*dep_fracdb
        pwr1 = 10.**pwy1
        s_i_0 = 1d0 + pwr1
        arg2 = s_i_0 + 0.1d0
        arg10 = ss_i + 1d0
        CALL POPREAL8(dh1smooth)
        ss_idb = 0.0_8
        CALL H_1_SMOOTH_D_B(arg10, arg10b, ss_id, ss_idb, s_i_0, s_i_0b&
&                     , arg2, arg2b, 0d0, 1d0, result1, result1b, &
&                     result1db)
        s_i_0b = s_i_0b + arg2b
        ss_ib = ss_ib + arg10b
        result1b = result1b + auxb/fac_correct_rh
        arg10 = -(temperature_k-273.15d0)
        CALL POPREAL8(dh1smooth)
        CALL H_1_SMOOTH_D_B(arg10, arg10b, 0.0_8, dummydiffb6, 35d0, &
&                     dummydiffb7, 40d0, dummydiffb8, &
&                     fraction_depnucl_warm_dust, 1d0, result1, result1b&
&                     , resb2)
        temperature_kb = temperature_kb - arg10b
        pwr1b = s_i_0b
        pwy1b = 10.**pwy1*LOG(10.)*pwr1b
        tc_hm_degcb = (5.3938e-4*2*tc_hm_degc+8.2584e-6*3*tc_hm_degc**2+&
&         3.1656e-3)*pwy1b
        arg10 = ss_w + 1.0d0
        CALL POPREAL8(dh1smooth)
        delta_swb = 0.0_8
        CALL H_1_SMOOTH_D_B(arg10, arg10b, ss_wd, ss_wdb, 0.97d0, &
&                     dummydiffb4, 1d0, dummydiffb5, 0d0, 1d0, delta_sw&
&                     , delta_swb, resb1)
        ss_wb = ss_wb + arg10b
        arg10 = -(temperature_k-273.15)
        CALL POPREAL8(dh1smooth)
        delta_tb = 0.0_8
        CALL H_1_SMOOTH_D_B(arg10, arg10b, 0.0_8, dummydiffb1, 35d0, &
&                     dummydiffb2, 40d0, dummydiffb3, &
&                     fraction_depnucl_warm_dust, 1d0, delta_t, delta_tb&
&                     , resb0)
        temperature_kb = temperature_kb + tc_hm_degcb - arg10b
        arg10 = ss_i + 1d0
        CALL POPREAL8(dh1smooth)
        ss_idb = 0.0_8
        delta_sib = 0.0_8
        CALL H_1_SMOOTH_D_B(arg10, arg10b, ss_id, ss_idb, 1.1d0, &
&                     dummydiffb, 1.2d0, dummydiffb0, 0.0d0, 1d0, &
&                     delta_si, delta_sib, resb)
        ss_ib = ss_ib + arg10b
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          ss_iwb = ss_iwb + ss_ib
          ss_ib = 0.0_8
          ss_wb = 0.0_8
          ss_wdb = 0.0_8
        END IF
      ELSE IF (branch .EQ. 2) THEN
        n_grid_sootb = 0.0_8
        d_grid_sootb = 0.0_8
        n_grid_dustb = 0.0_8
        d_grid_dustb = 0.0_8
        siwb = 0.0_8
        ss_wb = 0.0_8
        ss_iwb = 0.0_8
        psi_solob = 0.0_8
        ss_wdb = 0.0_8
      ELSE
        n_grid_sootb = 0.0_8
        d_grid_sootb = 0.0_8
        n_grid_dustb = 0.0_8
        d_grid_dustb = 0.0_8
        siwb = 0.0_8
        ss_wb = 0.0_8
        ss_iwb = 0.0_8
        psi_solob = 0.0_8
        ss_wdb = 0.0_8
      END IF
      siwb = siwb + ss_iwb
      swb = ss_wb
      swdb = ss_wdb
      sib = ss_ib
      a_solob = psi_solob/base_solo_omega
    END IF
  END SUBROUTINE EMPIRICAL_PARAM_PHILLIPS_D_B
!  Differentiation of empirical_param_phillips in forward (tangent) mode:
!   variations   of useful results: dsh n_iw
!   with respect to varying inputs: si sw
!=======================================================================================
!=======================================================================================
!=======================================================================================
!!====================================================================================
!		EMPIRICAL PARAMETERISATION (Phillips et al. 2013, JAS)
!		contributed by Vaughan Phillips, 2012
!		University of Leeds
! Implementation:   Donifan Barahona donifan.o.barahona@nasa.gov 
!====================================================================================
  SUBROUTINE EMPIRICAL_PARAM_PHILLIPS_D(temperature_k, p_sat, si, sid, &
&   siw, sw, swd, d_grid_dust, n_grid_dust, ijstop_dust, d_grid_soot, &
&   n_grid_soot, ijstop_soot, d_grid_bio, n_grid_bio, ijstop_bio, a_solo&
&   , n_iw, n_iwd, dsh, dshd)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: temperature_k, p_sat, si, siw, sw, a_solo
    REAL*8, INTENT(IN) :: sid, swd
    REAL*8, DIMENSION(2), INTENT(IN) :: d_grid_dust, n_grid_dust
    REAL*8, DIMENSION(1), INTENT(IN) :: d_grid_soot, n_grid_soot, &
&   d_grid_bio, n_grid_bio
    INTEGER, INTENT(IN) :: ijstop_dust, ijstop_soot, ijstop_bio
    REAL*8 :: nin_a_nuc_dust, nin_a_nuc_soot, nin_a_nuc_bio, &
&   nin_a_nuc_solo, num_ic_dust_imm, num_ic_soot_imm, num_ic_bio_imm, &
&   num_ic_solo_imm
!DONIF
    REAL*8, INTENT(INOUT) :: dsh, n_iw
    REAL*8, INTENT(INOUT) :: dshd, n_iwd
!DONIF
    REAL*8 :: dn_in_dust, dn_in_soot, dn_in_bio, dn_in_solo, dnall, &
&   dnaux, naux, ss_w, dh_frac_dust, dh_frac_soot, dh_frac_solo, aux, &
&   dfdep
    REAL*8 :: dn_in_dustd, dn_in_biod, dnalld, nauxd, ss_wd, &
&   dh_frac_dustd, auxd, dfdepd
    REAL*8 :: rho_cfdc, base_dust_omega, base_soot_philic_omega, &
&   base_bio_omega, alpha_dust, alpha_soot, alpha_bio, &
&   fraction_depnucl_warm_dust, pie, base_solo_omega, temp_max_dust_degc&
&   , temp_max_soot_degc, temp_max_bio_degc, glass_frac
    PARAMETER (base_dust_omega=2.0d-6, base_soot_philic_omega=1.0d-7, &
&   base_bio_omega=0.89d-6, base_solo_omega=5.6d-5, glass_frac=0.5d0, &
&   alpha_dust=2d0/3d0, alpha_soot=1d0/3d0-0.03d0, alpha_bio=0.03d0, &
&   rho_cfdc=50000d0/(287d0*228.15d0), fraction_depnucl_warm_dust=0.15d0&
&   , pie=3.1415926d0, temp_max_dust_degc=-10d0, temp_max_soot_degc=-&
&     15d0, temp_max_bio_degc=-2d0)
    REAL*8, SAVE :: fac_correct_rh=2d0, rho_aida
    REAL*8 :: h_frac_dust, n_in, n_in_dust, n_in_ultra, n_in_dust_ultra&
&   , cihenc_dust, esw, esi, ss_i, n_in_soot_ultra, h_frac_soot, &
&   h_frac_bio, n_in_soot, n_in_bio, n_in_bio_ultra, cihenc_soot, &
&   cihenc_bio, delta_si, delta_t, delta_sw, n_in_max, ss_iw, rho
    REAL*8 :: h_frac_dustd, n_ind, n_in_dustd, n_in_ultrad, &
&   n_in_dust_ultrad, cihenc_dustd, ss_id, n_in_soot_ultrad, &
&   h_frac_sootd, h_frac_biod, n_in_sootd, n_in_biod, n_in_bio_ultrad, &
&   cihenc_sootd, cihenc_biod
    REAL*8 :: h_frac_solo, rhi, n_in_solo, n_in_solo_star, cihenc_solo, &
&   psi_solo
    REAL*8 :: h_frac_solod, rhid, n_in_solod, n_in_solo_stard, &
&   cihenc_solod
    REAL*8 :: mu, s_i_0, rh_crit, s_i_w_warm, s_i_w_cold, s_i_w, &
&   tc_hm_degc
    REAL*8 :: mud
    REAL*8 :: s_w_0, dep_frac, n_in_hat, n_in_tilde
    REAL*8 :: dep_fracd, n_in_hatd, n_in_tilded
    REAL*8, SAVE :: eps=0.622d0
    INTEGER :: ij
    INTRINSIC SIZE
    INTRINSIC EXP
    INTRINSIC MAX
    INTRINSIC MIN
    REAL*8 :: pwy1
    REAL*8 :: pwr1
    REAL*8 :: pwr1d
    REAL*8 :: result1
    REAL*8 :: result1d
    REAL*8 :: arg1
    REAL*8 :: arg1d
    REAL*8 :: pwx1
    REAL*8 :: pwx1d
    REAL*8 :: x2
    REAL*8 :: x2d
    REAL*8 :: x1
    REAL*8 :: max1d
    REAL*8 :: max4d
    REAL*8 :: dumm
    REAL*8 :: dumm2
    REAL*8 :: dumm1
    REAL*8 :: dumm0
    REAL*8 :: max3d
    REAL*8 :: max6
    REAL*8 :: max6d
    REAL*8 :: max5
    REAL*8 :: max4
    REAL*8 :: max3
    REAL*8 :: max2
    REAL*8 :: max1
    INTRINSIC INT
    REAL*8 :: arg10
    REAL*8 :: arg2
!intrinsic :: exp, DEXP, SIZE, DBLE
!print *, SIZE(n_grid_dust(:))
    IF (ijstop_dust .NE. SIZE(n_grid_dust)) THEN
      STOP
    ELSE IF (ijstop_soot .NE. SIZE(n_grid_soot)) THEN
      STOP
    ELSE IF (ijstop_bio .NE. SIZE(n_grid_bio)) THEN
      STOP
    ELSE
!default
      dnaux = 12.96
      naux = 0.0
      dnall = dnaux
      dsh = 0.0
      n_iw = 0.0
      nin_a_nuc_dust = 0.0
      nin_a_nuc_soot = 0.0
      nin_a_nuc_bio = 0.0
      nin_a_nuc_solo = 0.0
      num_ic_dust_imm = 0.0
      num_ic_soot_imm = 0.0
      num_ic_bio_imm = 0.0
      num_ic_solo_imm = 0.0
      dn_in_dust = 0.0
      dn_in_soot = 0.0
      dn_in_bio = 0.0
      dn_in_solo = 0.0
      dh_frac_dust = 0.0
      dh_frac_soot = 0.0
      dh_frac_solo = 0.0
      dh1smooth = 0.0
      aux = 0.0
!====================================================================================
!		COMPUTATION BLOCK 
!
!====================================================================================
!
      rho_aida = 90000./(287.*205.)
      rho = p_sat/(287.*temperature_k)
      psi_solo = a_solo/base_solo_omega
!everything is based on supersaturation 
      ss_id = sid
      ss_i = si - 1.0
      ss_wd = swd
      ss_w = sw - 1.0
      ss_iw = siw - 1.0
      IF (ss_i .GT. 0.0d0) THEN
        IF (temperature_k .LT. 273.15d0 .AND. temperature_k .GT. 273.15 &
&           - 90.) THEN
!SS_iw = QSW/QSI - 1.
          IF (ss_w .GT. 0.) THEN
            ss_i = ss_iw
            ss_w = 0.0
            ss_id = 0.0_8
            ss_wd = 0.0_8
          END IF
!				S_i_zero = 1.15 !this is taken care of
          dh1smoothd = 0.0_8
          arg10 = ss_i + 1d0
          dumm = H_1_SMOOTH_D(arg10, ss_id, 1.1d0, 1.2d0, 0.0d0, 1d0, &
&           delta_si)
          arg10 = -(temperature_k-273.15)
          dumm0 = H_1_SMOOTH_D(arg10, 0.0_8, 35d0, 40d0, &
&           fraction_depnucl_warm_dust, 1d0, delta_t)
          arg10 = ss_w + 1.0d0
          dumm1 = H_1_SMOOTH_D(arg10, ss_wd, 0.97d0, 1d0, 0d0, 1d0, &
&           delta_sw)
          tc_hm_degc = temperature_k - 273.15d0
          pwy1 = 8.2584e-6*tc_hm_degc*tc_hm_degc*tc_hm_degc + 5.3938e-4*&
&           tc_hm_degc*tc_hm_degc + 3.1656e-3*tc_hm_degc - 1.0261d0
          pwr1 = 10.**pwy1
          s_i_0 = 1d0 + pwr1
          s_w_0 = 0.97d0
          s_w_0 = 0.97d0
          arg10 = -(temperature_k-273.15d0)
          dumm2 = H_1_SMOOTH_D(arg10, 0.0_8, 35d0, 40d0, &
&           fraction_depnucl_warm_dust, 1d0, result1)
          aux = result1/fac_correct_rh
          arg10 = ss_i + 1d0
          arg2 = s_i_0 + 0.1d0
          result1d = H_1_SMOOTH_D(arg10, ss_id, s_i_0, arg2, 0d0, 1d0, &
&           result1)
          dep_fracd = aux*result1d
          dep_frac = result1*aux
          dfdepd = aux*dh1smoothd
          dfdep = dh1smooth*aux
          arg10 = ss_w + 1.0d0
          auxd = H_1_SMOOTH_D(arg10, ss_wd, s_w_0, 1.d0, 0.d0, 1.d0, aux&
&           )
          h_frac_dustd = dep_fracd + (1.d0-dep_frac)*auxd - dep_fracd*&
&           aux
          h_frac_dust = dep_frac + (1.d0-dep_frac)*aux
          dh_frac_dustd = dfdepd + siw*((1.d0-dep_frac)*dh1smoothd-&
&           dep_fracd*dh1smooth) - auxd*dfdep - aux*dfdepd
          dh_frac_dust = dfdep + siw*(1.d0-dep_frac)*dh1smooth - aux*&
&           dfdep
          IF (h_frac_dust .GT. 1.d0) THEN
            h_frac_dust = 1.d0
            h_frac_dustd = 0.0_8
          END IF
          IF (h_frac_dust .GT. 1.0e-6 .AND. h_frac_dust .LT. 1.d0) THEN
            dh_frac_dustd = (dh_frac_dustd*h_frac_dust-dh_frac_dust*&
&             h_frac_dustd)/h_frac_dust**2
            dh_frac_dust = dh_frac_dust/h_frac_dust
          ELSE
            dh_frac_dust = 0.0d0
            dh_frac_dustd = 0.0_8
          END IF
!soluble organics
          s_i_0 = 1.2d0
          arg10 = -(temperature_k-273.15d0)
          aux = H_1_SMOOTH(arg10, 65d0, 75d0, 0d0, 1d0)
          dh1smoothd = 0.0_8
          arg10 = ss_i + 1d0
          arg2 = s_i_0 + 0.1d0
          result1d = H_1_SMOOTH_D(arg10, ss_id, s_i_0, arg2, 0d0, 1d0, &
&           result1)
          dep_fracd = aux*result1d
          dep_frac = result1*aux
          h_frac_solod = dep_fracd
          h_frac_solo = dep_frac
          dh_frac_solo = 0.0d0
          IF (h_frac_solo .GT. 1.0e-6 .AND. h_frac_solo .LT. 1.d0) &
&           dh_frac_solo = dh1smooth/h_frac_solo
          IF (h_frac_solo .GT. 1.d0) THEN
            h_frac_solo = 1.d0
            h_frac_solod = 0.0_8
          END IF
          s_w_0 = 0.97d0
          s_i_0 = 1.3d0
          arg10 = -(temperature_k-273.15d0)
          result1 = H_1_SMOOTH(arg10, 40.d0, 50.d0, 0.d0, 1.d0)
          aux = result1/fac_correct_rh
          dh1smoothd = 0.0_8
          arg10 = ss_i + 1d0
          arg2 = s_i_0 + 0.1d0
          result1d = H_1_SMOOTH_D(arg10, ss_id, s_i_0, arg2, 0.d0, 1.d0&
&           , result1)
          dep_fracd = aux*result1d
          dep_frac = result1*aux
          dfdep = dh1smooth*aux
          dh1smoothd = 0.0_8
          arg10 = ss_w + 1.0d0
          auxd = H_1_SMOOTH_D(arg10, ss_wd, s_w_0, 1.d0, 0.d0, 1.d0, aux&
&           )
          h_frac_sootd = dep_fracd + (1.d0-dep_frac)*auxd - dep_fracd*&
&           aux
          h_frac_soot = dep_frac + (1.d0-dep_frac)*aux
          IF (h_frac_soot .GT. 1.d0) THEN
            h_frac_soot = 1.d0
            h_frac_sootd = 0.0_8
          END IF
          dh_frac_soot = dfdep + siw*(1d0-dep_frac)*dh1smooth - aux*&
&           dfdep
          IF (h_frac_soot .GT. 1.0e-6 .AND. h_frac_soot .LT. 1.d0) THEN
            dh_frac_soot = dh_frac_soot/h_frac_soot
          ELSE
            dh_frac_soot = 0.0d0
          END IF
          h_frac_biod = h_frac_sootd
          h_frac_bio = h_frac_soot
          IF (temperature_k .LT. 273.15d0 .AND. temperature_k .GE. &
&             273.15d0 - 35.d0) THEN
            n_ind = 1.e3*0.0587*fac_correct_rh*12.96d0*ss_id*EXP(12.96d0&
&             *ss_i-0.639)/rho_cfdc
            n_in = 1.e3*(EXP(12.96d0*ss_i-0.639)/rho_cfdc)*0.0587*&
&             fac_correct_rh
            IF (temperature_k .GT. 273.15 - 5. .AND. temperature_k .LT. &
&               273.15 - 2.) THEN
              arg10 = -(temperature_k-273.15d0)
              result1 = H_1_SMOOTH(arg10, 2.d0, 5.d0, 0.d0, 1.d0)
              n_ind = result1*n_ind
              n_in = n_in*result1
            END IF
            IF (temperature_k .GE. 273.15 - 2.d0) THEN
              n_in = 0.d0
              n_ind = 0.0_8
            END IF
            IF (temperature_k .LT. 273.15d0 - 25.d0) THEN
              arg1d = 0.1296*100.*ss_id
              arg1 = 0.1296*(ss_i*100.-10.)
              n_in_tilded = 1000.*fac_correct_rh*0.3*EXP(arg1)**(-0.7)*&
&               arg1d*EXP(arg1)/rho_cfdc
              n_in_tilde = 1000.*EXP(arg1)**0.3*fac_correct_rh/rho_cfdc
              n_in_hatd = n_ind
              n_in_hat = n_in
              IF (temperature_k .GE. 273.15 - 30.) n_in_max = 1.e3*(EXP(&
&                 12.96*ss_iw-0.639)/rho_cfdc)*0.0587*fac_correct_rh
              IF (temperature_k .LT. 273.15 - 30.) THEN
                arg1 = 0.1296*(ss_iw*100.-10.)
                n_in_max = 1000.*EXP(arg1)**0.3*fac_correct_rh/rho_cfdc
              END IF
              IF (n_in_hat .GT. n_in_max) THEN
                n_in_hat = n_in_max
                n_in_hatd = 0.0_8
              END IF
              IF (n_in_tilde .GT. n_in_max) THEN
                n_in_tilde = n_in_max
                n_in_tilded = 0.0_8
              END IF
              pwx1d = (n_in_tilded*n_in_hat-n_in_tilde*n_in_hatd)/&
&               n_in_hat**2
              pwx1 = n_in_tilde/n_in_hat
              arg10 = -(temperature_k-273.15d0)
              result1 = H_1_SMOOTH(arg10, 25d0, 35d0, 0d0, 1d0)
              IF (pwx1 .GT. 0.0 .OR. (pwx1 .LT. 0.0 .AND. result1 .EQ. &
&                 INT(result1))) THEN
                pwr1d = result1*pwx1**(result1-1)*pwx1d
              ELSE IF (pwx1 .EQ. 0.0 .AND. result1 .EQ. 1.0) THEN
                pwr1d = pwx1d
              ELSE
                pwr1d = 0.0
              END IF
              pwr1 = pwx1**result1
              n_ind = n_in_hatd*pwr1 + n_in_hat*pwr1d
              n_in = n_in_hat*pwr1
              IF (n_in .GT. n_in_max) THEN
                n_in = n_in_max
                n_ind = 0.0_8
              END IF
            END IF
            n_in_dust = 0.
            dn_in_dust = 0.
            IF (temperature_k .LT. 273.15 - 30.) THEN
!DONIF
!this is a simplified derivative of dNds
              dnaux = 3.88
            ELSE
              dnaux = 12.96
            END IF
            naux = 0.0
            dn_in_dustd = 0.0_8
            n_in_dustd = 0.0_8
            DO ij=1,ijstop_dust
              mud = alpha_dust*pie*d_grid_dust(ij)**2*(n_ind*h_frac_dust&
&               +n_in*h_frac_dustd)/base_dust_omega
              mu = n_in*alpha_dust*h_frac_dust*pie*d_grid_dust(ij)*&
&               d_grid_dust(ij)/base_dust_omega
              nauxd = n_grid_dust(ij)*mud*EXP(-mu)
              naux = (1.-EXP(-mu))*n_grid_dust(ij)
              n_in_dustd = n_in_dustd + nauxd
              n_in_dust = n_in_dust + naux
              IF (mu*(n_grid_dust(ij)-naux)*(dnaux+dh_frac_dust) .LT. &
&                 0.0) THEN
                max1 = 0.0
                max1d = 0.0_8
              ELSE
                max1d = (mud*(dnaux+dh_frac_dust)+mu*dh_frac_dustd)*(&
&                 n_grid_dust(ij)-naux) - mu*(dnaux+dh_frac_dust)*nauxd
                max1 = mu*(n_grid_dust(ij)-naux)*(dnaux+dh_frac_dust)
              END IF
              dn_in_dustd = max1d + dn_in_dustd
              dn_in_dust = max1 + dn_in_dust
            END DO
            IF (temperature_k .GT. 273.15 + temp_max_dust_degc - 20. &
&               .AND. temperature_k .LT. 273.15 + temp_max_dust_degc) &
&           THEN
              arg10 = -(temperature_k-273.15d0)
              arg2 = -temp_max_dust_degc + 20d0
              result1 = H_1_SMOOTH(arg10, -temp_max_dust_degc, arg2, 0d0&
&               , 1d0)
              n_in_dustd = result1*n_in_dustd
              n_in_dust = n_in_dust*result1
            END IF
            IF (temperature_k .GE. 273.15 + temp_max_dust_degc) THEN
              n_in_dust = 0.
              n_in_dustd = 0.0_8
            END IF
            n_in_soot = 0.
            dn_in_soot = 0.
            n_in_sootd = 0.0_8
            DO ij=1,ijstop_soot
              mud = alpha_soot*pie*d_grid_soot(ij)**2.*(n_ind*&
&               h_frac_soot+n_in*h_frac_sootd)/base_soot_philic_omega
              mu = n_in*alpha_soot*h_frac_soot*pie*d_grid_soot(ij)**2./&
&               base_soot_philic_omega
              nauxd = n_grid_soot(ij)*mud*EXP(-mu)
              naux = (1.-EXP(-mu))*n_grid_soot(ij)
              n_in_sootd = n_in_sootd + nauxd
              n_in_soot = n_in_soot + naux
              IF (mu*(n_grid_soot(ij)-naux)*(dnaux+dh_frac_soot) .LT. &
&                 0.0) THEN
                max2 = 0.0
              ELSE
                max2 = mu*(n_grid_soot(ij)-naux)*(dnaux+dh_frac_soot)
              END IF
              dn_in_soot = max2 + dn_in_soot
            END DO
            IF (temperature_k .GT. 273.15 + temp_max_soot_degc - 10. &
&               .AND. temperature_k .LT. 273.15 + temp_max_soot_degc) &
&           THEN
              arg10 = -(temperature_k-273.15d0)
              arg2 = -temp_max_soot_degc + 10d0
              result1 = H_1_SMOOTH(arg10, -temp_max_soot_degc, arg2, 0d0&
&               , 1d0)
              n_in_sootd = result1*n_in_sootd
              n_in_soot = n_in_soot*result1
            END IF
            IF (temperature_k .GE. 273.15 + temp_max_soot_degc) THEN
              n_in_soot = 0.
              n_in_sootd = 0.0_8
            END IF
            n_in_bio = 0.
            dn_in_bio = 0.
            n_in_biod = 0.0_8
            dn_in_biod = 0.0_8
            DO ij=1,ijstop_bio
              mu = n_in*alpha_bio*h_frac_bio*pie*d_grid_bio(ij)**2./&
&               base_bio_omega
              mud = alpha_bio*(n_ind*h_frac_bio+n_in*h_frac_biod)
              mu = n_in*alpha_bio*h_frac_bio
              nauxd = n_grid_bio(ij)*mud*EXP(-mu)
              naux = (1.-EXP(-mu))*n_grid_bio(ij)
!!!!!!!!!!!!!!remember!!!!!!!!!!!!!!!!
!naux =  n_in*ALPHA_bio*H_frac_bio
!!!!!!!!!!!!!!remember!!!!!!!!!!!!!!!!
              n_in_biod = n_in_biod + nauxd
              n_in_bio = n_in_bio + naux
              IF (mu*(n_grid_bio(ij)-naux)*dnaux .LT. 0.0) THEN
                max3 = 0.0
                max3d = 0.0_8
              ELSE
                max3d = dnaux*(mud*(n_grid_bio(ij)-naux)-mu*nauxd)
                max3 = mu*(n_grid_bio(ij)-naux)*dnaux
              END IF
              dn_in_biod = max3d + dn_in_biod
              dn_in_bio = max3 + dn_in_bio
            END DO
            IF (temperature_k .GT. 273.15 + temp_max_bio_degc - 3. .AND.&
&               temperature_k .LT. 273.15 + temp_max_bio_degc) THEN
              arg10 = -(temperature_k-273.15d0)
              arg2 = -temp_max_bio_degc + 3d0
              result1 = H_1_SMOOTH(arg10, -temp_max_bio_degc, arg2, 0d0&
&               , 1d0)
              n_in_biod = result1*n_in_biod
              n_in_bio = n_in_bio*result1
            END IF
            IF (temperature_k .GE. 273.15 + temp_max_bio_degc) THEN
              n_in_bio = 0d0
              n_in_biod = 0.0_8
            END IF
          ELSE
            n_in = 0.
            n_in_ultra = 0.
            n_in_dust = 0.
            n_in_soot = 0.
            n_in_bio = 0.
            n_in_sootd = 0.0_8
            n_in_biod = 0.0_8
            dn_in_dustd = 0.0_8
            n_in_dustd = 0.0_8
            dn_in_biod = 0.0_8
          END IF
          IF (temperature_k .LT. 273.15 - 35.) THEN
            arg1d = 0.1296*100.*ss_id
            arg1 = 0.1296*(ss_i*100.-10.)
            n_in_ultrad = 1000.*fac_correct_rh*0.3*EXP(arg1)**(-0.7)*&
&             arg1d*EXP(arg1)/rho_cfdc
            n_in_ultra = 1000.*EXP(arg1)**0.3*fac_correct_rh/rho_cfdc
!DONIF simplified treatment of derivative asusming dH small 
            dnaux = 3.88
            naux = 0.0
            rhid = 100.*ss_id
            rhi = (ss_i+1.)*100.
            IF (rhi .LT. 0.) THEN
              rhi = 0.
              rhid = 0.0_8
            END IF
            n_in_solo_stard = 1000.e6*7.7211e-5*rhid/rho_aida
            n_in_solo_star = 1000.e6*(7.7211e-5*rhi-9.2688e-3)/rho_aida
            n_in_dust_ultra = 0.
            dn_in_dust = 0.0
            n_in_dust_ultrad = 0.0_8
            dn_in_dustd = 0.0_8
            DO ij=1,ijstop_dust
              mud = alpha_dust*pie*d_grid_dust(ij)**2.*(n_in_ultrad*&
&               h_frac_dust+n_in_ultra*h_frac_dustd)/base_dust_omega
              mu = n_in_ultra*alpha_dust*h_frac_dust*pie*d_grid_dust(ij)&
&               **2./base_dust_omega
              nauxd = n_grid_dust(ij)*mud*EXP(-mu)
              naux = (1.-EXP(-mu))*n_grid_dust(ij)
              n_in_dust_ultrad = n_in_dust_ultrad + nauxd
              n_in_dust_ultra = n_in_dust_ultra + naux
              IF (mu*(n_grid_dust(ij)-naux)*(dnaux+dh_frac_dust) .LT. &
&                 0.0) THEN
                max4 = 0.0
                max4d = 0.0_8
              ELSE
                max4d = (mud*(dnaux+dh_frac_dust)+mu*dh_frac_dustd)*(&
&                 n_grid_dust(ij)-naux) - mu*(dnaux+dh_frac_dust)*nauxd
                max4 = mu*(n_grid_dust(ij)-naux)*(dnaux+dh_frac_dust)
              END IF
              dn_in_dustd = max4d + dn_in_dustd
              dn_in_dust = max4 + dn_in_dust
            END DO
            n_in_soot_ultra = 0.0
            dn_in_soot = 0.0
            n_in_soot_ultrad = 0.0_8
            DO ij=1,ijstop_soot
              mud = alpha_soot*pie*d_grid_soot(ij)**2.*(n_in_ultrad*&
&               h_frac_soot+n_in_ultra*h_frac_sootd)/&
&               base_soot_philic_omega
              mu = n_in_ultra*alpha_soot*h_frac_soot*pie*d_grid_soot(ij)&
&               **2./base_soot_philic_omega
              nauxd = n_grid_soot(ij)*mud*EXP(-mu)
              naux = (1.-EXP(-mu))*n_grid_soot(ij)
              n_in_soot_ultrad = n_in_soot_ultrad + nauxd
              n_in_soot_ultra = n_in_soot_ultra + naux
              IF (mu*(n_grid_soot(ij)-naux)*(dnaux+dh_frac_soot) .LT. &
&                 0.0) THEN
                max5 = 0.0
              ELSE
                max5 = mu*(n_grid_soot(ij)-naux)*(dnaux+dh_frac_soot)
              END IF
              dn_in_soot = max5 + dn_in_soot
            END DO
            n_in_bio_ultra = 0.
            dn_in_bio = 0.0
            n_in_bio_ultrad = 0.0_8
            dn_in_biod = 0.0_8
            DO ij=1,ijstop_bio
              mud = alpha_bio*pie*d_grid_bio(ij)**2.*(n_in_ultrad*&
&               h_frac_bio+n_in_ultra*h_frac_biod)/base_bio_omega
              mu = n_in_ultra*alpha_bio*h_frac_bio*pie*d_grid_bio(ij)**&
&               2./base_bio_omega
              nauxd = n_grid_bio(ij)*mud*EXP(-mu)
              naux = (1.-EXP(-mu))*n_grid_bio(ij)
              n_in_bio_ultrad = n_in_bio_ultrad + nauxd
              n_in_bio_ultra = n_in_bio_ultra + naux
              IF (mu*(n_grid_bio(ij)-naux)*dnaux .LT. 0.0) THEN
                max6 = 0.0
                max6d = 0.0_8
              ELSE
                max6d = dnaux*(mud*(n_grid_bio(ij)-naux)-mu*nauxd)
                max6 = mu*(n_grid_bio(ij)-naux)*dnaux
              END IF
              dn_in_biod = max6d + dn_in_biod
              dn_in_bio = max6 + dn_in_bio
            END DO
            n_in_solod = psi_solo*glass_frac*(h_frac_solod*&
&             n_in_solo_star+h_frac_solo*n_in_solo_stard)
            n_in_solo = psi_solo*glass_frac*h_frac_solo*n_in_solo_star
            x1 = psi_solo*glass_frac*(h_frac_solo*77211.0*100.0/rho_aida&
&             +n_in_solo_star*dh_frac_solo)
            IF (x1 .LT. 0.0) THEN
              dn_in_solo = 0.0
            ELSE
              dn_in_solo = x1
            END IF
          ELSE
            n_in_ultra = 0.
            n_in_dust_ultra = 0.
            n_in_soot_ultra = 0.
            n_in_solo = 0.
            n_in_bio_ultra = 0.
            n_in_soot_ultrad = 0.0_8
            n_in_dust_ultrad = 0.0_8
            n_in_solod = 0.0_8
            n_in_bio_ultrad = 0.0_8
          END IF
          n_in_dustd = n_in_dustd + n_in_dust_ultrad
          n_in_dust = n_in_dust + n_in_dust_ultra
          n_in_sootd = n_in_sootd + n_in_soot_ultrad
          n_in_soot = n_in_soot + n_in_soot_ultra
          n_in_biod = n_in_biod + n_in_bio_ultrad
          n_in_bio = n_in_bio + n_in_bio_ultra
! PROBLEM:  how to ensure that the frozen fraction does not exceed 1 ?
          IF (n_in_dust + n_in_bio + n_in_soot + n_in_solo .GT. 0.) THEN
            cihenc_dustd = n_in_dustd
            cihenc_dust = n_in_dust - nin_a_nuc_dust
            IF (cihenc_dust .LT. 0.) THEN
              cihenc_dust = 0.
              cihenc_dustd = 0.0_8
            END IF
            cihenc_sootd = n_in_sootd
            cihenc_soot = n_in_soot - nin_a_nuc_soot
            IF (cihenc_soot .LT. 0.) THEN
              cihenc_soot = 0.
              cihenc_sootd = 0.0_8
            END IF
            cihenc_biod = n_in_biod
            cihenc_bio = n_in_bio - nin_a_nuc_bio
            IF (cihenc_bio .LT. 0.) THEN
              cihenc_bio = 0.
              cihenc_biod = 0.0_8
            END IF
            cihenc_solod = n_in_solod
            cihenc_solo = n_in_solo - nin_a_nuc_solo
            IF (cihenc_solo .LT. 0.) THEN
              cihenc_solo = 0.
              cihenc_solod = 0.0_8
            END IF
            n_iwd = cihenc_dustd
            n_iw = n_iw + cihenc_dust
            nin_a_nuc_dust = nin_a_nuc_dust + cihenc_dust
            num_ic_dust_imm = num_ic_dust_imm + cihenc_dust
            n_iwd = n_iwd + cihenc_sootd
            n_iw = n_iw + cihenc_soot
            nin_a_nuc_soot = nin_a_nuc_soot + cihenc_soot
            num_ic_soot_imm = num_ic_soot_imm + cihenc_soot
            n_iwd = n_iwd + cihenc_biod
            n_iw = n_iw + cihenc_bio
            nin_a_nuc_bio = nin_a_nuc_bio + cihenc_bio
            num_ic_bio_imm = num_ic_bio_imm + cihenc_bio
            n_iwd = n_iwd + cihenc_solod
            n_iw = n_iw + cihenc_solo
            nin_a_nuc_solo = nin_a_nuc_solo + cihenc_solo
            num_ic_solo_imm = num_ic_solo_imm + cihenc_solo
          ELSE
            n_iwd = 0.0_8
          END IF
        ELSE
          n_iwd = 0.0_8
          n_in_sootd = 0.0_8
          n_in_solod = 0.0_8
          dn_in_dustd = 0.0_8
          dn_in_biod = 0.0_8
        END IF
      ELSE
        n_iwd = 0.0_8
        n_in_sootd = 0.0_8
        n_in_solod = 0.0_8
        dn_in_dustd = 0.0_8
        dn_in_biod = 0.0_8
      END IF
!DONIF
      dnalld = dn_in_dustd + dn_in_biod + n_in_sootd + n_in_solod
      dnall = dn_in_dust + dn_in_bio + n_in_soot + n_in_solo
      IF (dnall .GT. 0. .AND. n_iw .GT. 0.0) THEN
        IF (n_iw/dnall .GT. ss_i) THEN
          x2d = ss_id
          x2 = ss_i
        ELSE
          x2d = (n_iwd*dnall-n_iw*dnalld)/dnall**2
          x2 = n_iw/dnall
        END IF
        IF (x2 .LT. 0.005) THEN
          dsh = 0.005
          dshd = 0.0_8
        ELSE
          dshd = x2d
          dsh = x2
        END IF
      ELSE
        dsh = 0.005
        dshd = 0.0_8
      END IF
    END IF
  END SUBROUTINE EMPIRICAL_PARAM_PHILLIPS_D
!  Differentiation of empirical_param_phillips in reverse (adjoint) mode:
!   gradient     of useful results: temperature_k dsh n_iw
!   with respect to varying inputs: n_grid_soot d_grid_soot temperature_k
!                a_solo n_grid_dust d_grid_dust si sw siw
!=======================================================================================
!=======================================================================================
!=======================================================================================
!!====================================================================================
!		EMPIRICAL PARAMETERISATION (Phillips et al. 2013, JAS)
!		contributed by Vaughan Phillips, 2012
!		University of Leeds
! Implementation:   Donifan Barahona donifan.o.barahona@nasa.gov 
!====================================================================================
  SUBROUTINE EMPIRICAL_PARAM_PHILLIPS_B(temperature_k, temperature_kb, &
&   p_sat, si, sib, siw, siwb, sw, swb, d_grid_dust, d_grid_dustb, &
&   n_grid_dust, n_grid_dustb, ijstop_dust, d_grid_soot, d_grid_sootb, &
&   n_grid_soot, n_grid_sootb, ijstop_soot, d_grid_bio, n_grid_bio, &
&   ijstop_bio, a_solo, a_solob, n_iw, n_iwb, dsh, dshb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: temperature_k, p_sat, si, siw, sw, a_solo
    REAL*8 :: temperature_kb, sib, siwb, swb, a_solob
    REAL*8, DIMENSION(2), INTENT(IN) :: d_grid_dust, n_grid_dust
    REAL*8, DIMENSION(2) :: d_grid_dustb, n_grid_dustb
    REAL*8, DIMENSION(1), INTENT(IN) :: d_grid_soot, n_grid_soot, &
&   d_grid_bio, n_grid_bio
    REAL*8, DIMENSION(1) :: d_grid_sootb, n_grid_sootb
    INTEGER, INTENT(IN) :: ijstop_dust, ijstop_soot, ijstop_bio
    REAL*8 :: nin_a_nuc_dust, nin_a_nuc_soot, nin_a_nuc_bio, &
&   nin_a_nuc_solo, num_ic_dust_imm, num_ic_soot_imm, num_ic_bio_imm, &
&   num_ic_solo_imm
!DONIF
    REAL*8, INTENT(INOUT) :: dsh, n_iw
    REAL*8 :: dshb, n_iwb
!DONIF
    REAL*8 :: dn_in_dust, dn_in_soot, dn_in_bio, dn_in_solo, dnall, &
&   dnaux, naux, ss_w, dh_frac_dust, dh_frac_soot, dh_frac_solo, aux, &
&   dfdep
    REAL*8 :: dn_in_dustb, dn_in_biob, dnallb, nauxb, ss_wb, &
&   dh_frac_dustb, auxb, dfdepb
    REAL*8 :: rho_cfdc, base_dust_omega, base_soot_philic_omega, &
&   base_bio_omega, alpha_dust, alpha_soot, alpha_bio, &
&   fraction_depnucl_warm_dust, pie, base_solo_omega, temp_max_dust_degc&
&   , temp_max_soot_degc, temp_max_bio_degc, glass_frac
    PARAMETER (base_dust_omega=2.0d-6, base_soot_philic_omega=1.0d-7, &
&   base_bio_omega=0.89d-6, base_solo_omega=5.6d-5, glass_frac=0.5d0, &
&   alpha_dust=2d0/3d0, alpha_soot=1d0/3d0-0.03d0, alpha_bio=0.03d0, &
&   rho_cfdc=50000d0/(287d0*228.15d0), fraction_depnucl_warm_dust=0.15d0&
&   , pie=3.1415926d0, temp_max_dust_degc=-10d0, temp_max_soot_degc=-&
&     15d0, temp_max_bio_degc=-2d0)
    REAL*8, SAVE :: fac_correct_rh=2d0, rho_aida
    REAL*8 :: h_frac_dust, n_in, n_in_dust, n_in_ultra, n_in_dust_ultra&
&   , cihenc_dust, esw, esi, ss_i, n_in_soot_ultra, h_frac_soot, &
&   h_frac_bio, n_in_soot, n_in_bio, n_in_bio_ultra, cihenc_soot, &
&   cihenc_bio, delta_si, delta_t, delta_sw, n_in_max, ss_iw, rho
    REAL*8 :: h_frac_dustb, n_inb, n_in_dustb, n_in_ultrab, &
&   n_in_dust_ultrab, cihenc_dustb, ss_ib, n_in_soot_ultrab, &
&   h_frac_sootb, h_frac_biob, n_in_sootb, n_in_biob, n_in_bio_ultrab, &
&   cihenc_sootb, cihenc_biob, n_in_maxb, ss_iwb
    REAL*8 :: h_frac_solo, rhi, n_in_solo, n_in_solo_star, cihenc_solo, &
&   psi_solo
    REAL*8 :: h_frac_solob, rhib, n_in_solob, n_in_solo_starb, &
&   cihenc_solob, psi_solob
    REAL*8 :: mu, s_i_0, rh_crit, s_i_w_warm, s_i_w_cold, s_i_w, &
&   tc_hm_degc
    REAL*8 :: mub, s_i_0b, tc_hm_degcb
    REAL*8 :: s_w_0, dep_frac, n_in_hat, n_in_tilde
    REAL*8 :: s_w_0b, dep_fracb, n_in_hatb, n_in_tildeb
    REAL*8, SAVE :: eps=0.622d0
    INTEGER :: ij
    INTRINSIC SIZE
    INTRINSIC EXP
    INTRINSIC MAX
    INTRINSIC MIN
    REAL*8 :: pwy1
    REAL*8 :: pwy1b
    REAL*8 :: pwr1
    REAL*8 :: pwr1b
    REAL*8 :: result1
    REAL*8 :: result1b
    REAL*8 :: arg1
    REAL*8 :: arg1b
    REAL*8 :: pwx1
    REAL*8 :: pwx1b
    REAL*8 :: x2
    REAL*8 :: x2b
    REAL*8 :: x1
    REAL*8 :: max6
    REAL*8 :: max6b
    REAL*8 :: max5
    REAL*8 :: max4
    REAL*8 :: max4b
    REAL*8 :: max3
    REAL*8 :: max3b
    REAL*8 :: max2
    REAL*8 :: max1
    REAL*8 :: max1b
    REAL*8 :: arg10
    REAL*8 :: arg10b
    REAL*8 :: arg2
    REAL*8 :: arg2b
    REAL*8 :: res
    REAL*8 :: res0
    REAL*8 :: res1
    REAL*8 :: arg11
    REAL*8 :: arg12
    REAL*8 :: arg13
    INTEGER :: branch
    REAL*8 :: resb
    REAL*8 :: arg1b2
    REAL*8 :: arg1b1
    REAL*8 :: arg1b0
    REAL*8 :: resb1
    REAL*8 :: tempb9
    REAL*8 :: resb0
    REAL*8 :: tempb8
    REAL*8 :: tempb7
    REAL*8 :: tempb6
    REAL*8 :: tempb5
    REAL*8 :: tempb4
    REAL*8 :: tempb3
    REAL*8 :: tempb2
    REAL*8 :: tempb1
    REAL*8 :: tempb0
    REAL*8 :: dummydiffb9
    REAL*8 :: dummydiffb8
    REAL*8 :: tempb12
    REAL*8 :: dummydiffb7
    REAL*8 :: tempb11
    REAL*8 :: dummydiffb6
    REAL*8 :: tempb10
    REAL*8 :: dummydiffb5
    REAL*8 :: dummydiffb4
    REAL*8 :: dummydiffb3
    REAL*8 :: dummydiffb2
    REAL*8 :: dummydiffb1
    REAL*8 :: dummydiffb0
    REAL*8 :: dummydiffb16
    REAL*8 :: tempb
    REAL*8 :: dummydiffb15
    REAL*8 :: dummydiffb14
    REAL*8 :: dummydiffb13
    REAL*8 :: dummydiffb12
    REAL*8 :: dummydiffb11
    REAL*8 :: dummydiffb10
    REAL*8 :: dummydiffb
!intrinsic :: exp, DEXP, SIZE, DBLE
!print *, SIZE(n_grid_dust(:))
    IF (ijstop_dust .NE. SIZE(n_grid_dust)) THEN
      STOP
    ELSE IF (ijstop_soot .NE. SIZE(n_grid_soot)) THEN
      STOP
    ELSE IF (ijstop_bio .NE. SIZE(n_grid_bio)) THEN
      STOP
    ELSE
!default
      n_iw = 0.0
      nin_a_nuc_dust = 0.0
      nin_a_nuc_soot = 0.0
      nin_a_nuc_bio = 0.0
      nin_a_nuc_solo = 0.0
      dn_in_dust = 0.0
      dn_in_bio = 0.0
      dh1smooth = 0.0
!====================================================================================
!		COMPUTATION BLOCK 
!
!====================================================================================
!
      rho_aida = 90000./(287.*205.)
      psi_solo = a_solo/base_solo_omega
!everything is based on supersaturation 
      ss_i = si - 1.0
      ss_w = sw - 1.0
      ss_iw = siw - 1.0
      IF (ss_i .GT. 0.0d0) THEN
        IF (temperature_k .LT. 273.15d0 .AND. temperature_k .GT. 273.15 &
&           - 90.) THEN
!SS_iw = QSW/QSI - 1.
          IF (ss_w .GT. 0.) THEN
            ss_i = ss_iw
            ss_w = 0.0
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
!				S_i_zero = 1.15 !this is taken care of
          arg10 = ss_i + 1d0
          CALL PUSHREAL8(dh1smooth)
          res = H_1_SMOOTH(arg10, 1.1d0, 1.2d0, 0.0d0, 1d0)
          arg10 = -(temperature_k-273.15)
          CALL PUSHREAL8(dh1smooth)
          res0 = H_1_SMOOTH(arg10, 35d0, 40d0, &
&           fraction_depnucl_warm_dust, 1d0)
          arg10 = ss_w + 1.0d0
          CALL PUSHREAL8(dh1smooth)
          res1 = H_1_SMOOTH(arg10, 0.97d0, 1d0, 0d0, 1d0)
          tc_hm_degc = temperature_k - 273.15d0
          pwy1 = 8.2584e-6*tc_hm_degc*tc_hm_degc*tc_hm_degc + 5.3938e-4*&
&           tc_hm_degc*tc_hm_degc + 3.1656e-3*tc_hm_degc - 1.0261d0
          pwr1 = 10.**pwy1
          s_i_0 = 1d0 + pwr1
          s_w_0 = 0.97d0
          arg10 = -(temperature_k-273.15d0)
          CALL PUSHREAL8(dh1smooth)
          result1 = H_1_SMOOTH(arg10, 35d0, 40d0, &
&           fraction_depnucl_warm_dust, 1d0)
          aux = result1/fac_correct_rh
          arg10 = ss_i + 1d0
          arg2 = s_i_0 + 0.1d0
          CALL PUSHREAL8(dh1smooth)
          result1 = H_1_SMOOTH(arg10, s_i_0, arg2, 0d0, 1d0)
          dep_frac = result1*aux
          dfdep = dh1smooth*aux
          arg10 = ss_w + 1.0d0
          CALL PUSHREAL8(dh1smooth)
          CALL PUSHREAL8(aux)
          aux = H_1_SMOOTH(arg10, s_w_0, 1.d0, 0.d0, 1.d0)
          h_frac_dust = dep_frac + (1.d0-dep_frac)*aux
          dh_frac_dust = dfdep + siw*(1.d0-dep_frac)*dh1smooth - aux*&
&           dfdep
          IF (h_frac_dust .GT. 1.d0) THEN
            h_frac_dust = 1.d0
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          IF (h_frac_dust .GT. 1.0e-6 .AND. h_frac_dust .LT. 1.d0) THEN
            CALL PUSHREAL8(dh_frac_dust)
            dh_frac_dust = dh_frac_dust/h_frac_dust
            CALL PUSHCONTROL1B(0)
          ELSE
            dh_frac_dust = 0.0d0
            CALL PUSHCONTROL1B(1)
          END IF
!soluble organics
          s_i_0 = 1.2d0
          arg10 = -(temperature_k-273.15d0)
          CALL PUSHREAL8(dh1smooth)
          CALL PUSHREAL8(aux)
          aux = H_1_SMOOTH(arg10, 65d0, 75d0, 0d0, 1d0)
          arg10 = ss_i + 1d0
          arg2 = s_i_0 + 0.1d0
          CALL PUSHREAL8(dh1smooth)
          CALL PUSHREAL8(result1)
          result1 = H_1_SMOOTH(arg10, s_i_0, arg2, 0d0, 1d0)
          CALL PUSHREAL8(dep_frac)
          dep_frac = result1*aux
          h_frac_solo = dep_frac
          IF (h_frac_solo .GT. 1.d0) THEN
            h_frac_solo = 1.d0
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          s_w_0 = 0.97d0
          s_i_0 = 1.3d0
          arg10 = -(temperature_k-273.15d0)
          CALL PUSHREAL8(dh1smooth)
          CALL PUSHREAL8(result1)
          result1 = H_1_SMOOTH(arg10, 40.d0, 50.d0, 0.d0, 1.d0)
          CALL PUSHREAL8(aux)
          aux = result1/fac_correct_rh
          arg10 = ss_i + 1d0
          arg2 = s_i_0 + 0.1d0
          CALL PUSHREAL8(dh1smooth)
          result1 = H_1_SMOOTH(arg10, s_i_0, arg2, 0.d0, 1.d0)
          dep_frac = result1*aux
          arg10 = ss_w + 1.0d0
          CALL PUSHREAL8(dh1smooth)
          CALL PUSHREAL8(aux)
          aux = H_1_SMOOTH(arg10, s_w_0, 1.d0, 0.d0, 1.d0)
          h_frac_soot = dep_frac + (1.d0-dep_frac)*aux
          IF (h_frac_soot .GT. 1.d0) THEN
            h_frac_soot = 1.d0
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          h_frac_bio = h_frac_soot
          IF (temperature_k .LT. 273.15d0 .AND. temperature_k .GE. &
&             273.15d0 - 35.d0) THEN
            n_in = 1.e3*(EXP(12.96d0*ss_i-0.639)/rho_cfdc)*0.0587*&
&             fac_correct_rh
            IF (temperature_k .GT. 273.15 - 5. .AND. temperature_k .LT. &
&               273.15 - 2.) THEN
              arg10 = -(temperature_k-273.15d0)
              CALL PUSHREAL8(dh1smooth)
              CALL PUSHREAL8(result1)
              result1 = H_1_SMOOTH(arg10, 2.d0, 5.d0, 0.d0, 1.d0)
              CALL PUSHREAL8(n_in)
              n_in = n_in*result1
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
            IF (temperature_k .GE. 273.15 - 2.d0) THEN
              n_in = 0.d0
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
            IF (temperature_k .LT. 273.15d0 - 25.d0) THEN
              arg1 = 0.1296*(ss_i*100.-10.)
              n_in_tilde = 1000.*EXP(arg1)**0.3*fac_correct_rh/rho_cfdc
              n_in_hat = n_in
              IF (temperature_k .GE. 273.15 - 30.) THEN
                n_in_max = 1.e3*(EXP(12.96*ss_iw-0.639)/rho_cfdc)*0.0587&
&                 *fac_correct_rh
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
              IF (temperature_k .LT. 273.15 - 30.) THEN
                arg1 = 0.1296*(ss_iw*100.-10.)
                n_in_max = 1000.*EXP(arg1)**0.3*fac_correct_rh/rho_cfdc
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
              IF (n_in_hat .GT. n_in_max) THEN
                n_in_hat = n_in_max
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
              IF (n_in_tilde .GT. n_in_max) THEN
                n_in_tilde = n_in_max
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
              pwx1 = n_in_tilde/n_in_hat
              arg10 = -(temperature_k-273.15d0)
              CALL PUSHREAL8(dh1smooth)
              CALL PUSHREAL8(result1)
              result1 = H_1_SMOOTH(arg10, 25d0, 35d0, 0d0, 1d0)
              pwr1 = pwx1**result1
              n_in = n_in_hat*pwr1
              IF (n_in .GT. n_in_max) THEN
                n_in = n_in_max
                CALL PUSHCONTROL2B(0)
              ELSE
                CALL PUSHCONTROL2B(1)
              END IF
            ELSE
              CALL PUSHCONTROL2B(2)
            END IF
            n_in_dust = 0.
            dn_in_dust = 0.
            IF (temperature_k .LT. 273.15 - 30.) THEN
!DONIF
!this is a simplified derivative of dNds
              dnaux = 3.88
            ELSE
              dnaux = 12.96
            END IF
            DO ij=1,ijstop_dust
              CALL PUSHREAL8(mu)
              mu = n_in*alpha_dust*h_frac_dust*pie*d_grid_dust(ij)*&
&               d_grid_dust(ij)/base_dust_omega
              CALL PUSHREAL8(naux)
              naux = (1.-EXP(-mu))*n_grid_dust(ij)
              n_in_dust = n_in_dust + naux
              IF (mu*(n_grid_dust(ij)-naux)*(dnaux+dh_frac_dust) .LT. &
&                 0.0) THEN
                max1 = 0.0
                CALL PUSHCONTROL1B(0)
              ELSE
                max1 = mu*(n_grid_dust(ij)-naux)*(dnaux+dh_frac_dust)
                CALL PUSHCONTROL1B(1)
              END IF
              dn_in_dust = max1 + dn_in_dust
            END DO
            IF (temperature_k .GT. 273.15 + temp_max_dust_degc - 20. &
&               .AND. temperature_k .LT. 273.15 + temp_max_dust_degc) &
&           THEN
              arg10 = -(temperature_k-273.15d0)
              arg2 = -temp_max_dust_degc + 20d0
              arg11 = -temp_max_dust_degc
              CALL PUSHREAL8(dh1smooth)
              CALL PUSHREAL8(result1)
              result1 = H_1_SMOOTH(arg10, arg11, arg2, 0d0, 1d0)
              CALL PUSHREAL8(n_in_dust)
              n_in_dust = n_in_dust*result1
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
            IF (temperature_k .GE. 273.15 + temp_max_dust_degc) THEN
              n_in_dust = 0.
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
            n_in_soot = 0.
            DO ij=1,ijstop_soot
              CALL PUSHREAL8(mu)
              mu = n_in*alpha_soot*h_frac_soot*pie*d_grid_soot(ij)**2./&
&               base_soot_philic_omega
              CALL PUSHREAL8(naux)
              naux = (1.-EXP(-mu))*n_grid_soot(ij)
              n_in_soot = n_in_soot + naux
            END DO
            IF (temperature_k .GT. 273.15 + temp_max_soot_degc - 10. &
&               .AND. temperature_k .LT. 273.15 + temp_max_soot_degc) &
&           THEN
              arg10 = -(temperature_k-273.15d0)
              arg2 = -temp_max_soot_degc + 10d0
              arg12 = -temp_max_soot_degc
              CALL PUSHREAL8(dh1smooth)
              CALL PUSHREAL8(result1)
              result1 = H_1_SMOOTH(arg10, arg12, arg2, 0d0, 1d0)
              CALL PUSHREAL8(n_in_soot)
              n_in_soot = n_in_soot*result1
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
            IF (temperature_k .GE. 273.15 + temp_max_soot_degc) THEN
              n_in_soot = 0.
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
            n_in_bio = 0.
            dn_in_bio = 0.
            DO ij=1,ijstop_bio
              CALL PUSHREAL8(mu)
              mu = n_in*alpha_bio*h_frac_bio
              CALL PUSHREAL8(naux)
              naux = (1.-EXP(-mu))*n_grid_bio(ij)
!!!!!!!!!!!!!!remember!!!!!!!!!!!!!!!!
!naux =  n_in*ALPHA_bio*H_frac_bio
!!!!!!!!!!!!!!remember!!!!!!!!!!!!!!!!
              n_in_bio = n_in_bio + naux
              IF (mu*(n_grid_bio(ij)-naux)*dnaux .LT. 0.0) THEN
                max3 = 0.0
                CALL PUSHCONTROL1B(0)
              ELSE
                max3 = mu*(n_grid_bio(ij)-naux)*dnaux
                CALL PUSHCONTROL1B(1)
              END IF
              dn_in_bio = max3 + dn_in_bio
            END DO
            IF (temperature_k .GT. 273.15 + temp_max_bio_degc - 3. .AND.&
&               temperature_k .LT. 273.15 + temp_max_bio_degc) THEN
              arg10 = -(temperature_k-273.15d0)
              arg2 = -temp_max_bio_degc + 3d0
              arg13 = -temp_max_bio_degc
              CALL PUSHREAL8(dh1smooth)
              CALL PUSHREAL8(result1)
              result1 = H_1_SMOOTH(arg10, arg13, arg2, 0d0, 1d0)
              CALL PUSHREAL8(n_in_bio)
              n_in_bio = n_in_bio*result1
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
            IF (temperature_k .GE. 273.15 + temp_max_bio_degc) THEN
              n_in_bio = 0d0
              CALL PUSHCONTROL2B(0)
            ELSE
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE
            n_in_dust = 0.
            n_in_soot = 0.
            n_in_bio = 0.
            CALL PUSHCONTROL2B(2)
          END IF
          IF (temperature_k .LT. 273.15 - 35.) THEN
            arg1 = 0.1296*(ss_i*100.-10.)
            n_in_ultra = 1000.*EXP(arg1)**0.3*fac_correct_rh/rho_cfdc
!DONIF simplified treatment of derivative asusming dH small 
            CALL PUSHREAL8(dnaux)
            dnaux = 3.88
            rhi = (ss_i+1.)*100.
            IF (rhi .LT. 0.) THEN
              rhi = 0.
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
            n_in_solo_star = 1000.e6*(7.7211e-5*rhi-9.2688e-3)/rho_aida
            n_in_dust_ultra = 0.
            dn_in_dust = 0.0
            DO ij=1,ijstop_dust
              CALL PUSHREAL8(mu)
              mu = n_in_ultra*alpha_dust*h_frac_dust*pie*d_grid_dust(ij)&
&               **2./base_dust_omega
              CALL PUSHREAL8(naux)
              naux = (1.-EXP(-mu))*n_grid_dust(ij)
              n_in_dust_ultra = n_in_dust_ultra + naux
              IF (mu*(n_grid_dust(ij)-naux)*(dnaux+dh_frac_dust) .LT. &
&                 0.0) THEN
                max4 = 0.0
                CALL PUSHCONTROL1B(0)
              ELSE
                max4 = mu*(n_grid_dust(ij)-naux)*(dnaux+dh_frac_dust)
                CALL PUSHCONTROL1B(1)
              END IF
              dn_in_dust = max4 + dn_in_dust
            END DO
            n_in_soot_ultra = 0.0
            DO ij=1,ijstop_soot
              CALL PUSHREAL8(mu)
              mu = n_in_ultra*alpha_soot*h_frac_soot*pie*d_grid_soot(ij)&
&               **2./base_soot_philic_omega
              CALL PUSHREAL8(naux)
              naux = (1.-EXP(-mu))*n_grid_soot(ij)
              n_in_soot_ultra = n_in_soot_ultra + naux
            END DO
            n_in_bio_ultra = 0.
            dn_in_bio = 0.0
            DO ij=1,ijstop_bio
              CALL PUSHREAL8(mu)
              mu = n_in_ultra*alpha_bio*h_frac_bio*pie*d_grid_bio(ij)**&
&               2./base_bio_omega
              CALL PUSHREAL8(naux)
              naux = (1.-EXP(-mu))*n_grid_bio(ij)
              n_in_bio_ultra = n_in_bio_ultra + naux
              IF (mu*(n_grid_bio(ij)-naux)*dnaux .LT. 0.0) THEN
                max6 = 0.0
                CALL PUSHCONTROL1B(0)
              ELSE
                max6 = mu*(n_grid_bio(ij)-naux)*dnaux
                CALL PUSHCONTROL1B(1)
              END IF
              dn_in_bio = max6 + dn_in_bio
            END DO
            n_in_solo = psi_solo*glass_frac*h_frac_solo*n_in_solo_star
            CALL PUSHCONTROL1B(0)
          ELSE
            n_in_dust_ultra = 0.
            n_in_soot_ultra = 0.
            n_in_solo = 0.
            n_in_bio_ultra = 0.
            CALL PUSHCONTROL1B(1)
          END IF
          n_in_dust = n_in_dust + n_in_dust_ultra
          n_in_soot = n_in_soot + n_in_soot_ultra
          n_in_bio = n_in_bio + n_in_bio_ultra
! PROBLEM:  how to ensure that the frozen fraction does not exceed 1 ?
          IF (n_in_dust + n_in_bio + n_in_soot + n_in_solo .GT. 0.) THEN
            cihenc_dust = n_in_dust - nin_a_nuc_dust
            IF (cihenc_dust .LT. 0.) THEN
              cihenc_dust = 0.
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
            cihenc_soot = n_in_soot - nin_a_nuc_soot
            IF (cihenc_soot .LT. 0.) THEN
              cihenc_soot = 0.
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
            cihenc_bio = n_in_bio - nin_a_nuc_bio
            IF (cihenc_bio .LT. 0.) THEN
              cihenc_bio = 0.
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
            cihenc_solo = n_in_solo - nin_a_nuc_solo
            IF (cihenc_solo .LT. 0.) THEN
              cihenc_solo = 0.
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
            n_iw = n_iw + cihenc_dust
            n_iw = n_iw + cihenc_soot
            n_iw = n_iw + cihenc_bio
            n_iw = n_iw + cihenc_solo
            CALL PUSHCONTROL2B(0)
          ELSE
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B(2)
        END IF
      ELSE
        CALL PUSHCONTROL2B(3)
      END IF
!DONIF
      dnall = dn_in_dust + dn_in_bio + n_in_soot + n_in_solo
      IF (dnall .GT. 0. .AND. n_iw .GT. 0.0) THEN
        IF (n_iw/dnall .GT. ss_i) THEN
          x2 = ss_i
          CALL PUSHCONTROL1B(0)
        ELSE
          x2 = n_iw/dnall
          CALL PUSHCONTROL1B(1)
        END IF
        IF (x2 .LT. 0.005) THEN
          x2b = 0.0_8
        ELSE
          x2b = dshb
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          ss_ib = x2b
          dnallb = 0.0_8
        ELSE
          n_iwb = n_iwb + x2b/dnall
          dnallb = -(n_iw*x2b/dnall**2)
          ss_ib = 0.0_8
        END IF
      ELSE
        ss_ib = 0.0_8
        dnallb = 0.0_8
      END IF
      dn_in_dustb = dnallb
      dn_in_biob = dnallb
      n_in_sootb = dnallb
      n_in_solob = dnallb
      CALL POPCONTROL2B(branch)
      IF (branch .LT. 2) THEN
        IF (branch .EQ. 0) THEN
          cihenc_solob = n_iwb
          cihenc_biob = n_iwb
          cihenc_sootb = n_iwb
          cihenc_dustb = n_iwb
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) cihenc_solob = 0.0_8
          n_in_solob = n_in_solob + cihenc_solob
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) cihenc_biob = 0.0_8
          n_in_biob = cihenc_biob
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) cihenc_sootb = 0.0_8
          n_in_sootb = n_in_sootb + cihenc_sootb
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) cihenc_dustb = 0.0_8
          n_in_dustb = cihenc_dustb
        ELSE
          n_in_biob = 0.0_8
          n_in_dustb = 0.0_8
        END IF
        n_in_bio_ultrab = n_in_biob
        n_in_soot_ultrab = n_in_sootb
        n_in_dust_ultrab = n_in_dustb
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          tempb12 = glass_frac*n_in_solob
          psi_solob = n_in_solo_star*h_frac_solo*tempb12
          h_frac_solob = n_in_solo_star*psi_solo*tempb12
          n_in_solo_starb = psi_solo*h_frac_solo*tempb12
          n_in_ultrab = 0.0_8
          h_frac_biob = 0.0_8
          DO ij=ijstop_bio,1,-1
            max6b = dn_in_biob
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              mu = n_in_ultra*alpha_bio*h_frac_bio*pie*d_grid_bio(ij)**&
&               2./base_bio_omega
              nauxb = 0.0_8
              mub = 0.0_8
            ELSE
              mub = dnaux*(n_grid_bio(ij)-naux)*max6b
              nauxb = -(mu*dnaux*max6b)
            END IF
            nauxb = nauxb + n_in_bio_ultrab
            CALL POPREAL8(naux)
            mub = mub + EXP(-mu)*n_grid_bio(ij)*nauxb
            CALL POPREAL8(mu)
            tempb11 = alpha_bio*pie*d_grid_bio(ij)**2.*mub/&
&             base_bio_omega
            n_in_ultrab = n_in_ultrab + h_frac_bio*tempb11
            h_frac_biob = h_frac_biob + n_in_ultra*tempb11
          END DO
          n_grid_sootb = 0.0_8
          d_grid_sootb = 0.0_8
          h_frac_sootb = 0.0_8
          DO ij=ijstop_soot,1,-1
            nauxb = n_in_soot_ultrab
            mu = n_in_ultra*alpha_soot*h_frac_soot*pie*d_grid_soot(ij)**&
&             2./base_soot_philic_omega
            CALL POPREAL8(naux)
            mub = EXP(-mu)*n_grid_soot(ij)*nauxb
            n_grid_sootb(ij) = n_grid_sootb(ij) + (1.-EXP(-mu))*nauxb
            CALL POPREAL8(mu)
            tempb9 = alpha_soot*pie*mub
            tempb10 = d_grid_soot(ij)**2.*tempb9/base_soot_philic_omega
            n_in_ultrab = n_in_ultrab + h_frac_soot*tempb10
            h_frac_sootb = h_frac_sootb + n_in_ultra*tempb10
            d_grid_sootb(ij) = d_grid_sootb(ij) + n_in_ultra*h_frac_soot&
&             *2.*d_grid_soot(ij)*tempb9/base_soot_philic_omega
          END DO
          n_grid_dustb = 0.0_8
          d_grid_dustb = 0.0_8
          h_frac_dustb = 0.0_8
          dh_frac_dustb = 0.0_8
          DO ij=ijstop_dust,1,-1
            max4b = dn_in_dustb
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              mu = n_in_ultra*alpha_dust*h_frac_dust*pie*d_grid_dust(ij)&
&               **2./base_dust_omega
              nauxb = 0.0_8
              mub = 0.0_8
            ELSE
              tempb7 = mu*(dnaux+dh_frac_dust)*max4b
              tempb8 = (n_grid_dust(ij)-naux)*max4b
              n_grid_dustb(ij) = n_grid_dustb(ij) + tempb7
              nauxb = -tempb7
              mub = (dnaux+dh_frac_dust)*tempb8
              dh_frac_dustb = dh_frac_dustb + mu*tempb8
            END IF
            nauxb = nauxb + n_in_dust_ultrab
            CALL POPREAL8(naux)
            mub = mub + EXP(-mu)*n_grid_dust(ij)*nauxb
            n_grid_dustb(ij) = n_grid_dustb(ij) + (1.-EXP(-mu))*nauxb
            CALL POPREAL8(mu)
            tempb5 = alpha_dust*pie*mub
            tempb6 = d_grid_dust(ij)**2.*tempb5/base_dust_omega
            n_in_ultrab = n_in_ultrab + h_frac_dust*tempb6
            h_frac_dustb = h_frac_dustb + n_in_ultra*tempb6
            d_grid_dustb(ij) = d_grid_dustb(ij) + n_in_ultra*h_frac_dust&
&             *2.*d_grid_dust(ij)*tempb5/base_dust_omega
          END DO
          rhib = 1000.e6*7.7211e-5*n_in_solo_starb/rho_aida
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) rhib = 0.0_8
          arg1b = 0.3*EXP(arg1)**(-0.7)*fac_correct_rh*1000.*EXP(arg1)*&
&           n_in_ultrab/rho_cfdc
          ss_ib = ss_ib + 0.1296*100.*arg1b + 100.*rhib
          CALL POPREAL8(dnaux)
          dn_in_dustb = 0.0_8
          dn_in_biob = 0.0_8
        ELSE
          n_grid_sootb = 0.0_8
          d_grid_sootb = 0.0_8
          n_grid_dustb = 0.0_8
          d_grid_dustb = 0.0_8
          h_frac_sootb = 0.0_8
          h_frac_solob = 0.0_8
          psi_solob = 0.0_8
          h_frac_dustb = 0.0_8
          dh_frac_dustb = 0.0_8
          h_frac_biob = 0.0_8
        END IF
        CALL POPCONTROL2B(branch)
        IF (branch .EQ. 0) THEN
          n_in_biob = 0.0_8
        ELSE IF (branch .NE. 1) THEN
          ss_iwb = 0.0_8
          GOTO 110
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(n_in_bio)
          result1b = n_in_bio*n_in_biob
          n_in_biob = result1*n_in_biob
          CALL POPREAL8(result1)
          CALL POPREAL8(dh1smooth)
          dh1smoothb = 0.0_8
          CALL H_1_SMOOTH_B(arg10, arg10b, arg13, arg1b2, arg2, arg2b, &
&                     0d0, 1d0, result1b)
          temperature_kb = temperature_kb - arg10b
        END IF
        n_inb = 0.0_8
        DO ij=ijstop_bio,1,-1
          max3b = dn_in_biob
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            mu = n_in*alpha_bio*h_frac_bio
            nauxb = 0.0_8
            mub = 0.0_8
          ELSE
            mub = dnaux*(n_grid_bio(ij)-naux)*max3b
            nauxb = -(mu*dnaux*max3b)
          END IF
          nauxb = nauxb + n_in_biob
          CALL POPREAL8(naux)
          mub = mub + EXP(-mu)*n_grid_bio(ij)*nauxb
          CALL POPREAL8(mu)
          n_inb = n_inb + alpha_bio*h_frac_bio*mub
          h_frac_biob = h_frac_biob + alpha_bio*n_in*mub
        END DO
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) n_in_sootb = 0.0_8
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(n_in_soot)
          result1b = n_in_soot*n_in_sootb
          n_in_sootb = result1*n_in_sootb
          arg2 = -temp_max_soot_degc + 10d0
          arg10 = -(temperature_k-273.15d0)
          CALL POPREAL8(result1)
          CALL POPREAL8(dh1smooth)
          dh1smoothb = 0.0_8
          CALL H_1_SMOOTH_B(arg10, arg10b, arg12, arg1b1, arg2, arg2b, &
&                     0d0, 1d0, result1b)
          temperature_kb = temperature_kb - arg10b
        END IF
        DO ij=ijstop_soot,1,-1
          nauxb = n_in_sootb
          mu = n_in*alpha_soot*h_frac_soot*pie*d_grid_soot(ij)**2./&
&           base_soot_philic_omega
          CALL POPREAL8(naux)
          mub = EXP(-mu)*n_grid_soot(ij)*nauxb
          n_grid_sootb(ij) = n_grid_sootb(ij) + (1.-EXP(-mu))*nauxb
          CALL POPREAL8(mu)
          tempb3 = alpha_soot*pie*mub
          tempb4 = d_grid_soot(ij)**2.*tempb3/base_soot_philic_omega
          n_inb = n_inb + h_frac_soot*tempb4
          h_frac_sootb = h_frac_sootb + n_in*tempb4
          d_grid_sootb(ij) = d_grid_sootb(ij) + n_in*h_frac_soot*2.*&
&           d_grid_soot(ij)*tempb3/base_soot_philic_omega
        END DO
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) n_in_dustb = 0.0_8
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(n_in_dust)
          result1b = n_in_dust*n_in_dustb
          n_in_dustb = result1*n_in_dustb
          arg2 = -temp_max_dust_degc + 20d0
          arg10 = -(temperature_k-273.15d0)
          CALL POPREAL8(result1)
          CALL POPREAL8(dh1smooth)
          dh1smoothb = 0.0_8
          CALL H_1_SMOOTH_B(arg10, arg10b, arg11, arg1b0, arg2, arg2b, &
&                     0d0, 1d0, result1b)
          temperature_kb = temperature_kb - arg10b
        END IF
        DO ij=ijstop_dust,1,-1
          max1b = dn_in_dustb
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            mu = n_in*alpha_dust*h_frac_dust*pie*d_grid_dust(ij)*&
&             d_grid_dust(ij)/base_dust_omega
            nauxb = 0.0_8
            mub = 0.0_8
          ELSE
            tempb1 = mu*(dnaux+dh_frac_dust)*max1b
            tempb2 = (n_grid_dust(ij)-naux)*max1b
            n_grid_dustb(ij) = n_grid_dustb(ij) + tempb1
            nauxb = -tempb1
            mub = (dnaux+dh_frac_dust)*tempb2
            dh_frac_dustb = dh_frac_dustb + mu*tempb2
          END IF
          nauxb = nauxb + n_in_dustb
          CALL POPREAL8(naux)
          mub = mub + EXP(-mu)*n_grid_dust(ij)*nauxb
          n_grid_dustb(ij) = n_grid_dustb(ij) + (1.-EXP(-mu))*nauxb
          CALL POPREAL8(mu)
          tempb = alpha_dust*pie*mub
          tempb0 = d_grid_dust(ij)**2*tempb/base_dust_omega
          n_inb = n_inb + h_frac_dust*tempb0
          h_frac_dustb = h_frac_dustb + n_in*tempb0
          d_grid_dustb(ij) = d_grid_dustb(ij) + n_in*h_frac_dust*2*&
&           d_grid_dust(ij)*tempb/base_dust_omega
        END DO
        CALL POPCONTROL2B(branch)
        IF (branch .EQ. 0) THEN
          n_in_maxb = n_inb
          n_inb = 0.0_8
        ELSE IF (branch .EQ. 1) THEN
          n_in_maxb = 0.0_8
        ELSE
          ss_iwb = 0.0_8
          GOTO 100
        END IF
        pwr1b = n_in_hat*n_inb
        IF (pwx1 .LE. 0.0 .AND. (result1 .EQ. 0.0 .OR. result1 .NE. INT(&
&           result1))) THEN
          pwx1b = 0.0
        ELSE
          pwx1b = result1*pwx1**(result1-1)*pwr1b
        END IF
        n_in_hatb = pwr1*n_inb - n_in_tilde*pwx1b/n_in_hat**2
        IF (pwx1 .LE. 0.0) THEN
          result1b = 0.0
        ELSE
          result1b = pwx1**result1*LOG(pwx1)*pwr1b
        END IF
        arg10 = -(temperature_k-273.15d0)
        CALL POPREAL8(result1)
        CALL POPREAL8(dh1smooth)
        dh1smoothb = 0.0_8
        CALL H_1_SMOOTH_B(arg10, arg10b, 25d0, dummydiffb15, 35d0, &
&                   dummydiffb16, 0d0, 1d0, result1b)
        temperature_kb = temperature_kb - arg10b
        n_in_tildeb = pwx1b/n_in_hat
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          n_in_maxb = n_in_maxb + n_in_tildeb
          n_in_tildeb = 0.0_8
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          n_in_maxb = n_in_maxb + n_in_hatb
          n_in_hatb = 0.0_8
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          arg1 = 0.1296*(ss_iw*100.-10.)
          arg1b = 0.3*EXP(arg1)**(-0.7)*fac_correct_rh*1000.*EXP(arg1)*&
&           n_in_maxb/rho_cfdc
          ss_iwb = 0.1296*100.*arg1b
          n_in_maxb = 0.0_8
        ELSE
          ss_iwb = 0.0_8
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) ss_iwb = ss_iwb + EXP(12.96*ss_iw-0.639)*&
&           fac_correct_rh*0.0587*1.e3*12.96*n_in_maxb/rho_cfdc
        n_inb = n_in_hatb
        arg1 = 0.1296*(ss_i*100.-10.)
        arg1b = 0.3*EXP(arg1)**(-0.7)*fac_correct_rh*1000.*EXP(arg1)*&
&         n_in_tildeb/rho_cfdc
        ss_ib = ss_ib + 0.1296*100.*arg1b
 100    CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) n_inb = 0.0_8
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(n_in)
          result1b = n_in*n_inb
          n_inb = result1*n_inb
          arg10 = -(temperature_k-273.15d0)
          CALL POPREAL8(result1)
          CALL POPREAL8(dh1smooth)
          dh1smoothb = 0.0_8
          CALL H_1_SMOOTH_B(arg10, arg10b, 2.d0, dummydiffb13, 5.d0, &
&                     dummydiffb14, 0.d0, 1.d0, result1b)
          temperature_kb = temperature_kb - arg10b
        END IF
        ss_ib = ss_ib + EXP(12.96d0*ss_i-0.639)*fac_correct_rh*0.0587*&
&         1.e3*12.96d0*n_inb/rho_cfdc
 110    h_frac_sootb = h_frac_sootb + h_frac_biob
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) h_frac_sootb = 0.0_8
        dep_fracb = (1.0_8-aux)*h_frac_sootb
        auxb = (1.d0-dep_frac)*h_frac_sootb
        arg10 = ss_w + 1.0d0
        CALL POPREAL8(aux)
        CALL POPREAL8(dh1smooth)
        dh1smoothb = 0.0_8
        CALL H_1_SMOOTH_B(arg10, arg10b, s_w_0, s_w_0b, 1.d0, &
&                   dummydiffb12, 0.d0, 1.d0, auxb)
        ss_wb = arg10b
        result1b = aux*dep_fracb
        auxb = result1*dep_fracb
        arg2 = s_i_0 + 0.1d0
        arg10 = ss_i + 1d0
        CALL POPREAL8(dh1smooth)
        dh1smoothb = 0.0_8
        CALL H_1_SMOOTH_B(arg10, arg10b, s_i_0, s_i_0b, arg2, arg2b, &
&                   0.d0, 1.d0, result1b)
        ss_ib = ss_ib + arg10b
        CALL POPREAL8(aux)
        result1b = auxb/fac_correct_rh
        arg10 = -(temperature_k-273.15d0)
        CALL POPREAL8(result1)
        CALL POPREAL8(dh1smooth)
        dh1smoothb = 0.0_8
        CALL H_1_SMOOTH_B(arg10, arg10b, 40.d0, dummydiffb10, 50.d0, &
&                   dummydiffb11, 0.d0, 1.d0, result1b)
        temperature_kb = temperature_kb - arg10b
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) h_frac_solob = 0.0_8
        dep_fracb = h_frac_solob
        CALL POPREAL8(dep_frac)
        result1b = aux*dep_fracb
        auxb = result1*dep_fracb
        s_i_0 = 1.2d0
        arg2 = s_i_0 + 0.1d0
        arg10 = ss_i + 1d0
        CALL POPREAL8(result1)
        CALL POPREAL8(dh1smooth)
        dh1smoothb = 0.0_8
        CALL H_1_SMOOTH_B(arg10, arg10b, s_i_0, s_i_0b, arg2, arg2b, 0d0&
&                   , 1d0, result1b)
        ss_ib = ss_ib + arg10b
        arg10 = -(temperature_k-273.15d0)
        CALL POPREAL8(aux)
        CALL POPREAL8(dh1smooth)
        dh1smoothb = 0.0_8
        CALL H_1_SMOOTH_B(arg10, arg10b, 65d0, dummydiffb8, 75d0, &
&                   dummydiffb9, 0d0, 1d0, auxb)
        temperature_kb = temperature_kb - arg10b
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(dh_frac_dust)
          h_frac_dustb = h_frac_dustb - dh_frac_dust*dh_frac_dustb/&
&           h_frac_dust**2
          dh_frac_dustb = dh_frac_dustb/h_frac_dust
        ELSE
          dh_frac_dustb = 0.0_8
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) h_frac_dustb = 0.0_8
        dfdepb = (1.0_8-aux)*dh_frac_dustb
        dep_fracb = (1.0_8-aux)*h_frac_dustb - siw*dh1smooth*&
&         dh_frac_dustb
        siwb = (1.d0-dep_frac)*dh1smooth*dh_frac_dustb
        auxb = (1.d0-dep_frac)*h_frac_dustb - dfdep*dh_frac_dustb
        s_w_0 = 0.97d0
        arg10 = ss_w + 1.0d0
        CALL POPREAL8(aux)
        dh1smoothb = aux*dfdepb + (1.d0-dep_frac)*siw*dh_frac_dustb
        CALL POPREAL8(dh1smooth)
        CALL H_1_SMOOTH_B(arg10, arg10b, s_w_0, s_w_0b, 1.d0, &
&                   dummydiffb7, 0.d0, 1.d0, auxb)
        ss_wb = ss_wb + arg10b
        auxb = result1*dep_fracb + dh1smooth*dfdepb
        result1b = aux*dep_fracb
        pwr1 = 10.**pwy1
        s_i_0 = 1d0 + pwr1
        arg2 = s_i_0 + 0.1d0
        arg10 = ss_i + 1d0
        CALL POPREAL8(dh1smooth)
        CALL H_1_SMOOTH_B(arg10, arg10b, s_i_0, s_i_0b, arg2, arg2b, 0d0&
&                   , 1d0, result1b)
        s_i_0b = s_i_0b + arg2b
        ss_ib = ss_ib + arg10b
        result1b = auxb/fac_correct_rh
        arg10 = -(temperature_k-273.15d0)
        CALL POPREAL8(dh1smooth)
        CALL H_1_SMOOTH_B(arg10, arg10b, 35d0, dummydiffb5, 40d0, &
&                   dummydiffb6, fraction_depnucl_warm_dust, 1d0, &
&                   result1b)
        temperature_kb = temperature_kb - arg10b
        pwr1b = s_i_0b
        pwy1b = 10.**pwy1*LOG(10.)*pwr1b
        tc_hm_degcb = (5.3938e-4*2*tc_hm_degc+8.2584e-6*3*tc_hm_degc**2+&
&         3.1656e-3)*pwy1b
        arg10 = ss_w + 1.0d0
        CALL POPREAL8(dh1smooth)
        CALL H_1_SMOOTH_B(arg10, arg10b, 0.97d0, dummydiffb3, 1d0, &
&                   dummydiffb4, 0d0, 1d0, resb1)
        ss_wb = ss_wb + arg10b
        arg10 = -(temperature_k-273.15)
        CALL POPREAL8(dh1smooth)
        CALL H_1_SMOOTH_B(arg10, arg10b, 35d0, dummydiffb1, 40d0, &
&                   dummydiffb2, fraction_depnucl_warm_dust, 1d0, resb0)
        temperature_kb = temperature_kb + tc_hm_degcb - arg10b
        arg10 = ss_i + 1d0
        CALL POPREAL8(dh1smooth)
        CALL H_1_SMOOTH_B(arg10, arg10b, 1.1d0, dummydiffb, 1.2d0, &
&                   dummydiffb0, 0.0d0, 1d0, resb)
        ss_ib = ss_ib + arg10b
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          ss_iwb = ss_iwb + ss_ib
          ss_ib = 0.0_8
          ss_wb = 0.0_8
        END IF
      ELSE IF (branch .EQ. 2) THEN
        n_grid_sootb = 0.0_8
        d_grid_sootb = 0.0_8
        n_grid_dustb = 0.0_8
        d_grid_dustb = 0.0_8
        siwb = 0.0_8
        ss_wb = 0.0_8
        ss_iwb = 0.0_8
        psi_solob = 0.0_8
      ELSE
        n_grid_sootb = 0.0_8
        d_grid_sootb = 0.0_8
        n_grid_dustb = 0.0_8
        d_grid_dustb = 0.0_8
        siwb = 0.0_8
        ss_wb = 0.0_8
        ss_iwb = 0.0_8
        psi_solob = 0.0_8
      END IF
      siwb = siwb + ss_iwb
      swb = ss_wb
      sib = ss_ib
      a_solob = psi_solob/base_solo_omega
    END IF
  END SUBROUTINE EMPIRICAL_PARAM_PHILLIPS_B
!=======================================================================================
!=======================================================================================
!=======================================================================================
!!====================================================================================
!		EMPIRICAL PARAMETERISATION (Phillips et al. 2013, JAS)
!		contributed by Vaughan Phillips, 2012
!		University of Leeds
! Implementation:   Donifan Barahona donifan.o.barahona@nasa.gov 
!====================================================================================
  SUBROUTINE EMPIRICAL_PARAM_PHILLIPS(temperature_k, p_sat, si, siw, sw&
&   , d_grid_dust, n_grid_dust, ijstop_dust, d_grid_soot, n_grid_soot, &
&   ijstop_soot, d_grid_bio, n_grid_bio, ijstop_bio, a_solo, n_iw, dsh)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: temperature_k, p_sat, si, siw, sw, a_solo
    REAL*8, DIMENSION(2), INTENT(IN) :: d_grid_dust, n_grid_dust
    REAL*8, DIMENSION(1), INTENT(IN) :: d_grid_soot, n_grid_soot, &
&   d_grid_bio, n_grid_bio
    INTEGER, INTENT(IN) :: ijstop_dust, ijstop_soot, ijstop_bio
    REAL*8 :: nin_a_nuc_dust, nin_a_nuc_soot, nin_a_nuc_bio, &
&   nin_a_nuc_solo, num_ic_dust_imm, num_ic_soot_imm, num_ic_bio_imm, &
&   num_ic_solo_imm
!DONIF
    REAL*8, INTENT(INOUT) :: dsh, n_iw
!DONIF
    REAL*8 :: dn_in_dust, dn_in_soot, dn_in_bio, dn_in_solo, dnall, &
&   dnaux, naux, ss_w, dh_frac_dust, dh_frac_soot, dh_frac_solo, aux, &
&   dfdep
    REAL*8 :: rho_cfdc, base_dust_omega, base_soot_philic_omega, &
&   base_bio_omega, alpha_dust, alpha_soot, alpha_bio, &
&   fraction_depnucl_warm_dust, pie, base_solo_omega, temp_max_dust_degc&
&   , temp_max_soot_degc, temp_max_bio_degc, glass_frac
    PARAMETER (base_dust_omega=2.0d-6, base_soot_philic_omega=1.0d-7, &
&   base_bio_omega=0.89d-6, base_solo_omega=5.6d-5, glass_frac=0.5d0, &
&   alpha_dust=2d0/3d0, alpha_soot=1d0/3d0-0.03d0, alpha_bio=0.03d0, &
&   rho_cfdc=50000d0/(287d0*228.15d0), fraction_depnucl_warm_dust=0.15d0&
&   , pie=3.1415926d0, temp_max_dust_degc=-10d0, temp_max_soot_degc=-&
&     15d0, temp_max_bio_degc=-2d0)
    REAL*8, SAVE :: fac_correct_rh=2d0, rho_aida
    REAL*8 :: h_frac_dust, n_in, n_in_dust, n_in_ultra, n_in_dust_ultra&
&   , cihenc_dust, esw, esi, ss_i, n_in_soot_ultra, h_frac_soot, &
&   h_frac_bio, n_in_soot, n_in_bio, n_in_bio_ultra, cihenc_soot, &
&   cihenc_bio, delta_si, delta_t, delta_sw, n_in_max, ss_iw, rho
    REAL*8 :: h_frac_solo, rhi, n_in_solo, n_in_solo_star, cihenc_solo, &
&   psi_solo
    REAL*8 :: mu, s_i_0, rh_crit, s_i_w_warm, s_i_w_cold, s_i_w, &
&   tc_hm_degc
    REAL*8 :: s_w_0, dep_frac, n_in_hat, n_in_tilde
    REAL*8, SAVE :: eps=0.622d0
    INTEGER :: ij
    INTRINSIC SIZE
    INTRINSIC EXP
    INTRINSIC MAX
    INTRINSIC MIN
    REAL*8 :: pwy1
    REAL*8 :: pwr1
    REAL*8 :: result1
    REAL*8 :: arg1
    REAL*8 :: pwx1
    REAL*8 :: x2
    REAL*8 :: x1
    REAL*8 :: max6
    REAL*8 :: max5
    REAL*8 :: max4
    REAL*8 :: max3
    REAL*8 :: max2
    REAL*8 :: max1
    REAL*8 :: arg10
    REAL*8 :: arg2
!intrinsic :: exp, DEXP, SIZE, DBLE
!print *, SIZE(n_grid_dust(:))
    IF (ijstop_dust .NE. SIZE(n_grid_dust)) THEN
      STOP
    ELSE IF (ijstop_soot .NE. SIZE(n_grid_soot)) THEN
      STOP
    ELSE IF (ijstop_bio .NE. SIZE(n_grid_bio)) THEN
      STOP
    ELSE
!default
      dnaux = 12.96
      naux = 0.0
      dnall = dnaux
      dsh = 0.0
      n_iw = 0.0
      nin_a_nuc_dust = 0.0
      nin_a_nuc_soot = 0.0
      nin_a_nuc_bio = 0.0
      nin_a_nuc_solo = 0.0
      num_ic_dust_imm = 0.0
      num_ic_soot_imm = 0.0
      num_ic_bio_imm = 0.0
      num_ic_solo_imm = 0.0
      dn_in_dust = 0.0
      dn_in_soot = 0.0
      dn_in_bio = 0.0
      dn_in_solo = 0.0
      dh_frac_dust = 0.0
      dh_frac_soot = 0.0
      dh_frac_solo = 0.0
      dh1smooth = 0.0
      aux = 0.0
!====================================================================================
!		COMPUTATION BLOCK 
!
!====================================================================================
!
      rho_aida = 90000./(287.*205.)
      rho = p_sat/(287.*temperature_k)
      psi_solo = a_solo/base_solo_omega
!everything is based on supersaturation 
      ss_i = si - 1.0
      ss_w = sw - 1.0
      ss_iw = siw - 1.0
      IF (ss_i .GT. 0.0d0) THEN
        IF (temperature_k .LT. 273.15d0 .AND. temperature_k .GT. 273.15 &
&           - 90.) THEN
!SS_iw = QSW/QSI - 1.
          IF (ss_w .GT. 0.) THEN
            ss_i = ss_iw
            ss_w = 0.0
          END IF
!				S_i_zero = 1.15 !this is taken care of
          arg10 = ss_i + 1d0
          delta_si = H_1_SMOOTH(arg10, 1.1d0, 1.2d0, 0.0d0, 1d0)
          arg10 = -(temperature_k-273.15)
          delta_t = H_1_SMOOTH(arg10, 35d0, 40d0, &
&           fraction_depnucl_warm_dust, 1d0)
          arg10 = ss_w + 1.0d0
          delta_sw = H_1_SMOOTH(arg10, 0.97d0, 1d0, 0d0, 1d0)
          tc_hm_degc = temperature_k - 273.15d0
          pwy1 = 8.2584e-6*tc_hm_degc*tc_hm_degc*tc_hm_degc + 5.3938e-4*&
&           tc_hm_degc*tc_hm_degc + 3.1656e-3*tc_hm_degc - 1.0261d0
          pwr1 = 10.**pwy1
          s_i_0 = 1d0 + pwr1
          s_w_0 = 0.97d0
          s_w_0 = 0.97d0
          arg10 = -(temperature_k-273.15d0)
          result1 = H_1_SMOOTH(arg10, 35d0, 40d0, &
&           fraction_depnucl_warm_dust, 1d0)
          aux = result1/fac_correct_rh
          arg10 = ss_i + 1d0
          arg2 = s_i_0 + 0.1d0
          result1 = H_1_SMOOTH(arg10, s_i_0, arg2, 0d0, 1d0)
          dep_frac = result1*aux
          dfdep = dh1smooth*aux
          arg10 = ss_w + 1.0d0
          aux = H_1_SMOOTH(arg10, s_w_0, 1.d0, 0.d0, 1.d0)
          h_frac_dust = dep_frac + (1.d0-dep_frac)*aux
          dh_frac_dust = dfdep + siw*(1.d0-dep_frac)*dh1smooth - aux*&
&           dfdep
          IF (h_frac_dust .GT. 1.d0) h_frac_dust = 1.d0
          IF (h_frac_dust .GT. 1.0e-6 .AND. h_frac_dust .LT. 1.d0) THEN
            dh_frac_dust = dh_frac_dust/h_frac_dust
          ELSE
            dh_frac_dust = 0.0d0
          END IF
!soluble organics
          s_i_0 = 1.2d0
          arg10 = -(temperature_k-273.15d0)
          aux = H_1_SMOOTH(arg10, 65d0, 75d0, 0d0, 1d0)
          arg10 = ss_i + 1d0
          arg2 = s_i_0 + 0.1d0
          result1 = H_1_SMOOTH(arg10, s_i_0, arg2, 0d0, 1d0)
          dep_frac = result1*aux
          h_frac_solo = dep_frac
          dh_frac_solo = 0.0d0
          IF (h_frac_solo .GT. 1.0e-6 .AND. h_frac_solo .LT. 1.d0) &
&           dh_frac_solo = dh1smooth/h_frac_solo
          IF (h_frac_solo .GT. 1.d0) h_frac_solo = 1.d0
          s_w_0 = 0.97d0
          s_i_0 = 1.3d0
          arg10 = -(temperature_k-273.15d0)
          result1 = H_1_SMOOTH(arg10, 40.d0, 50.d0, 0.d0, 1.d0)
          aux = result1/fac_correct_rh
          arg10 = ss_i + 1d0
          arg2 = s_i_0 + 0.1d0
          result1 = H_1_SMOOTH(arg10, s_i_0, arg2, 0.d0, 1.d0)
          dep_frac = result1*aux
          dfdep = dh1smooth*aux
          arg10 = ss_w + 1.0d0
          aux = H_1_SMOOTH(arg10, s_w_0, 1.d0, 0.d0, 1.d0)
          h_frac_soot = dep_frac + (1.d0-dep_frac)*aux
          IF (h_frac_soot .GT. 1.d0) h_frac_soot = 1.d0
          dh_frac_soot = dfdep + siw*(1d0-dep_frac)*dh1smooth - aux*&
&           dfdep
          IF (h_frac_soot .GT. 1.0e-6 .AND. h_frac_soot .LT. 1.d0) THEN
            dh_frac_soot = dh_frac_soot/h_frac_soot
          ELSE
            dh_frac_soot = 0.0d0
          END IF
          h_frac_bio = h_frac_soot
          IF (temperature_k .LT. 273.15d0 .AND. temperature_k .GE. &
&             273.15d0 - 35.d0) THEN
            n_in = 1.e3*(EXP(12.96d0*ss_i-0.639)/rho_cfdc)*0.0587*&
&             fac_correct_rh
            IF (temperature_k .GT. 273.15 - 5. .AND. temperature_k .LT. &
&               273.15 - 2.) THEN
              arg10 = -(temperature_k-273.15d0)
              result1 = H_1_SMOOTH(arg10, 2.d0, 5.d0, 0.d0, 1.d0)
              n_in = n_in*result1
            END IF
            IF (temperature_k .GE. 273.15 - 2.d0) n_in = 0.d0
            IF (temperature_k .LT. 273.15d0 - 25.d0) THEN
              arg1 = 0.1296*(ss_i*100.-10.)
              n_in_tilde = 1000.*EXP(arg1)**0.3*fac_correct_rh/rho_cfdc
              n_in_hat = n_in
              IF (temperature_k .GE. 273.15 - 30.) n_in_max = 1.e3*(EXP(&
&                 12.96*ss_iw-0.639)/rho_cfdc)*0.0587*fac_correct_rh
              IF (temperature_k .LT. 273.15 - 30.) THEN
                arg1 = 0.1296*(ss_iw*100.-10.)
                n_in_max = 1000.*EXP(arg1)**0.3*fac_correct_rh/rho_cfdc
              END IF
              IF (n_in_hat .GT. n_in_max) n_in_hat = n_in_max
              IF (n_in_tilde .GT. n_in_max) n_in_tilde = n_in_max
              pwx1 = n_in_tilde/n_in_hat
              arg10 = -(temperature_k-273.15d0)
              result1 = H_1_SMOOTH(arg10, 25d0, 35d0, 0d0, 1d0)
              pwr1 = pwx1**result1
              n_in = n_in_hat*pwr1
              IF (n_in .GT. n_in_max) n_in = n_in_max
            END IF
            n_in_dust = 0.
            dn_in_dust = 0.
            IF (temperature_k .LT. 273.15 - 30.) THEN
!DONIF
!this is a simplified derivative of dNds
              dnaux = 3.88
            ELSE
              dnaux = 12.96
            END IF
            naux = 0.0
            DO ij=1,ijstop_dust
              mu = n_in*alpha_dust*h_frac_dust*pie*d_grid_dust(ij)*&
&               d_grid_dust(ij)/base_dust_omega
              naux = (1.-EXP(-mu))*n_grid_dust(ij)
              n_in_dust = n_in_dust + naux
              IF (mu*(n_grid_dust(ij)-naux)*(dnaux+dh_frac_dust) .LT. &
&                 0.0) THEN
                max1 = 0.0
              ELSE
                max1 = mu*(n_grid_dust(ij)-naux)*(dnaux+dh_frac_dust)
              END IF
              dn_in_dust = max1 + dn_in_dust
            END DO
            IF (temperature_k .GT. 273.15 + temp_max_dust_degc - 20. &
&               .AND. temperature_k .LT. 273.15 + temp_max_dust_degc) &
&           THEN
              arg10 = -(temperature_k-273.15d0)
              arg2 = -temp_max_dust_degc + 20d0
              result1 = H_1_SMOOTH(arg10, -temp_max_dust_degc, arg2, 0d0&
&               , 1d0)
              n_in_dust = n_in_dust*result1
            END IF
            IF (temperature_k .GE. 273.15 + temp_max_dust_degc) &
&             n_in_dust = 0.
            n_in_soot = 0.
            dn_in_soot = 0.
            DO ij=1,ijstop_soot
              mu = n_in*alpha_soot*h_frac_soot*pie*d_grid_soot(ij)**2./&
&               base_soot_philic_omega
              naux = (1.-EXP(-mu))*n_grid_soot(ij)
              n_in_soot = n_in_soot + naux
              IF (mu*(n_grid_soot(ij)-naux)*(dnaux+dh_frac_soot) .LT. &
&                 0.0) THEN
                max2 = 0.0
              ELSE
                max2 = mu*(n_grid_soot(ij)-naux)*(dnaux+dh_frac_soot)
              END IF
              dn_in_soot = max2 + dn_in_soot
            END DO
            IF (temperature_k .GT. 273.15 + temp_max_soot_degc - 10. &
&               .AND. temperature_k .LT. 273.15 + temp_max_soot_degc) &
&           THEN
              arg10 = -(temperature_k-273.15d0)
              arg2 = -temp_max_soot_degc + 10d0
              result1 = H_1_SMOOTH(arg10, -temp_max_soot_degc, arg2, 0d0&
&               , 1d0)
              n_in_soot = n_in_soot*result1
            END IF
            IF (temperature_k .GE. 273.15 + temp_max_soot_degc) &
&             n_in_soot = 0.
            n_in_bio = 0.
            dn_in_bio = 0.
            DO ij=1,ijstop_bio
              mu = n_in*alpha_bio*h_frac_bio*pie*d_grid_bio(ij)**2./&
&               base_bio_omega
              mu = n_in*alpha_bio*h_frac_bio
              naux = (1.-EXP(-mu))*n_grid_bio(ij)
!!!!!!!!!!!!!!remember!!!!!!!!!!!!!!!!
!naux =  n_in*ALPHA_bio*H_frac_bio
!!!!!!!!!!!!!!remember!!!!!!!!!!!!!!!!
              n_in_bio = n_in_bio + naux
              IF (mu*(n_grid_bio(ij)-naux)*dnaux .LT. 0.0) THEN
                max3 = 0.0
              ELSE
                max3 = mu*(n_grid_bio(ij)-naux)*dnaux
              END IF
              dn_in_bio = max3 + dn_in_bio
            END DO
            IF (temperature_k .GT. 273.15 + temp_max_bio_degc - 3. .AND.&
&               temperature_k .LT. 273.15 + temp_max_bio_degc) THEN
              arg10 = -(temperature_k-273.15d0)
              arg2 = -temp_max_bio_degc + 3d0
              result1 = H_1_SMOOTH(arg10, -temp_max_bio_degc, arg2, 0d0&
&               , 1d0)
              n_in_bio = n_in_bio*result1
            END IF
            IF (temperature_k .GE. 273.15 + temp_max_bio_degc) n_in_bio&
&              = 0d0
          ELSE
            n_in = 0.
            n_in_ultra = 0.
            n_in_dust = 0.
            n_in_soot = 0.
            n_in_bio = 0.
          END IF
          IF (temperature_k .LT. 273.15 - 35.) THEN
            arg1 = 0.1296*(ss_i*100.-10.)
            n_in_ultra = 1000.*EXP(arg1)**0.3*fac_correct_rh/rho_cfdc
!DONIF simplified treatment of derivative asusming dH small 
            dnaux = 3.88
            naux = 0.0
            rhi = (ss_i+1.)*100.
            IF (rhi .LT. 0.) rhi = 0.
            n_in_solo_star = 1000.e6*(7.7211e-5*rhi-9.2688e-3)/rho_aida
            n_in_dust_ultra = 0.
            dn_in_dust = 0.0
            DO ij=1,ijstop_dust
              mu = n_in_ultra*alpha_dust*h_frac_dust*pie*d_grid_dust(ij)&
&               **2./base_dust_omega
              naux = (1.-EXP(-mu))*n_grid_dust(ij)
              n_in_dust_ultra = n_in_dust_ultra + naux
              IF (mu*(n_grid_dust(ij)-naux)*(dnaux+dh_frac_dust) .LT. &
&                 0.0) THEN
                max4 = 0.0
              ELSE
                max4 = mu*(n_grid_dust(ij)-naux)*(dnaux+dh_frac_dust)
              END IF
              dn_in_dust = max4 + dn_in_dust
            END DO
            n_in_soot_ultra = 0.0
            dn_in_soot = 0.0
            DO ij=1,ijstop_soot
              mu = n_in_ultra*alpha_soot*h_frac_soot*pie*d_grid_soot(ij)&
&               **2./base_soot_philic_omega
              naux = (1.-EXP(-mu))*n_grid_soot(ij)
              n_in_soot_ultra = n_in_soot_ultra + naux
              IF (mu*(n_grid_soot(ij)-naux)*(dnaux+dh_frac_soot) .LT. &
&                 0.0) THEN
                max5 = 0.0
              ELSE
                max5 = mu*(n_grid_soot(ij)-naux)*(dnaux+dh_frac_soot)
              END IF
              dn_in_soot = max5 + dn_in_soot
            END DO
            n_in_bio_ultra = 0.
            dn_in_bio = 0.0
            DO ij=1,ijstop_bio
              mu = n_in_ultra*alpha_bio*h_frac_bio*pie*d_grid_bio(ij)**&
&               2./base_bio_omega
              naux = (1.-EXP(-mu))*n_grid_bio(ij)
              n_in_bio_ultra = n_in_bio_ultra + naux
              IF (mu*(n_grid_bio(ij)-naux)*dnaux .LT. 0.0) THEN
                max6 = 0.0
              ELSE
                max6 = mu*(n_grid_bio(ij)-naux)*dnaux
              END IF
              dn_in_bio = max6 + dn_in_bio
            END DO
            n_in_solo = psi_solo*glass_frac*h_frac_solo*n_in_solo_star
            x1 = psi_solo*glass_frac*(h_frac_solo*77211.0*100.0/rho_aida&
&             +n_in_solo_star*dh_frac_solo)
            IF (x1 .LT. 0.0) THEN
              dn_in_solo = 0.0
            ELSE
              dn_in_solo = x1
            END IF
          ELSE
            n_in_ultra = 0.
            n_in_dust_ultra = 0.
            n_in_soot_ultra = 0.
            n_in_solo = 0.
            n_in_bio_ultra = 0.
          END IF
          n_in_dust = n_in_dust + n_in_dust_ultra
          n_in_soot = n_in_soot + n_in_soot_ultra
          n_in_bio = n_in_bio + n_in_bio_ultra
! PROBLEM:  how to ensure that the frozen fraction does not exceed 1 ?
          IF (n_in_dust + n_in_bio + n_in_soot + n_in_solo .GT. 0.) THEN
            cihenc_dust = n_in_dust - nin_a_nuc_dust
            IF (cihenc_dust .LT. 0.) cihenc_dust = 0.
            cihenc_soot = n_in_soot - nin_a_nuc_soot
            IF (cihenc_soot .LT. 0.) cihenc_soot = 0.
            cihenc_bio = n_in_bio - nin_a_nuc_bio
            IF (cihenc_bio .LT. 0.) cihenc_bio = 0.
            cihenc_solo = n_in_solo - nin_a_nuc_solo
            IF (cihenc_solo .LT. 0.) cihenc_solo = 0.
            n_iw = n_iw + cihenc_dust
            nin_a_nuc_dust = nin_a_nuc_dust + cihenc_dust
            num_ic_dust_imm = num_ic_dust_imm + cihenc_dust
            n_iw = n_iw + cihenc_soot
            nin_a_nuc_soot = nin_a_nuc_soot + cihenc_soot
            num_ic_soot_imm = num_ic_soot_imm + cihenc_soot
            n_iw = n_iw + cihenc_bio
            nin_a_nuc_bio = nin_a_nuc_bio + cihenc_bio
            num_ic_bio_imm = num_ic_bio_imm + cihenc_bio
            n_iw = n_iw + cihenc_solo
            nin_a_nuc_solo = nin_a_nuc_solo + cihenc_solo
            num_ic_solo_imm = num_ic_solo_imm + cihenc_solo
          END IF
        END IF
      END IF
!DONIF
      dnall = dn_in_dust + dn_in_bio + n_in_soot + n_in_solo
      IF (dnall .GT. 0. .AND. n_iw .GT. 0.0) THEN
        IF (n_iw/dnall .GT. ss_i) THEN
          x2 = ss_i
        ELSE
          x2 = n_iw/dnall
        END IF
        IF (x2 .LT. 0.005) THEN
          dsh = 0.005
        ELSE
          dsh = x2
        END IF
      ELSE
        dsh = 0.005
      END IF
    END IF
  END SUBROUTINE EMPIRICAL_PARAM_PHILLIPS
  REAL*8 FUNCTION H_1(x, x_1, x_2, hlo)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: hlo, x, x_1, x_2
    IF (x .GE. x_2) h_1 = 1
    IF (x .LE. x_1) h_1 = hlo
    IF (x .GT. x_1 .AND. x .LT. x_2) h_1 = (x-x_1)/(x_2-x_1)
    IF (x_2 .LE. x_1) THEN
      STOP
    ELSE
      RETURN
    END IF
  END FUNCTION H_1
!  Differentiation of h_1_smooth_d in reverse (adjoint) mode:
!   gradient     of useful results: dh1smoothd dh1smooth h_1_smooth
!                xd h_1_smooth_d
!   with respect to varying inputs: dh1smoothd dh1smooth x_1 h_1_smooth
!                x_2 xd x
!  Differentiation of h_1_smooth in forward (tangent) mode:
!   variations   of useful results: dh1smooth h_1_smooth
!   with respect to varying inputs: dh1smooth x
  SUBROUTINE H_1_SMOOTH_D_B(x, xb, xd, xdb, x_1, x_1b, x_2, x_2b, hlo, &
&   hhi, h_1_smooth, h_1_smoothb, h_1_smooth_db)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: hlo, hhi, x, x_1, x_2
    REAL*8 :: xb, x_1b, x_2b
    REAL*8, INTENT(IN) :: xd
    REAL*8 :: xdb
    REAL*8 :: a_0, a_1, a_2, a_3, a, b
    REAL*8 :: a_0b, a_1b, a_2b, a_3b, ab, bb
    INTRINSIC MIN
    INTRINSIC MAX
    REAL*8 :: h_1_smooth
    REAL*8 :: h_1_smoothb
    INTEGER :: branch
    REAL*8 :: h_1_smooth_db
    REAL*8 :: h_1_smooth_d
    REAL*8 :: temp0
    REAL*8 :: tempb6
    REAL*8 :: tempb5
    REAL*8 :: tempb4
    REAL*8 :: tempb3
    REAL*8 :: tempb2
    REAL*8 :: tempb1
    REAL*8 :: tempb0
    REAL*8 :: tempb
    REAL*8 :: temp
    IF (x .GE. x_2) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (x .LE. x_1) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (x .GE. x_2) THEN
      CALL PUSHREAL8(dh1smooth)
      dh1smooth = 0.0d0
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (x .LE. x_1) THEN
      CALL PUSHREAL8(dh1smooth)
      dh1smooth = 0.0d0
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (x .GT. x_1 .AND. x .LT. x_2) THEN
      a = 6d0*(hlo-hhi)/(x_2**3d0-x_1**3d0+3d0*(x_2*x_1*x_1-x_1*x_2*x_2)&
&       )
      a_3 = a/3d0
      a_2 = -(a/2d0*(x_1+x_2))
      a_1 = a*x_2*x_1
      CALL PUSHREAL8(dh1smooth)
      dh1smooth = a_1 + 2.0d0*a_2*x + 3.0d0*a_3*x*x
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (dh1smooth .GT. 1.0e6) THEN
      CALL PUSHREAL8(dh1smooth)
      dh1smooth = 1.0e6
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHREAL8(dh1smooth)
      dh1smooth = dh1smooth
      CALL PUSHCONTROL1B(1)
    END IF
    IF (dh1smooth .LT. zero_par) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (x_2 .LE. x_1) THEN
      STOP
    ELSE
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        dh1smoothdb = 0.0_8
        dh1smoothb = 0.0_8
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8(dh1smooth)
        dh1smoothdb = 0.0_8
        dh1smoothb = 0.0_8
      ELSE
        CALL POPREAL8(dh1smooth)
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        tempb2 = a_3*h_1_smooth_db
        tempb1 = x*tempb2
        temp0 = xd*x + x*xd
        tempb0 = a_2*h_1_smooth_db
        tempb = 3.0d0*a_3*dh1smoothdb
        CALL POPREAL8(dh1smooth)
        a_1b = x*h_1_smoothb + xd*h_1_smooth_db + dh1smoothb
        a_2b = 2.0d0*xd*dh1smoothdb + (xd*x+x*xd)*h_1_smooth_db + x**2*&
&         h_1_smoothb + 2.0d0*x*dh1smoothb
        xb = 2*xd*tempb + 2*xd*tempb0 + 2*xd*tempb1 + (xd*2*x+temp0)*&
&         tempb2 + (a_3*3*x**2+a_2*2*x+a_1)*h_1_smoothb + (a_3*3.0d0*2*x&
&         +2.0d0*a_2)*dh1smoothb
        a_3b = 3.0d0*(xd*x+x*xd)*dh1smoothdb + (temp0*x+x**2*xd)*&
&         h_1_smooth_db + x**3*h_1_smoothb + 3.0d0*x**2*dh1smoothb
        xdb = xdb + a_1*h_1_smooth_db + 2*x*tempb0 + 2*x*tempb1 + x**2*&
&         tempb2 + 2*x*tempb + 2.0d0*a_2*dh1smoothdb
        a_0b = h_1_smoothb
        bb = a_0b
        tempb3 = -(x_1**2*bb)
        ab = x_1*x_2*a_1b + a_3b/3d0 - (x_1+x_2)*a_2b/2d0 + x_2*tempb3/&
&         2d0 + x_1**3d0*bb/6d0
        tempb6 = -(a*a_2b/2d0)
        temp = x_2**3d0 - x_1**3d0 + 3d0*(x_2*x_1**2-x_1*x_2**2)
        tempb4 = -((hlo-hhi)*6d0*ab/temp**2)
        tempb5 = 3d0*tempb4
        x_1b = a*x_2*a_1b - 3d0*x_1**2.0D0*tempb4 + (x_2*2*x_1-x_2**2)*&
&         tempb5 + tempb6 + (a*3d0*x_1**2.0D0/6d0-a*x_2*2*x_1/2d0)*bb
        x_2b = x_1*a*a_1b + 3d0*x_2**2.0D0*tempb4 + (x_1**2-x_1*2*x_2)*&
&         tempb5 + tempb6 + a*tempb3/2d0
        dh1smoothdb = 0.0_8
        dh1smoothb = 0.0_8
        h_1_smoothb = 0.0_8
      ELSE
        x_1b = 0.0_8
        x_2b = 0.0_8
        xb = 0.0_8
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8(dh1smooth)
        dh1smoothdb = 0.0_8
        dh1smoothb = 0.0_8
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8(dh1smooth)
        dh1smoothdb = 0.0_8
        dh1smoothb = 0.0_8
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) h_1_smoothb = 0.0_8
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) h_1_smoothb = 0.0_8
    END IF
  END SUBROUTINE H_1_SMOOTH_D_B
!  Differentiation of h_1_smooth in forward (tangent) mode:
!   variations   of useful results: dh1smooth h_1_smooth
!   with respect to varying inputs: dh1smooth x
  REAL*8 FUNCTION H_1_SMOOTH_D(x, xd, x_1, x_2, hlo, hhi, h_1_smooth)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: hlo, hhi, x, x_1, x_2
    REAL*8, INTENT(IN) :: xd
    REAL*8 :: a_0, a_1, a_2, a_3, a, b
    INTRINSIC MIN
    INTRINSIC MAX
    REAL*8 :: h_1_smooth
    IF (x .GE. x_2) h_1_smooth = hhi
    IF (x .LE. x_1) h_1_smooth = hlo
    IF (x .GE. x_2) THEN
      dh1smooth = 0.0d0
      dh1smoothd = 0.0_8
    END IF
    IF (x .LE. x_1) THEN
      dh1smooth = 0.0d0
      dh1smoothd = 0.0_8
    END IF
    IF (x .GT. x_1 .AND. x .LT. x_2) THEN
      a = 6d0*(hlo-hhi)/(x_2**3d0-x_1**3d0+3d0*(x_2*x_1*x_1-x_1*x_2*x_2)&
&       )
      a_3 = a/3d0
      a_2 = -(a/2d0*(x_1+x_2))
      a_1 = a*x_2*x_1
      b = hlo + a*x_1**3d0/6d0 - a*x_1*x_1*x_2/2d0
      a_0 = b
      h_1_smooth_d = a_1*xd + a_2*(xd*x+x*xd) + a_3*((xd*x+x*xd)*x+x**2*&
&       xd)
      h_1_smooth = a_0 + a_1*x + a_2*x*x + a_3*x*x*x
      dh1smoothd = 2.0d0*a_2*xd + 3.0d0*a_3*(xd*x+x*xd)
      dh1smooth = a_1 + 2.0d0*a_2*x + 3.0d0*a_3*x*x
    ELSE
      h_1_smooth_d = 0.0_8
    END IF
    IF (dh1smooth .GT. 1.0e6) THEN
      dh1smooth = 1.0e6
      dh1smoothd = 0.0_8
    ELSE
      dh1smooth = dh1smooth
    END IF
    IF (dh1smooth .LT. zero_par) THEN
      dh1smooth = zero_par
      dh1smoothd = 0.0_8
    ELSE
      dh1smooth = dh1smooth
    END IF
    IF (x_2 .LE. x_1) THEN
      STOP
    ELSE
      RETURN
    END IF
  END FUNCTION H_1_SMOOTH_D
!  Differentiation of h_1_smooth in reverse (adjoint) mode:
!   gradient     of useful results: dh1smooth h_1_smooth
!   with respect to varying inputs: dh1smooth x_1 x_2 x
  SUBROUTINE H_1_SMOOTH_B(x, xb, x_1, x_1b, x_2, x_2b, hlo, hhi, &
&   h_1_smoothb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: hlo, hhi, x, x_1, x_2
    REAL*8 :: xb, x_1b, x_2b
    REAL*8 :: a_0, a_1, a_2, a_3, a, b
    REAL*8 :: a_0b, a_1b, a_2b, a_3b, ab, bb
    INTRINSIC MIN
    INTRINSIC MAX
    INTEGER :: branch
    REAL*8 :: h_1_smoothb
    REAL*8 :: h_1_smooth
    REAL*8 :: tempb2
    REAL*8 :: tempb1
    REAL*8 :: tempb0
    REAL*8 :: tempb
    REAL*8 :: temp
    IF (x .GE. x_2) THEN
      CALL PUSHREAL8(dh1smooth)
      dh1smooth = 0.0d0
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (x .LE. x_1) THEN
      CALL PUSHREAL8(dh1smooth)
      dh1smooth = 0.0d0
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (x .GT. x_1 .AND. x .LT. x_2) THEN
      a = 6d0*(hlo-hhi)/(x_2**3d0-x_1**3d0+3d0*(x_2*x_1*x_1-x_1*x_2*x_2)&
&       )
      a_3 = a/3d0
      a_2 = -(a/2d0*(x_1+x_2))
      a_1 = a*x_2*x_1
      CALL PUSHREAL8(dh1smooth)
      dh1smooth = a_1 + 2.0d0*a_2*x + 3.0d0*a_3*x*x
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (dh1smooth .GT. 1.0e6) THEN
      CALL PUSHREAL8(dh1smooth)
      dh1smooth = 1.0e6
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHREAL8(dh1smooth)
      dh1smooth = dh1smooth
      CALL PUSHCONTROL1B(1)
    END IF
    IF (dh1smooth .LT. zero_par) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (x_2 .LE. x_1) THEN
      STOP
    ELSE
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) dh1smoothb = 0.0_8
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8(dh1smooth)
        dh1smoothb = 0.0_8
      ELSE
        CALL POPREAL8(dh1smooth)
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8(dh1smooth)
        a_1b = x*h_1_smoothb + dh1smoothb
        a_2b = x**2*h_1_smoothb + 2.0d0*x*dh1smoothb
        xb = (a_3*3*x**2+a_2*2*x+a_1)*h_1_smoothb + (a_3*3.0d0*2*x+2.0d0&
&         *a_2)*dh1smoothb
        a_3b = x**3*h_1_smoothb + 3.0d0*x**2*dh1smoothb
        a_0b = h_1_smoothb
        bb = a_0b
        tempb = -(x_1**2*bb)
        ab = x_1*x_2*a_1b + a_3b/3d0 - (x_1+x_2)*a_2b/2d0 + x_2*tempb/&
&         2d0 + x_1**3d0*bb/6d0
        tempb2 = -(a*a_2b/2d0)
        temp = x_2**3d0 - x_1**3d0 + 3d0*(x_2*x_1**2-x_1*x_2**2)
        tempb0 = -((hlo-hhi)*6d0*ab/temp**2)
        tempb1 = 3d0*tempb0
        x_1b = a*x_2*a_1b - 3d0*x_1**2.0D0*tempb0 + (x_2*2*x_1-x_2**2)*&
&         tempb1 + tempb2 + (a*3d0*x_1**2.0D0/6d0-a*x_2*2*x_1/2d0)*bb
        x_2b = x_1*a*a_1b + 3d0*x_2**2.0D0*tempb0 + (x_1**2-x_1*2*x_2)*&
&         tempb1 + tempb2 + a*tempb/2d0
        dh1smoothb = 0.0_8
      ELSE
        x_1b = 0.0_8
        x_2b = 0.0_8
        xb = 0.0_8
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8(dh1smooth)
        dh1smoothb = 0.0_8
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8(dh1smooth)
        dh1smoothb = 0.0_8
      END IF
    END IF
  END SUBROUTINE H_1_SMOOTH_B
  REAL*8 FUNCTION H_1_SMOOTH(x, x_1, x_2, hlo, hhi)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: hlo, hhi, x, x_1, x_2
    REAL*8 :: a_0, a_1, a_2, a_3, a, b
    INTRINSIC MIN
    INTRINSIC MAX
    IF (x .GE. x_2) h_1_smooth = hhi
    IF (x .LE. x_1) h_1_smooth = hlo
    IF (x .GE. x_2) dh1smooth = 0.0d0
    IF (x .LE. x_1) dh1smooth = 0.0d0
    IF (x .GT. x_1 .AND. x .LT. x_2) THEN
      a = 6d0*(hlo-hhi)/(x_2**3d0-x_1**3d0+3d0*(x_2*x_1*x_1-x_1*x_2*x_2)&
&       )
      a_3 = a/3d0
      a_2 = -(a/2d0*(x_1+x_2))
      a_1 = a*x_2*x_1
      b = hlo + a*x_1**3d0/6d0 - a*x_1*x_1*x_2/2d0
      a_0 = b
      h_1_smooth = a_0 + a_1*x + a_2*x*x + a_3*x*x*x
      dh1smooth = a_1 + 2.0d0*a_2*x + 3.0d0*a_3*x*x
    END IF
    IF (dh1smooth .GT. 1.0e6) THEN
      dh1smooth = 1.0e6
    ELSE
      dh1smooth = dh1smooth
    END IF
    IF (dh1smooth .LT. zero_par) THEN
      dh1smooth = zero_par
    ELSE
      dh1smooth = dh1smooth
    END IF
    IF (x_2 .LE. x_1) THEN
      STOP
    ELSE
      RETURN
    END IF
  END FUNCTION H_1_SMOOTH
  

END MODULE ICE_AER_CLOUD_D_B
